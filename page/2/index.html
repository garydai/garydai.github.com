<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/22/2019-11-22-java-reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/22/2019-11-22-java-reference/" itemprop="url">java 引用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-22T00:00:00+08:00">
                2019-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java-引用"><a href="#java-引用" class="headerlink" title="java 引用"></a>java 引用</h1><h4 id="强引用StrongReference"><a href="#强引用StrongReference" class="headerlink" title="强引用StrongReference"></a>强引用StrongReference</h4><p>垃圾回收的时候，即使内存不足也不会回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h4 id="软引用SoftReferenc"><a href="#软引用SoftReferenc" class="headerlink" title="软引用SoftReferenc"></a>软引用SoftReferenc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javalearning;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 虚拟机参数配置</span></span><br><span class="line"><span class="comment"> * -Xms256m</span></span><br><span class="line"><span class="comment"> * -Xmx1024m</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*软引用对象中指向了一个长度为300000000个元素的整形数组*/</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">int</span>[]&gt; softReference = </span><br><span class="line">                <span class="keyword">new</span> SoftReference&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">300000000</span>]);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*主动调用一次gc,由于此时JVM的内存够用，此时softReference引用的对象未被回收*/</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*消耗内存,会导致一次自动的gc,此时JVM的内存不够用</span></span><br><span class="line"><span class="comment">         *就回收softReference对象中指向的数组对象*/</span></span><br><span class="line">        <span class="keyword">int</span>[] strongReference = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">         </span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</p>
<p>软引用可用来实现内存敏感的高速缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyObject aRef = <span class="keyword">new</span> MyObject();</span><br><span class="line">SoftReference aSoftRef=<span class="keyword">new</span> SoftReference(aRef);</span><br><span class="line">aRef = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//现在只有一个软引用指向MyObject的这个对象，</span></span><br><span class="line"><span class="comment">//如果这个对象还没有被回收，可以把他再次变为强引用</span></span><br><span class="line"><span class="keyword">if</span>(aSoftRef.get() != <span class="keyword">null</span>)</span><br><span class="line">  MyObject bRef = aSoftRef.get();</span><br><span class="line"><span class="comment">//这个时候MyObject这个对象又变成强引用</span></span><br></pre></td></tr></table></figure>

<p>除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用</p>
<p>所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。</p>
<h4 id="弱引用WeakReferenc"><a href="#弱引用WeakReferenc" class="headerlink" title="弱引用WeakReferenc"></a>弱引用WeakReferenc</h4><p>当JVM进行垃圾回收时，无论内存是否充足，都会回收仅被弱引用关联的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javalearning;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*若引用对象中指向了一个长度为1000个元素的整形数组*/</span></span><br><span class="line">        WeakReference&lt;String[]&gt; weakReference = </span><br><span class="line">                <span class="keyword">new</span> WeakReference&lt;String[]&gt;(<span class="keyword">new</span> String[<span class="number">1000</span>]);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*未执行gc,目前仅被弱引用指向的对象还未被回收，所以结果不是null*/</span>     </span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*执行一次gc,即使目前JVM的内存够用,但还是回收仅被弱引用指向的对象*/</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="幻象引用PhantomReference"><a href="#幻象引用PhantomReference" class="headerlink" title="幻象引用PhantomReference"></a>幻象引用PhantomReference</h4><p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收</p>
<h4 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h4><p>当gc（垃圾回收线程）准备回收一个对象时，如果发现它还仅有软引用(或弱引用，或虚引用)指向它，就会在回收该对象之前，把这个软引用（或弱引用，或虚引用）加入到与之关联的引用队列</p>
<p>如果一个软引用（或弱引用，或虚引用）<strong>对象本身</strong>在引用队列中，就说明该引用对象所<strong>指向的对象</strong>被回收了</p>
<p>当软引用（或弱引用，或虚引用）对象所指向的对象被回收了，那么这个引用对象本身就没有价值了，如果程序中存在大量的这类对象（注意，我们创建的软引用、弱引用、虚引用对象本身是个强引用，不会自动被gc回收），就会浪费内存。因此我们这就可以手动回收位于引用队列中的引用对象本身</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javalearning;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueneDemo</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*创建引用队列*/</span></span><br><span class="line">        ReferenceQueue&lt;SoftReference&lt;<span class="keyword">int</span>[]&gt;&gt; rq = </span><br><span class="line">                <span class="keyword">new</span> ReferenceQueue&lt;SoftReference&lt;<span class="keyword">int</span>[]&gt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*创建一个软引用数组，每一个对象都是软引用类型*/</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">int</span>[]&gt;[] srArr = <span class="keyword">new</span> SoftReference[<span class="number">1000</span>];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; srArr.length; i++)&#123;</span><br><span class="line">            srArr[i] = <span class="keyword">new</span> SoftReference(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">300000</span>], rq);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*（可能）在gc前保留下了三个强引用*/</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = srArr[<span class="number">30</span>].get();</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = srArr[<span class="number">60</span>].get();</span><br><span class="line">        <span class="keyword">int</span>[] arr3 = srArr[<span class="number">90</span>].get();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*占用内存，会导致一次gc，使得只有软引用指向的对象被回收*/</span></span><br><span class="line">        <span class="keyword">int</span>[] strongRef = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200000000</span>];</span><br><span class="line">         </span><br><span class="line">        Object x;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((x = rq.poll()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(idx &lt; srArr.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x == srArr[idx])&#123;</span><br><span class="line">                    System.out.println(<span class="string">"free "</span> + x);</span><br><span class="line">                    srArr[idx] = <span class="keyword">null</span>; <span class="comment">/*手动释放内存*/</span></span><br><span class="line">                    n++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*当然最简单的方法是通过isEnqueued()判断一个软引用方法是否在</span></span><br><span class="line"><span class="comment">         * 队列中，上面的方法只是举例</span></span><br><span class="line"><span class="comment">         int n = 0;</span></span><br><span class="line"><span class="comment">         for(int i = 0; i &lt; srArr.length; i++)&#123;</span></span><br><span class="line"><span class="comment">            if(srArr[i].isEnqueued())&#123;</span></span><br><span class="line"><span class="comment">                srArr[i] = null;</span></span><br><span class="line"><span class="comment">                n++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         &#125;  </span></span><br><span class="line"><span class="comment">        */</span>     </span><br><span class="line">        System.out.println(<span class="string">"recycle  "</span> + n + <span class="string">"  SoftReference Object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://juejin.im/post/5c01427ef265da6175737e14" target="_blank" rel="noopener">https://juejin.im/post/5c01427ef265da6175737e14</a></p>
<p><a href="https://www.cnblogs.com/nullzx/p/7406151.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/7406151.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/21/2019-11-21-java-io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/21/2019-11-21-java-io/" itemprop="url">java io</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-21T00:00:00+08:00">
                2019-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java-io"><a href="#java-io" class="headerlink" title="java io"></a>java io</h1><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191121151136366.png" alt="image-20191121151136366"></p>
<p><img src="/Users/daitechang/Documents/garydai.github.com/_posts/pic/image-20191121151124100.png" alt="image-20191121151124100"></p>
<h3 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h3><p>NIO 的 Buffer 除了做了缓冲块优化之外，还提供了一个可以直接访问物理内存的类 DirectBuffer。普通的 Buffer 分配的是 JVM 堆内存，而 DirectBuffer 是直接分配物理内存 (非堆内存)</p>
<p>数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而在 Java 中，在用户空间中又存在一个拷贝，那就是从 Java 堆内存中拷贝到临时的直接内存中，通过临时的直接内存拷贝到内存空间中去。此时的直接内存和堆内存都是属于用户空间</p>
<p>由于 DirectBuffer 申请的是非 JVM 的物理内存，所以创建和销毁的代价很高。DirectBuffer 申请的内存并不是直接由 JVM 负责垃圾回收，但在 DirectBuffer 包装类被回收时，会通过 Java Reference 机制来释放该内存块</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/14/2019-11-14-nat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/14/2019-11-14-nat/" itemprop="url">nat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-14T00:00:00+08:00">
                2019-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="nat"><a href="#nat" class="headerlink" title="nat"></a>nat</h1><p>网络地址转换</p>
<h3 id="snat"><a href="#snat" class="headerlink" title="snat"></a>snat</h3><p>网络包出口替换原地址</p>
<p>MASQUERADE，地址伪装，算是snat中的一种特例，可以实现自动化的snat。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables-t nat -A POSTROUTING -s 10.8.0.0&#x2F;255.255.255.0 -o eth0 -j SNAT --to-source192.168.5.3-192.168.5.5</span><br><span class="line"></span><br><span class="line">iptables-t nat -A POSTROUTING -s 10.8.0.0&#x2F;255.255.255.0 -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure>



<p>如此配置的话，不用指定SNAT的目标ip了，不管现在eth0的出口获得了怎样的动态ip，MASQUERADE会自动读取eth0现在的ip地址然后做SNAT出去，这样就实现了很好的动态SNAT地址转换。</p>
<h3 id="dnat"><a href="#dnat" class="headerlink" title="dnat"></a>dnat</h3><p>网络包进口替换目标地址</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://blog.csdn.net/jk110333/article/details/8229828" target="_blank" rel="noopener">https://blog.csdn.net/jk110333/article/details/8229828</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/2019-11-10-string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/10/2019-11-10-string/" itemprop="url">string</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-10T00:00:00+08:00">
                2019-11-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191110211250652.png" alt="image-20191110211250652"></p>
<h3 id="全局字符串池（string-pool也有叫做string-literal-pool）"><a href="#全局字符串池（string-pool也有叫做string-literal-pool）" class="headerlink" title="全局字符串池（string pool也有叫做string literal pool）"></a>全局字符串池（string pool也有叫做string literal pool）</h3><p>全局字符串池里的内容是在类加载完成，经过<strong>验证，准备阶段</strong>之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（<strong>记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。</strong>）。<br>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</p>
<h3 id="class文件常量池（class-constant-pool）"><a href="#class文件常量池（class-constant-pool）" class="headerlink" title="class文件常量池（class constant pool）"></a>class文件常量池（class constant pool）</h3><p>class文件存放编译器生成的<strong>各种字面量(Literal)和符号引用(Symbolic References)</strong></p>
<h3 id="运行时常量池（runtime-constant-pool）"><a href="#运行时常量池（runtime-constant-pool）" class="headerlink" title="运行时常量池（runtime constant pool）"></a>运行时常量池（runtime constant pool）</h3><p>而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中。class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过<strong>解析</strong>（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 &#x3D; &quot;abc&quot;;</span><br><span class="line">String str2 &#x3D; new String(&quot;def&quot;);</span><br><span class="line">String str3 &#x3D; &quot;abc&quot;;</span><br><span class="line">String str4 &#x3D; str2.intern();</span><br><span class="line">String str5 &#x3D; &quot;def&quot;;</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str3);&#x2F;&#x2F;true</span><br><span class="line">System.out.println(str2 &#x3D;&#x3D; str4);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(str4 &#x3D;&#x3D; str5);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p>上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致</p>
<p>在堆中会有一个”abc”实例，全局StringTable中存放着”abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是”def”的实例对象，并且StringTable中存储一个”def”的引用值，还有一个是new出来的一个”def”的实例对象，与上面那个是不同的实例，<strong>当在解析str3的时候查找StringTable</strong>，里面有”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值，最后str5在解析的时候就也是指向存在于StringTable中的”def”的引用值</p>
<ul>
<li>1.全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。</li>
<li>2.class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</li>
<li>3.运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</li>
</ul>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://time.geekbang.org/column/article/97215" target="_blank" rel="noopener">https://time.geekbang.org/column/article/97215</a></p>
<p><a href="https://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/" target="_blank" rel="noopener">https://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/</a></p>
<p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/09/2019-11-9-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/09/2019-11-9-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url">网络协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-09T00:00:00+08:00">
                2019-11-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>网络跳线</p>
<h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>ARP、VLAN、STP</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>ICMP、IP、OSPF、BGP、IPSec、GRE</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>UDP、TCP</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>DHCP、HTTP、HTTPS、RTMP、P2P、DNS、GTP、RPC</p>
<h5 id="怎么找到目标地址的mac地址"><a href="#怎么找到目标地址的mac地址" class="headerlink" title="怎么找到目标地址的mac地址"></a>怎么找到目标地址的mac地址</h5><p>子网内，用mac定位目标，子网外用ip定位</p>
<p>如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191110092522089.png" alt="image-20191110092522089"></p>
<h6 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h6><p>知道ip地址求mac地址</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191110095151691.png" alt="image-20191110095151691"></p>
<h5 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h5><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191109120438329.png" alt="image-20191109120438329"></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191109120658084.png" alt="image-20191109120658084"></p>
<p>192.168.0.x 是最常用的私有 IP 地址。你家里有 Wi-Fi，对应就会有一个 IP 地址。一般你家里地上网设备不会超过 256 个，所以 /24 基本就够了。有时候我们也能见到 /16 的 CIDR，这两种是最常见的</p>
<h5 id="dhcp"><a href="#dhcp" class="headerlink" title="dhcp"></a>dhcp</h5><p>新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 地址为 255.255.255.255。广播包封装了 UDP，UDP 封装了 BOOTP，DHCP Server分配一个ip给新来的机器，要保证mac地址唯一。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>根据mac地址转发网络包，第一次不知道对应的端口，广播所有端口，然后缓存正确的端口</p>
<ol>
<li>在划分vlan的前提下可以实现多个广播域，每个接口都是一个单独的冲突域</li>
<li>通过自我学习的方法可以构建出CAM表，并基于CAM进行转发数据。</li>
<li>支持生成树算法。可以构建出物理有环，逻辑无环的网络</li>
</ol>
<h6 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h6><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191110105604643.png" alt="image-20191110105604643"></p>
<p>相同 VLAN 的包，才会互相转发，不同 VLAN 的包，是看不到的</p>
<p>交换机之间用Trunk口连接</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191210163357462.png" alt="image-20191210163357462"></p>
<p><a href="https://baijiahao.baidu.com/s?id=1628398215665219628&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1628398215665219628&amp;wfr=spider&amp;for=pc</a></p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫作路由表</p>
<h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><p>可靠连接；如果对方没有回复，会不断重试</p>
<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191203091727623.png" alt="image-20191203091727623"></p>
<p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。服务端调用 accept 函数，其实是在第一个队列中拿出一个已经完成的连接进行处理。如果还没有完成就阻塞等待</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/04/2019-11-4-thread_local/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/04/2019-11-4-thread_local/" itemprop="url">thread_local</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-04T00:00:00+08:00">
                2019-11-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.ThreadLocalMap;</span><br></pre></td></tr></table></figure>

<ol>
<li>Thread: 当前线程，可以通过Thread.currentThread()获取。</li>
<li>ThreadLocal：我们的static ThreadLocal变量。</li>
<li>Object: 当前线程共享变量。</li>
</ol>
<p>我们调用ThreadLocal.get方法时，实际上是从当前线程中获取ThreadLocalMap&lt;ThreadLocal, Object&gt;，然后根据当前ThreadLocal获取当前线程共享变量Object。</p>
<h4 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       T value = initialValue();</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p>弱引用，gc的时候会释放内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">       <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">       Object value;</span><br><span class="line"></span><br><span class="line">       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">           <span class="keyword">super</span>(k);</span><br><span class="line">           value = v;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/03/2019-11-3-ddd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/03/2019-11-3-ddd/" itemprop="url">ddd</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-03T00:00:00+08:00">
                2019-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p>领域</p>
<p>​    子域</p>
<p>​        核心域</p>
<p>​        通用域</p>
<p>​        支撑域</p>
<p>​            聚合</p>
<p>​                聚合根</p>
<p>​                实体</p>
<p>​                值对象</p>
<p>领域是用来限定业务边界和范围，子域对应一个更小的问题域或更小的业务范围</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/01/2019-11-1-jvm-invoke/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/01/2019-11-1-jvm-invoke/" itemprop="url">jvm-invoke</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-01T00:00:00+08:00">
                2019-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java函数调用"><a href="#java函数调用" class="headerlink" title="java函数调用"></a>java函数调用</h2><p>因为某个类中的重载方法可能被它的子类所重写，因此Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型</p>
<p>Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">invokestatic：用于调用静态方法。</span><br><span class="line">invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。</span><br><span class="line">invokevirtual：用于调用非私有实例方法。</span><br><span class="line">invokeinterface：用于调用接口方法。</span><br><span class="line">invokedynamic：用于调用动态方法。</span><br></pre></td></tr></table></figure>

<p>对于 invokestatic 以及 invokespecial 而言，Java 虚拟机能够直接识别具体的目标方法。而对于 invokevirtual 以及 invokeinterface 而言，在绝大部分情况下，虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。除了final标记的函数</p>
<p>在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。</p>
<p>符号引用存储在 class 文件的常量池之中</p>
<p>在 class 文件中，Java 编译器会用符号引用指代目标方法。在执行调用指令前，它所附带的符号引用需要被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用为目标方法的指针。对于需要动态绑定的方法调用而言，实际引用为辅助动态绑定的信息。</p>
<p>两个方法的参数类型一致，编译器会认为是重写，但只有当两个方法的参数类型以及返回类型一致时，Java 虚拟机才会判定为重写。</p>
<h4 id="找出方法"><a href="#找出方法" class="headerlink" title="找出方法"></a>找出方法</h4><p>对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。</p>
<ol>
<li>在 C 中查找符合名字及描述符的方法。</li>
<li>如果没有找到，在 C 的父类中继续搜索，直至 Object 类。</li>
<li>如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。</li>
</ol>
<p>对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。</p>
<ol>
<li>在 I 中查找符合名字及描述符的方法。</li>
<li>如果没有找到，在 Object 类中的公有实例方法中搜索。</li>
<li>如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。</li>
</ol>
<p>经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引</p>
<h4 id="虚方法调用"><a href="#虚方法调用" class="headerlink" title="虚方法调用"></a>虚方法调用</h4><p>Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令，而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的虚方法调用。</p>
<h4 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h4><p>类加载的准备阶段，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表</p>
<p>invokevirtual 所使用的虚方法表（virtual method table，vtable）</p>
<p>invokeinterface 所使用的接口方法表（interface method table，itable）</p>
<p>子类方法表中包含父类方法表中的所有方法；</p>
<p>子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同</p>
<p>方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值（实际上并不仅是索引值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">passThroughImmigration</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForeignerPassenger</span> <span class="keyword">extends</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">passThroughImmigration</span><span class="params">()</span> </span>&#123; <span class="comment">/* 进外国人通道 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinesePassenger</span> <span class="keyword">extends</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">passThroughImmigration</span><span class="params">()</span> </span>&#123; <span class="comment">/* 进中国人通道 */</span> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visitDutyFreeShops</span><span class="params">()</span> </span>&#123; <span class="comment">/* 逛免税店 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Passenger passenger = ...</span><br><span class="line">passenger.passThroughImmigration();</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191101153748947.png" alt="image-20191101153748947"></p>
<p>使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法</p>
<p>即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）</p>
<p>内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定</p>
<h3 id="method-invoke"><a href="#method-invoke" class="headerlink" title="method invoke"></a>method invoke</h3><p>方法反射Method.invoke源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> ... </span>&#123;</span><br><span class="line">    ... <span class="comment">// 权限检查</span></span><br><span class="line">    MethodAccessor ma = methodAccessor;</span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>委派给 MethodAccessor 来处理。MethodAccessor 是一个接口，它有两个已有的具体实现：一个通过本地方法来实现反射调用，另一个则使用了委派模式（生成动态代理类来执行方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 动态实现的伪代码，这里只列举了关键的调用逻辑，其实它还包括调用者检测、参数检测的字节码。</span></span><br><span class="line"><span class="keyword">package</span> jdk.internal.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedMethodAccessor1</span> <span class="keyword">extends</span> ... </span>&#123;</span><br><span class="line">  <span class="meta">@Overrides</span>    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> ... </span>&#123;</span><br><span class="line">    Test.target((<span class="keyword">int</span>) args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 虚拟机设置了一个阈值 15（可以通过 -Dsun.reflect.inflationThreshold= 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation</p>
<h3 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h3><p>Java 7 引入了一条新的指令 invokedynamic。该指令的调用机制抽象出调用点这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上，在第一次执行 invokedynamic 指令时，Java 虚拟机将执行它所对应的启动方法，生成并且绑定一个调用点。之后如果再次执行该指令，Java 虚拟机则直接调用已经绑定了的调用点所链接的方法。</p>
<p>它将调用点（CallSite）抽象成一个 Java 类，并且将原本由 Java 虚拟机控制的方法调用以及方法链接暴露给了应用程序。在运行过程中，每一条 invokedynamic 指令将捆绑一个调用点，并且会调用该调用点所链接的方法句柄</p>
<h5 id="方法句柄"><a href="#方法句柄" class="headerlink" title="方法句柄"></a>方法句柄</h5><p>方法句柄是一个强类型的、能够被直接执行的引用。它仅关心所指向方法的参数类型以及返回类型，而不关心方法所在的类以及方法名。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。</p>
<h5 id="获取方法句柄两种方式"><a href="#获取方法句柄两种方式" class="headerlink" title="获取方法句柄两种方式"></a>获取方法句柄两种方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">  private static void bar(Object o) &#123;</span><br><span class="line">    ..</span><br><span class="line">  &#125;</span><br><span class="line">  public static Lookup lookup() &#123;</span><br><span class="line">    return MethodHandles.lookup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取方法句柄的不同方式</span><br><span class="line">MethodHandles.Lookup l &#x3D; Foo.lookup(); &#x2F;&#x2F; 具备Foo类的访问权限</span><br><span class="line">Method m &#x3D; Foo.class.getDeclaredMethod(&quot;bar&quot;, Object.class);</span><br><span class="line">MethodHandle mh0 &#x3D; l.unreflect(m);</span><br><span class="line"></span><br><span class="line">MethodType t &#x3D; MethodType.methodType(void.class, Object.class);</span><br><span class="line">MethodHandle mh1 &#x3D; l.findStatic(Foo.class, &quot;bar&quot;, t);</span><br></pre></td></tr></table></figure>

<p>在 Java 8 中，Lambda 表达式也是借助 invokedynamic 来实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int x &#x3D; ..</span><br><span class="line">IntStream.of(1, 2, 3).map(i -&gt; i * 2).map(i -&gt; i * x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; i -&gt; i * 2</span><br><span class="line">  private static int lambda$0(int);</span><br><span class="line">    Code:</span><br><span class="line">       0: iload_0</span><br><span class="line">       1: iconst_2</span><br><span class="line">       2: imul</span><br><span class="line">       3: ireturn</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; i -&gt; i * x</span><br><span class="line">  private static int lambda$1(int, int);</span><br><span class="line">    Code:</span><br><span class="line">       0: iload_1</span><br><span class="line">       1: iload_0</span><br><span class="line">       2: imul</span><br><span class="line">       3: ireturn</span><br></pre></td></tr></table></figure>

<p>该 invokedynamic 指令对应的启动方法将通过 ASM 生成一个适配器类。</p>
<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://time.geekbang.org/column/article/12098" target="_blank" rel="noopener">https://time.geekbang.org/column/article/12098</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/2019-10-31-linux-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/31/2019-10-31-linux-thread/" itemprop="url">linux线程同步</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-31T00:00:00+08:00">
                2019-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="linux线程同步"><a href="#linux线程同步" class="headerlink" title="linux线程同步"></a>linux线程同步</h2><p>Pthread的同步机制有Mutex Lock、Spin Lock、Reader-Writter Lock、join、Condition Variables、semaphore、Barriers</p>
<p>互斥锁(mutex)</p>
<p>pthread_mutex_lock(&amp;mutex);</p>
<p>条件变量</p>
<p>信号量</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><h5 id="有了互斥变量pthread-mutext-t为什么还要引入条件变量pthread-cond-t呢"><a href="#有了互斥变量pthread-mutext-t为什么还要引入条件变量pthread-cond-t呢" class="headerlink" title="有了互斥变量pthread_mutext_t为什么还要引入条件变量pthread_cond_t呢"></a>有了互斥变量pthread_mutext_t为什么还要引入条件变量pthread_cond_t呢</h5><p>条件变量是线程的另外一种同步机制，这些同步对象为线程提供了会合的场所，理解起来就是两个（或者多个）线程需要碰头（或者说进行交互-一个线程给另外的一个或者多个线程发送消息），我们指定在条件变量这个地方发生，一个线程用于修改这个变量使其满足其它线程继续往下执行的条件，其它线程则接收条件已经发生改变的信号。</p>
<p>条件变量同锁一起使用使得线程可以以一种无竞争的方式等待任意条件的发生。所谓无竞争就是，条件改变这个信号会发送到所有等待这个信号的线程。而不是说一个线程接受到这个消息而其它线程就接收不到了。</p>
<p>条件变量一共也就pthread_cond_init、pthread_cond_destroy、pthread_cond_wait、pthread_cond_timedwait、pthread_cond_signal、pthread_cond_broadcast这么几个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">推荐用法</span><br><span class="line"></span><br><span class="line">class Condition4 : public ConditionBase</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Condition4()</span><br><span class="line">        : signal_(false)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void wait()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_);</span><br><span class="line">        while (!signal_)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond_, &amp;mutex_);</span><br><span class="line">        &#125;</span><br><span class="line">        signal_ &#x3D; false;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void wakeup()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_);</span><br><span class="line">        signal_ &#x3D; true;</span><br><span class="line">        pthread_cond_signal(&amp;cond_);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    bool signal_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">POSIX规范为了简化实现，允许pthread_cond_signal在实现的时候可以唤醒不止一个线程</span><br><span class="line"></span><br><span class="line">java的park，unpark就是采用这个线程同步方式</span><br><span class="line"></span><br><span class="line">notify和notify_all在linux系统就调用pthread_cond_signal、pthread_cond_broadcast，wait调用pthread_cond_wait</span><br><span class="line"></span><br><span class="line">void os::PlatformEvent::park() &#123;       &#x2F;&#x2F; AKA &quot;down()&quot;</span><br><span class="line">  &#x2F;&#x2F; Transitions for _event:</span><br><span class="line">  &#x2F;&#x2F;   -1 &#x3D;&gt; -1 : illegal</span><br><span class="line">  &#x2F;&#x2F;    1 &#x3D;&gt;  0 : pass - return immediately</span><br><span class="line">  &#x2F;&#x2F;    0 &#x3D;&gt; -1 : block; then set _event to 0 before returning</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Invariant: Only the thread associated with the PlatformEvent</span><br><span class="line">  &#x2F;&#x2F; may call park().</span><br><span class="line">  assert(_nParked &#x3D;&#x3D; 0, &quot;invariant&quot;);</span><br><span class="line"></span><br><span class="line">  int v;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; atomically decrement _event</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    v &#x3D; _event;</span><br><span class="line">    if (Atomic::cmpxchg(v - 1, &amp;_event, v) &#x3D;&#x3D; v) break;</span><br><span class="line">  &#125;</span><br><span class="line">  guarantee(v &gt;&#x3D; 0, &quot;invariant&quot;);</span><br><span class="line"></span><br><span class="line">  if (v &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; Do this the hard way by blocking ...</span><br><span class="line">    int status &#x3D; pthread_mutex_lock(_mutex);</span><br><span class="line">    assert_status(status &#x3D;&#x3D; 0, status, &quot;mutex_lock&quot;);</span><br><span class="line">    guarantee(_nParked &#x3D;&#x3D; 0, &quot;invariant&quot;);</span><br><span class="line">    ++_nParked;</span><br><span class="line">    while (_event &lt; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; OS-level &quot;spurious wakeups&quot; are ignored</span><br><span class="line">      status &#x3D; pthread_cond_wait(_cond, _mutex);</span><br><span class="line">      assert_status(status &#x3D;&#x3D; 0, status, &quot;cond_wait&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    --_nParked;</span><br><span class="line"></span><br><span class="line">    _event &#x3D; 0;</span><br><span class="line">    status &#x3D; pthread_mutex_unlock(_mutex);</span><br><span class="line">    assert_status(status &#x3D;&#x3D; 0, status, &quot;mutex_unlock&quot;);</span><br><span class="line">    &#x2F;&#x2F; Paranoia to ensure our locked and lock-free paths interact</span><br><span class="line">    &#x2F;&#x2F; correctly with each other.</span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">  &#125;</span><br><span class="line">  guarantee(_event &gt;&#x3D; 0, &quot;invariant&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void os::PlatformEvent::unpark() &#123;</span><br><span class="line">  &#x2F;&#x2F; Transitions for _event:</span><br><span class="line">  &#x2F;&#x2F;    0 &#x3D;&gt; 1 : just return</span><br><span class="line">  &#x2F;&#x2F;    1 &#x3D;&gt; 1 : just return</span><br><span class="line">  &#x2F;&#x2F;   -1 &#x3D;&gt; either 0 or 1; must signal target thread</span><br><span class="line">  &#x2F;&#x2F;         That is, we can safely transition _event from -1 to either</span><br><span class="line">  &#x2F;&#x2F;         0 or 1.</span><br><span class="line">  &#x2F;&#x2F; See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F; Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means</span><br><span class="line">  &#x2F;&#x2F; that it will take two back-to-back park() calls for the owning</span><br><span class="line">  &#x2F;&#x2F; thread to block. This has the benefit of forcing a spurious return</span><br><span class="line">  &#x2F;&#x2F; from the first park() call after an unpark() call which will help</span><br><span class="line">  &#x2F;&#x2F; shake out uses of park() and unpark() without checking state conditions</span><br><span class="line">  &#x2F;&#x2F; properly. This spurious return doesn&#39;t manifest itself in any user code</span><br><span class="line">  &#x2F;&#x2F; but only in the correctly written condition checking loops of ObjectMonitor,</span><br><span class="line">  &#x2F;&#x2F; Mutex&#x2F;Monitor, Thread::muxAcquire and os::sleep</span><br><span class="line"></span><br><span class="line">  if (Atomic::xchg(1, &amp;_event) &gt;&#x3D; 0) return;</span><br><span class="line"></span><br><span class="line">  int status &#x3D; pthread_mutex_lock(_mutex);</span><br><span class="line">  assert_status(status &#x3D;&#x3D; 0, status, &quot;mutex_lock&quot;);</span><br><span class="line">  int anyWaiters &#x3D; _nParked;</span><br><span class="line">  assert(anyWaiters &#x3D;&#x3D; 0 || anyWaiters &#x3D;&#x3D; 1, &quot;invariant&quot;);</span><br><span class="line">  status &#x3D; pthread_mutex_unlock(_mutex);</span><br><span class="line">  assert_status(status &#x3D;&#x3D; 0, status, &quot;mutex_unlock&quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Note that we signal() *after* dropping the lock for &quot;immortal&quot; Events.</span><br><span class="line">  &#x2F;&#x2F; This is safe and avoids a common class of futile wakeups.  In rare</span><br><span class="line">  &#x2F;&#x2F; circumstances this can cause a thread to return prematurely from</span><br><span class="line">  &#x2F;&#x2F; cond_&#123;timed&#125;wait() but the spurious wakeup is benign and the victim</span><br><span class="line">  &#x2F;&#x2F; will simply re-test the condition and re-park itself.</span><br><span class="line">  &#x2F;&#x2F; This provides particular benefit if the underlying platform does not</span><br><span class="line">  &#x2F;&#x2F; provide wait morphing.</span><br><span class="line"></span><br><span class="line">  if (anyWaiters !&#x3D; 0) &#123;</span><br><span class="line">    status &#x3D; pthread_cond_signal(_cond);</span><br><span class="line">    assert_status(status &#x3D;&#x3D; 0, status, &quot;cond_signal&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;liyuan989&#x2F;p&#x2F;4240271.html</span><br></pre></td></tr></table></figure>

<p>###java 线程</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/thread.png" alt=""><br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/thread2.png" alt=""></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191031152908741.png" alt="image-20191031152908741"></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191031163550430.png" alt="image-20191031163550430"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      NEW,</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">       * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">       * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">       * such as processor.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      RUNNABLE,</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">       * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">       * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">       * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">       * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      BLOCKED,</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">       * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">       * following methods:</span></span><br><span class="line"><span class="comment">       * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">       * perform a particular action.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">       * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">       * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">       * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">       * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      WAITING,</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">       * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">       * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">       * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">       *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">       * The thread has completed execution.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      TERMINATED;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>#####BLOCKED</p>
<p>synchronized </p>
<h5 id="WAITING-TIMED-WAITING"><a href="#WAITING-TIMED-WAITING" class="headerlink" title="WAITING/TIMED_WAITING"></a>WAITING/TIMED_WAITING</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程执行如下方法会进入WAITING状态：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">执行如下方法会进入TIMED_WAITING状态：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>



<p>阻塞：当一个线程试图获取对象锁（非java.util.concurrent库中的锁，即synchronized），而该锁被其他线程持有，则该线程进入阻塞状态。它的特点是<strong>使用简单，由JVM调度器来决定唤醒自己，而不需要由另一个线程来显式唤醒自己，不响应中断</strong>。<br>等待：当一个线程等待另一个线程通知调度器一个条件时，该线程进入等待状态。它的特点是<strong>需要等待另一个线程显式地唤醒自己，实现灵活，语义更丰富，可响应中断</strong>。例如调用：Object.wait()、Thread.join()以及等待Lock或Condition。</p>
<p>　　需要强调的是虽然synchronized和JUC里的Lock都实现锁的功能，但线程进入的状态是不一样的。<strong>synchronized会让线程进入阻塞态，而JUC里的Lock是用LockSupport.park()/unpark()来实现阻塞/唤醒的，会让线程进入等待态</strong>。但话又说回来，虽然等锁时进入的状态不一样，但被唤醒后又都进入runnable态，从行为效果来看又是一样的。</p>
<h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>在使用synchronized关键字获取锁的过程中不响应中断请求，这是synchronized的局限性。如果这对程序是一个问题，应该使用显式锁，java中的Lock接口，它支持以响应中断的方式获取锁。对于Lock.lock()，可以改用Lock.lockInterruptibly()，可被中断的加锁操作，它可以抛出中断异常。等同于等待时间无限长的Lock.tryLock(long time, TimeUnit unit)。</p>
<h5 id="io操作"><a href="#io操作" class="headerlink" title="io操作"></a>io操作</h5><p>如果线程在等待IO操作，尤其是网络IO，则会有一些特殊的处理，我们没有介绍过网络，这里只是简单介绍下。</p>
<ol>
<li>实现此InterruptibleChannel接口的通道是可中断的：如果某个线程在可中断通道上因调用某个阻塞的 I/O 操作（常见的操作一般有这些：serverSocketChannel. accept()、socketChannel.connect、socketChannel.open、socketChannel.read、socketChannel.write、fileChannel.read、fileChannel.write）而进入阻塞状态，而另一个线程又调用了该阻塞线程的 interrupt 方法，这将导致该通道被关闭，并且已阻塞线程接将会收到ClosedByInterruptException，并且设置已阻塞线程的中断状态。另外，如果已设置某个线程的中断状态并且它在通道上调用某个阻塞的 I/O 操作，则该通道将关闭并且该线程立即接收到 ClosedByInterruptException；并仍然设置其中断状态。</li>
<li>如果线程阻塞于Selector调用，则线程的中断标志位会被设置，同时，阻塞的调用会立即返回。</li>
</ol>
<p>我们重点介绍另一种情况，<strong>InputStream的read调用</strong>，该操作是不可中断的，如果流中没有数据，read会阻塞 (但线程状态依然是RUNNABLE)，且不响应interrupt()，<strong>与synchronized类似，调用interrupt()只会设置线程的中断标志，而不会真正”中断”它</strong></p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://zhuanlan.zhihu.com/p/27857336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27857336</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/29/2019-10-29-zero-copy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/29/2019-10-29-zero-copy/" itemprop="url">zero-copy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-29T00:00:00+08:00">
                2019-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="zero-copy"><a href="#zero-copy" class="headerlink" title="zero-copy"></a>zero-copy</h2><p>零拷贝主要的任务就是<strong>避免</strong>CPU将数据从一块存储拷贝到另外一块存储，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。并减少内核态和用户态的切换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while((n &#x3D; read(diskfd, buf, BUF_SIZE)) &gt; 0)</span><br><span class="line">    write(sockfd, buf , n);</span><br></pre></td></tr></table></figure>



<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191029173050503.png" alt="image-20191029173050503"></p>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf &#x3D; mmap(diskfd, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure>



<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191029173205203.png" alt="image-20191029173205203"></p>
<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191029174319368.png" alt="image-20191029174319368"></p>
<h4 id="硬件优化sendfile"><a href="#硬件优化sendfile" class="headerlink" title="硬件优化sendfile"></a>硬件优化sendfile</h4><p>将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去，DMA引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191029173545420.png" alt="image-20191029173545420"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java NIO中的FileChannal.transferTo()方法就是这样的实现，这个实现是依赖于操作系统底层的sendFile()实现的。</span><br><span class="line"></span><br><span class="line">public void transferTo(long position, long count, WritableByteChannel target);</span><br><span class="line">他底层的调用时系统调用**sendFile()**方法：</span><br><span class="line"></span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure>



<h3 id="refernce"><a href="#refernce" class="headerlink" title="refernce"></a>refernce</h3><p><a href="https://www.jianshu.com/p/fad3339e3448" target="_blank" rel="noopener">https://www.jianshu.com/p/fad3339e3448</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">271</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

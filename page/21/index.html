<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/21/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="default-2015-1-29-socket" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/29/2015-1-29-socket/" class="article-date">
  <time datetime="2015-01-28T16:00:00.000Z" itemprop="datePublished">2015-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/29/2015-1-29-socket/">socket</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><h4 id="接收网络数据"><a href="#接收网络数据" class="headerlink" title="接收网络数据"></a>接收网络数据</h4><p>网卡收到网线传来的数据，通过硬件电路的传输，将数据写入到内存中的某个地址上</p>
<p>当网卡把数据写入到内存后，网卡向 CPU 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</p>
<p>从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select 和 epoll 都是阻塞方法</p>
<h4 id="阻塞的原理"><a href="#阻塞的原理" class="headerlink" title="阻塞的原理"></a>阻塞的原理</h4><p>操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得 CPU 使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到 recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191113091525419.png" alt="image-20191113091525419"></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191113091722640.png" alt="image-20191113091722640"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socket</span></span><br><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);   </span><br><span class="line"><span class="comment">//绑定</span></span><br><span class="line">bind(s, ...)</span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line"><span class="built_in">listen</span>(s, ...)</span><br><span class="line"><span class="comment">//接受客户端连接</span></span><br><span class="line"><span class="keyword">int</span> c = accept(s, ...)</span><br><span class="line"><span class="comment">//接收客户端数据</span></span><br><span class="line">recv(c, ...);</span><br><span class="line"><span class="comment">//将数据打印出来</span></span><br><span class="line"><span class="built_in">printf</span>(...)</span><br></pre></td></tr></table></figure>



<h5 id="操作系统如何知道网络数据对应于哪个-socket？"><a href="#操作系统如何知道网络数据对应于哪个-socket？" class="headerlink" title="操作系统如何知道网络数据对应于哪个 socket？"></a>操作系统如何知道网络数据对应于哪个 socket？</h5><p>因为一个 socket 对应着一个端口号，而网络数据包中包含了 ip 和端口的信息，内核可以通过端口号找到对应的 socket</p>
<h5 id="如何同时监视多个-socket-的数据？"><a href="#如何同时监视多个-socket-的数据？" class="headerlink" title="如何同时监视多个 socket 的数据？"></a>如何同时监视多个 socket 的数据？</h5><p><strong>select、poll、epoll</strong></p>
<h6 id="select方式"><a href="#select方式" class="headerlink" title="select方式"></a>select方式</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">bind(s, ...);</span><br><span class="line"><span class="built_in">listen</span>(s, ...);</span><br><span class="line"><span class="keyword">int</span> fds[] =  存放需要监听的socket;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = select(..., fds, ...)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], ...))&#123;</span><br><span class="line">            <span class="comment">//fds[i]的数据处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>其一，每次调用 select 都需要将进程加入到所有监视 socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个 fds 列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定 select 的最大监视数量，默认只能监视 1024 个 socket。</p>
<p>其二，进程被唤醒后，程序并不知道哪些 socket 收到数据，还需要遍历一次。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191206135442670.png" alt="image-20191206135442670"></p>
<h6 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);   </span><br><span class="line">bind(s, ...)</span><br><span class="line"><span class="built_in">listen</span>(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = epoll_wait(...)</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select 低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。如下图所示，每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 相对固定，并不需要每次都修改。epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。显而易见地，效率就能得到提升。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191113093959871.png" alt="image-20191113093959871"></p>
<p>select 低效的一个原因在于程序不知道哪些 socket 收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的 socket，就能避免遍历</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191206135936683.png" alt="image-20191206135936683"></p>
<p>当 socket 收到数据后，中断程序会给 eventpoll 的“就绪列表”添加 socket 引用。如下图展示的是 sock2 和 sock3 收到数据后，中断程序让 rdlist 引用这两个 socket。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191113095241992.png" alt="image-20191113095241992"></p>
<p>某个进程调用 epoll_create 方法时，内核会创建一个 eventpoll 对象（也就是程序中 epfd 所代表的对象）。eventpoll 对象也是文件系统中的一员，和 socket 一样，它也会有等待队列。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191206140246220.png" alt="image-20191206140246220"></p>
<p>当 socket 收到数据后，中断程序会操作 eventpoll 对象，而不是直接操作进程</p>
<p>当 socket 收到数据后，中断程序会给 eventpoll 的“就绪列表”添加 socket 引用</p>
<p>当程序执行到 epoll_wait 时，如果 rdlist 已经引用了 socket，那么 epoll_wait 直接返回，如果 rdlist 为空，阻塞进程，如下图</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191113095838347.png" alt="image-20191113095838347"></p>
<p>epoll 使用双向链表来实现就绪队列（rdllist）</p>
<p>用红黑树保存监视的socket，根据端口，能快速找到对应的socket</p>
<p>eventpoll 对象相当于 socket 和进程之间的中介，socket 的数据接收并不直接影响进程，而是通过改变 eventpoll 的就绪列表来改变进程状态。</p>
<p>当程序执行到 epoll_wait 时，如果 rdlist 已经引用了 socket，那么 epoll_wait 直接返回，如果 rdlist 为空，阻塞进程。</p>
<p><strong>当 socket 接收到数据，中断程序一方面修改 rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态（如下图）。也因为 rdlist 的存在，进程 A 可以知道哪些 socket 发生了变化</strong></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191206141422914.png" alt="image-20191206141422914"></p>
<h4 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h4><p>socket套接字是一种有相应描述符的打开文件（open—write/read—close）</p>
<p>socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态</p>
<p>socket 在 Linux 中就是以文件的形式存在的，即对应一个文件描述符</p>
<p>每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标</p>
<p>socket结构里，主要的是两个队列，一个是发送队列，一个是接收队列。在这两个队列里面保存的是一个缓存 sk_buff。这个缓存里面能够看到完整的包的结构</p>
<p>socket上定义了几个IO事件：状态改变事件、有数据可读事件、有发送缓存可写事件、有IO错误事件。对于这些事件，socket中分别定义了相应的事件处理函数，也称回调函数。</p>
<p>Socket I/O事件的处理过程中，要使用到sock上的两个队列：等待队列和异步通知队列，这两个队列中都保存着等待该Socket I/O事件的进程。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191112151603487.png" alt="image-20191112151603487"></p>
<h5 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h5><p>进程 A 运行到了 epoll_wait 语句，内核会将进程 A 放入 eventpoll 的等待队列wq中，阻塞进程，eventpoll红黑树rbr维护监听的socket，当 socket 接收到数据（ip：port），中断程序快速查找socket，并放入eventpoll就绪队列rdlist，唤醒 eventpoll 等待队列中的进程</p>
<h4 id="tcp连接："><a href="#tcp连接：" class="headerlink" title="tcp连接："></a>tcp连接：</h4><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><p>1.1.创建套接字，协议、类型</p>
<pre><code>socket()</code></pre><p>1.2.绑定地址、端口</p>
<pre><code>bind()</code></pre><p>1.3.声明该套接字用于监听</p>
<p>mark a connection-mode socket, specified by the socket argument, as accepting connections.</p>
<p>默认的socket是主动性套接字，用于客户端，listen函数告诉内核该socket是用于监听。</p>
<pre><code>listen()</code></pre><p>1.4.监听套接字直到连接到来，每次接受连接请求会生成已连接描述符，用于客户端通信</p>
<pre><code>accept()</code></pre><p>Accept a connection with the accept() system call. This call typically blocks until a client connects with the server.</p>
<p>如果已经建立了连接的队列有新连接，则accept返回新连接的socket，否则一直阻塞</p>
<h3 id="client端"><a href="#client端" class="headerlink" title="client端:"></a>client端:</h3><pre><code>2.1.socket()

2.2.connect()</code></pre><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://my.oschina.net/editorial-story/blog/3052308" target="_blank" rel="noopener">https://my.oschina.net/editorial-story/blog/3052308</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/01/29/2015-1-29-socket/" data-id="ck521h17g006slc7k61dd9961" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2015-1-22-nginx" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/22/2015-1-22-nginx/" class="article-date">
  <time datetime="2015-01-21T16:00:00.000Z" itemprop="datePublished">2015-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/22/2015-1-22-nginx/">nginx&amp;apeche</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>request-&gt;nginx-&gt;index模块-&gt;配置文件-&gt;response</p>
<p>##0.基础</p>
<p><a href="http://garydai.github.io/2013/06/01/IO.html" target="_blank" rel="noopener">http://garydai.github.io/2013/06/01/IO.html</a></p>
<p><a href="http://garydai.github.io/2015/01/29/socket.html" target="_blank" rel="noopener">http://garydai.github.io/2015/01/29/socket.html</a></p>
<p>##1.框架</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/nginx.PNG" alt=""> </p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/nginx1.jpg" alt=""> </p>
<pre><code>struct ngx_cycle_s {
    void                  ****conf_ctx;
    ngx_pool_t               *pool;

    ngx_log_t                *log;
    ngx_log_t                 new_log;

    ngx_connection_t        **files;
    ngx_connection_t         *free_connections;
    ngx_uint_t                free_connection_n;

    ngx_array_t               listening;
    ngx_array_t               pathes;
    ngx_list_t                open_files;
    ngx_list_t                shared_memory;

    ngx_uint_t                connection_n;
    ngx_uint_t                files_n;

    ngx_connection_t         *connections;
    ngx_event_t              *read_events;
    ngx_event_t              *write_events;

    ngx_cycle_t              *old_cycle;

    ngx_str_t                 conf_file;
    ngx_str_t                 conf_param;
    ngx_str_t                 conf_prefix;
    ngx_str_t                 prefix;
    ngx_str_t                 lock_file;
    ngx_str_t                 hostname;
};

cycle = ngx_init_cycle(&amp;init_cycle);
1.1.main函数里调用ngx\_init_cycle初始化一个主进程实例,并创建监听套接字



ngx_master_process_cycle(cycle);
1.2.创建worker进程

1.3.worker进程竞争accept锁

1.4.某一进程accept事件发生

1.5.取空闲的连接</code></pre><p>##2.主要数据结构</p>
<pre><code>struct ngx_listening_s {
    ngx_socket_t        fd;

    struct sockaddr    *sockaddr;
    socklen_t           socklen;    /* size of sockaddr */
    size_t              addr_text_max_len;
    ngx_str_t           addr_text;

    int                 type;

    int                 backlog;
    int                 rcvbuf;
    int                 sndbuf;

    /* handler of accepted connection */
    ngx_connection_handler_pt   handler;

    void               *servers;  /* array of ngx_http_in_addr_t, for example */

    ngx_log_t           log;
    ngx_log_t          *logp;

    size_t              pool_size;
    /* should be here because of the AcceptEx() preread */
    size_t              post_accept_buffer_size;
    /* should be here because of the deferred accept */
    ngx_msec_t          post_accept_timeout;

    ngx_listening_t    *previous;
    ngx_connection_t   *connection;

    unsigned            open:1;
    unsigned            remain:1;
    unsigned            ignore:1;

    unsigned            bound:1;       /* already bound */
    unsigned            inherited:1;   /* inherited from previous process */
    unsigned            nonblocking_accept:1;
    unsigned            listen:1;
    unsigned            nonblocking:1;
    unsigned            shared:1;    /* shared between threads or processes */
    unsigned            addr_ntop:1;

#if (NGX_HAVE_INET6 &amp;&amp; defined IPV6_V6ONLY)
    unsigned            ipv6only:2;
#endif

#if (NGX_HAVE_DEFERRED_ACCEPT)
    unsigned            deferred_accept:1;
    unsigned            delete_deferred:1;
    unsigned            add_deferred:1;
#ifdef SO_ACCEPTFILTER
    char               *accept_filter;
#endif
#endif

};

struct ngx_connection_s {
    void               *data;
    ngx_event_t        *read;
    ngx_event_t        *write;

    ngx_socket_t        fd;

    ngx_recv_pt         recv;
    ngx_send_pt         send;
    ngx_recv_chain_pt   recv_chain;
    ngx_send_chain_pt   send_chain;

    ngx_listening_t    *listening;

    off_t               sent;

    ngx_log_t          *log;

    ngx_pool_t         *pool;

    struct sockaddr    *sockaddr;
    socklen_t           socklen;
    ngx_str_t           addr_text;

#if (NGX_SSL)
    ngx_ssl_connection_t  *ssl;
#endif

    struct sockaddr    *local_sockaddr;
    socklen_t           local_socklen;

    ngx_buf_t          *buffer;

    ngx_atomic_uint_t   number;

    ngx_uint_t          requests;

    unsigned            buffered:8;

    unsigned            log_error:3;     /* ngx_connection_log_error_e */

    unsigned            single_connection:1;
    unsigned            unexpected_eof:1;
    unsigned            timedout:1;
    unsigned            error:1;
    unsigned            destroyed:1;

    unsigned            idle:1;
    unsigned            close:1;

    unsigned            sendfile:1;
    unsigned            sndlowat:1;
    unsigned            tcp_nodelay:2;   /* ngx_connection_tcp_nodelay_e */
    unsigned            tcp_nopush:2;    /* ngx_connection_tcp_nopush_e */

#if (NGX_HAVE_IOCP)
    unsigned            accept_context_updated:1;
#endif

#if (NGX_THREADS)
    ngx_atomic_t        lock;
#endif
};



struct ngx_event_s {
    void            *data;

    unsigned         write:1;

    unsigned         accept:1;

    /* used to detect the stale events in kqueue, rtsig, and epoll */
    unsigned         instance:1;

    /*
     * the event was passed or would be passed to a kernel;
     * in aio mode - operation was posted.
     */
    unsigned         active:1;

    unsigned         disabled:1;

    /* the ready event; in aio mode 0 means that no operation can be posted */
    unsigned         ready:1;

    unsigned         oneshot:1;

    /* aio operation is complete */
    unsigned         complete:1;

    unsigned         eof:1;
    unsigned         error:1;

    unsigned         timedout:1;
    unsigned         timer_set:1;

    unsigned         delayed:1;

    unsigned         read_discarded:1;

    unsigned         unexpected_eof:1;

    unsigned         deferred_accept:1;

    /* the pending eof reported by kqueue or in aio chain operation */
    unsigned         pending_eof:1;

#if !(NGX_THREADS)
    unsigned         posted_ready:1;
#endif

#if (NGX_WIN32)
    /* setsockopt(SO_UPDATE_ACCEPT_CONTEXT) was succesfull */
    unsigned         accept_context_updated:1;
#endif

#if (NGX_HAVE_KQUEUE)
    unsigned         kq_vnode:1;

    /* the pending errno reported by kqueue */
    int              kq_errno;
#endif

    /*
     * kqueue only:
     *   accept:     number of sockets that wait to be accepted
     *   read:       bytes to read when event is ready
     *               or lowat when event is set with NGX_LOWAT_EVENT flag
     *   write:      available space in buffer when event is ready
     *               or lowat when event is set with NGX_LOWAT_EVENT flag
     *
     * iocp: TODO
     *
     * otherwise:
     *   accept:     1 if accept many, 0 otherwise
     */

#if (NGX_HAVE_KQUEUE) || (NGX_HAVE_IOCP)
    int              available;
#else
    unsigned         available:1;
#endif

    ngx_event_handler_pt  handler;


#if (NGX_HAVE_AIO)

#if (NGX_HAVE_IOCP)
    ngx_event_ovlp_t ovlp;
#else
    struct aiocb     aiocb;
#endif

#endif

    ngx_uint_t       index;

    ngx_log_t       *log;

    ngx_rbtree_node_t   timer;

    unsigned         closed:1;

    /* to test on worker exit */
    unsigned         channel:1;
    unsigned         resolver:1;

#if (NGX_THREADS)

    unsigned         locked:1;

    unsigned         posted_ready:1;
    unsigned         posted_timedout:1;
    unsigned         posted_eof:1;

#if (NGX_HAVE_KQUEUE)
    /* the pending errno reported by kqueue */
    int              posted_errno;
#endif

#if (NGX_HAVE_KQUEUE) || (NGX_HAVE_IOCP)
    int              posted_available;
#else
    unsigned         posted_available:1;
#endif

    ngx_atomic_t    *lock;
    ngx_atomic_t    *own_lock;

#endif

    /* the links of the posted queue */
    ngx_event_t     *next;
    ngx_event_t    **prev;


#if 0

    /* the threads support */

    /*
     * the event thread context, we store it here
     * if $(CC) does not understand __thread declaration
     * and pthread_getspecific() is too costly
     */

    void            *thr_ctx;

#if (NGX_EVENT_T_PADDING)

    /* event should not cross cache line in SMP */

    uint32_t         padding[NGX_EVENT_T_PADDING];
#endif
#endif
};</code></pre><p>connection</p>
<p>nginx每个socket被封装成connection结构ngx_connection_t，ngx_connection_t里还包含socket的读写事件ngx_event_t，及事件发生时调用的回调函数。</p>
<p>event</p>
<p>ngx_event_t</p>
<p>##2.模块</p>
<p>nginx框架由模块组成</p>
<pre><code>struct ngx_module_s {
    ngx_uint_t            ctx_index;
    ngx_uint_t            index;

    ngx_uint_t            spare0;
    ngx_uint_t            spare1;
    ngx_uint_t            spare2;
    ngx_uint_t            spare3;

    ngx_uint_t            version;

    void                 *ctx;
    ngx_command_t        *commands;
    ngx_uint_t            type;

    ngx_int_t           (*init_master)(ngx_log_t *log);

    ngx_int_t           (*init_module)(ngx_cycle_t *cycle);

    ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
    ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
    void                (*exit_thread)(ngx_cycle_t *cycle);
    void                (*exit_process)(ngx_cycle_t *cycle);

    void                (*exit_master)(ngx_cycle_t *cycle);

    uintptr_t             spare_hook0;
    uintptr_t             spare_hook1;
    uintptr_t             spare_hook2;
    uintptr_t             spare_hook3;
    uintptr_t             spare_hook4;
    uintptr_t             spare_hook5;
    uintptr_t             spare_hook6;
    uintptr_t             spare_hook7;
};</code></pre><p>解析模块conf，再初始化模块的配置结构init_conf</p>
<p>2.1.1.handlers : 处理客户端请求并产生响应内容,比如ngx_http_static_moudle模块，负责客户端的静态页面请求，并将对应的静态磁盘文件作为响应内容输出.</p>
<p>2.1.2.filters : 对handlers产生的响应内容做各种过滤处理(即增，删，改),比如 ngx_http_not_modify_filter_moudle,如果通过时间判断前后2次请求的响应内容没有发生任何改变,那么可以直接响应”304 Not Modified”状态标识,让客户端使用缓存即可,而原本发送的响应内容将被清除掉.</p>
<p>2.1.3.upstream : 如果存在后端真实的服务器,nginx 可以利用upstream模块充当反向代理的角色，对客户端的请求只负责转发到后端的真实服务器，如ngx_http_proxy_moudle模块.</p>
<p>2.1.4.load-balance : 在nginx充当中间代理时，由于后端真实服务器往往多于一个，对于某一次客户端的请求，如何选择对应的后端真实服务器来进行处理，这就有类似于ngx_http_upstream_ip_hash_module这样的模块来实现不同的负载均衡算法（Load Balance）。</p>
<p>3.1.处理连接事件模块</p>
<p>3.1.ngx_events_module事件模块</p>
<p>nginx只有ngx_event_core_module和ngx_epoll_module和其他IO实现类型模块</p>
<p>3.2.一个事件一个事件模块实例ngx_event_module_t</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/nginx1.png" alt=""> </p>
<p>###2.1.事件模块</p>
<p>事件模型的初始化与http模块类似，由ngx_events_module驱动整个事件模块的解析和初始化，ngx_event_core_module对events块大部分指令的解析保存重要的配置信息。</p>
<p>nginx的IO属于事件模块</p>
<pre><code>typedef struct {
    ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);  //将某描述符的某个事件（可读／可写）添加到多路复用监控里
    ngx_int_t  (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);  //将某描述符的某个事件（可读/可写）从多路复用监控里删除 

    ngx_int_t  (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);  //启动对某个事件的监控
    ngx_int_t  (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);  //禁止对某个事件的监控

    ngx_int_t  (*add_conn)(ngx_connection_t *c);    //将指定的连接关联的描述符添加到多路复用的监控里
    ngx_int_t  (*del_conn)(ngx_connection_t *c, ngx_uint_t flags);//将指定的连接关联的描述符从多路复用的监控里删除
    ngx_int_t (*process_changes)(ngx_cycle_t *cycle, ngx_uint_t nowait);//只有kqueue用到
    ngx_int_t (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags);  //阻塞等待事件发生,对发生的事件进行逐个处理

    ngx_int_t (*init)(ngx_cycle_t *cycle, ngx_msec_t timer); //初始化 
    void (*done)(ngx_cycle_t *cycle);//回收资源
} ngx_event_actions_t; 

typedef struct {
    ngx_str_t              *name;

    void                 *(*create_conf)(ngx_cycle_t *cycle);
    char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);

    ngx_event_actions_t     actions;
} ngx_event_module_t;


ngx_module_t  ngx_event_core_module = {
    NGX_MODULE_V1,
    &amp;ngx_event_core_module_ctx,            /* module context */
    ngx_event_core_commands,               /* module directives */
    NGX_EVENT_MODULE,                      /* module type */
    NULL,                                  /* init master */
    ngx_event_module_init,                 /* init module */
    ngx_event_process_init,                /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


ngx_module_t  ngx_epoll_module = {
    NGX_MODULE_V1,
    &amp;ngx_epoll_module_ctx,               /* module context */
    ngx_epoll_commands,                  /* module directives */
    NGX_EVENT_MODULE,                    /* module type */
    NULL,                                /* init master */
    NULL,                                /* init module */
    NULL,                                /* init process */
    NULL,                                /* init thread */
    NULL,                                /* exit thread */
    NULL,                                /* exit process */
    NULL,                                /* exit master */
    NGX_MODULE_V1_PADDING
};</code></pre><p>nginx有两个事件模块，ngx_event_core_module和ngx_epoll_module，ngx_event_core_module主要用于事件模块初始化，ngx_event_core_module对events块大部分指令的解析保存重要的配置信息，ngx_epoll_module实际上就是底层io模型的实现</p>
<p>1.解析events块</p>
<p>2.解析完events块，接着调用所有event module的init_conf回调函数初始化模块的配置结构，ngx_event_core_module和ngx_epoll_module会对配置结构中尚未初始化的一些属性赋默认值，比如默认使用io模型，也就是use指令的默认值</p>
<p>3.初始化事件模块init_module和init_process</p>
<pre><code>init_module:
static ngx_int_t
ngx_event_module_init(ngx_cycle_t *cycle)
{
    .......
      cl = 128;

    size = cl            /* ngx_accept_mutex */
           + cl          /* ngx_connection_counter */
           + cl;         /* ngx_temp_number */

    shm.size = size;
    shm.name.len = sizeof(&quot;nginx_shared_zone&quot;);
    shm.name.data = (u_char *) &quot;nginx_shared_zone&quot;;
    shm.log = cycle-&gt;log;

     if (ngx_shm_alloc(&amp;shm) != NGX_OK) {
        return NGX_ERROR;
    }

    shared = shm.addr;

    ngx_accept_mutex_ptr = (ngx_atomic_t *) shared;
    ngx_accept_mutex.spin = (ngx_uint_t) -1;
    //  将accept锁放入共享内存，并将其初始化。
    if (ngx_shmtx_create(&amp;ngx_accept_mutex, (ngx_shmtx_sh_t *) shared,
                         cycle-&gt;lock_file.data)
        != NGX_OK)
    {
        return NGX_ERROR;
    }

    ngx_connection_counter = (ngx_atomic_t *) (shared + 1 * cl);//接着放入连接计数器
}</code></pre><p>ngx_event_process_init函数是在创建完worker进程后调用的</p>
<pre><code>static ngx_int_t
ngx_event_process_init(ngx_cycle_t *cycle)
{
    //而对于ecf-&gt;accept_mutex字段的判断主要是提供用户便利，可以关闭该功能，因为既然均衡策略也有相应的代码逻辑，难保在某些情况下其本身的消耗也许会得不偿失；当然，该字段默认为1，在配置初始化函数ngx_event_core_init_conf()内，有这么一句：ngx_conf_init_value(ecf-&gt;accept_mutex, 1);
    if (ccf-&gt;master &amp;&amp; ccf-&gt;worker_processes &gt; 1 &amp;&amp; ecf-&gt;accept_mutex) {  
    ngx_use_accept_mutex = 1;  
    ngx_accept_mutex_held = 0;  
    ngx_accept_mutex_delay = ecf-&gt;accept_mutex_delay;  

    } else {  
        ngx_use_accept_mutex = 0;  
    }  
}


//初始化timer
if (ngx_event_timer_init(cycle-&gt;log) == NGX_ERROR) {  
    return NGX_ERROR;  
}  



  for (m = 0; ngx_modules[m]; m++) {
        if (ngx_modules[m]-&gt;type != NGX_EVENT_MODULE) {
            continue;
        }

        if (ngx_modules[m]-&gt;ctx_index != ecf-&gt;use) {
            continue;
        }

        module = ngx_modules[m]-&gt;ctx;

        if (module-&gt;actions.init(cycle, ngx_timer_resolution) != NGX_OK) { //初始化epoll,在lunix下  ngx_epoll_init
            /* fatal */
            exit(2);
        }

        break;
    }



ngx_epoll_init    



static ngx_int_t
ngx_epoll_init(ngx_cycle_t *cycle, ngx_msec_t timer)
{
       ep = epoll_create(cycle-&gt;connection_n / 2);//  ep就是epoll的句柄，初值为-1，所以一启动nginx就是调用epoll_create创建句柄，
         if (nevents &lt; epcf-&gt;events) {
                  if (event_list) {
                          ngx_free(event_list);
         }

         //初始化nevents和event_list，epcf-&gt;events是由ngx_epoll_module的epoll_events指令设置的。nevents和event_list是要传给epoll_wait的参数，nevents是要监听的事件的最大个数，event_list用于存放epoll返回的事件。

         event_list = ngx_alloc(sizeof(struct epoll_event) * epcf-&gt;events,ycle-&gt;log);

         nevents = epcf-&gt;events;

         ngx_event_actions = ngx_epoll_module_ctx.actions; //为抽象事件模型赋值

}</code></pre><p>入口ngx_events_block</p>
<p>2.nginx内存管理</p>
<p>2.1.ngx的内存池</p>
<p>###2.2HTTP模块</p>
<p>##4.进程之间的通信</p>
<p>采用socketpair()函数创造一对未命名的unix域套接字来进行主从进程或子进程之间的双向通信</p>
<pre><code>if (socketpair(AF_UNIX, SOCK_STREAM, 0, ngx_processes[s].channel) == -1)</code></pre><p>就目前nginx代码来看，子进程并没有往父进程发送任何消息，子进程之间也没有相互通信的逻辑，也许是因为nginx有其它一些更好的进程通信方式，比如共享内存等，所以这种channel通信目前仅做为父进程往子进程发送消息使用，但由于有这个基础在这，如果未来要使用channel做这样的事情，的确是可以的。</p>
<p>4.1.共享内存</p>
<p>slab访问机制</p>
<p>5.解析配置文件</p>
<p>Reference</p>
<p><a href="http://www.cnblogs.com/fll369/archive/2012/11/26/2788780.html" target="_blank" rel="noopener">http://www.cnblogs.com/fll369/archive/2012/11/26/2788780.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/01/22/2015-1-22-nginx/" data-id="ck521h18o0073lc7k0isl20bo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2015-1-20-webframe" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/20/2015-1-20-webframe/" class="article-date">
  <time datetime="2015-01-19T16:00:00.000Z" itemprop="datePublished">2015-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/20/2015-1-20-webframe/">2015-1-20-webframe</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##大型网站框架</p>
<p>###特点<br>高并发访问、海量数据处理、高可靠运行</p>
<p>###模式<br>1.分层</p>
<p>1.1 应用层</p>
<p>1.2 服务层</p>
<p>1.3 数据层</p>
<p>2.分割</p>
<p>3.分布式</p>
<p>4.集群</p>
<p>5.缓存</p>
<p>6.异步</p>
<p>7.冗余</p>
<p>8.自动化</p>
<p>9.安全</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/01/20/2015-1-20-webframe/" data-id="ck521h10k001vlc7k2cndh0tk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2015-1-15-machine_learning" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/15/2015-1-15-machine_learning/" class="article-date">
  <time datetime="2015-01-14T16:00:00.000Z" itemprop="datePublished">2015-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/15/2015-1-15-machine_learning/">machine_learning</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##斯坦福机器学习公开课</p>
<p>1.机器学习类型</p>
<p>有监督学习</p>
<p>无监督学习</p>
<p>半监督学习</p>
<p>强化学习</p>
<p>2.单变量线性回归</p>
<p>3.多变量线性回归</p>
<p>4.逻辑回归</p>
<p>分类，分类是监督学习的一个核心问题</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/01/15/2015-1-15-machine_learning/" data-id="ck521h10j001ulc7kbdf39lxa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2014-12-22-sentiment" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/22/2014-12-22-sentiment/" class="article-date">
  <time datetime="2014-12-21T16:00:00.000Z" itemprop="datePublished">2014-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/22/2014-12-22-sentiment/">sentiment</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##sentiment<br>情感分析</p>
<p>precision = tp/(tp+fp)</p>
<p>tp:true positive A被分类到到A</p>
<p>fp:false positive 其他类被分类到A</p>
<p>fn:false negative 其他类被分类到其他类</p>
<p>precision = tp/(tp+fn)</p>
<p>1.字典法</p>
<p>构造情绪字典</p>
<p>2.机器学习法</p>
<p>训练已分类的语料库，学习出类别的特征</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/12/22/2014-12-22-sentiment/" data-id="ck521h105001flc7k4pruatx1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2014-12-5-gearman" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/05/2014-12-5-gearman/" class="article-date">
  <time datetime="2014-12-04T16:00:00.000Z" itemprop="datePublished">2014-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/05/2014-12-5-gearman/">gearman</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##gearman<br>任务分发系统</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/12/05/2014-12-5-gearman/" data-id="ck521h108001hlc7khonrh6vu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2014-11-25-yii" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/25/2014-11-25-yii/" class="article-date">
  <time datetime="2014-11-24T16:00:00.000Z" itemprop="datePublished">2014-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/25/2014-11-25-yii/">yii</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="yii架构分析"><a href="#yii架构分析" class="headerlink" title="yii架构分析"></a>yii架构分析</h2><p>yii是由php编写的web后端框架</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1.请求url进入到yii的入口</p>
<p>2.如何解析url</p>
<p>3.MVC之间的接口</p>
<p>4.yii一直在监听的主程序</p>
<p>5.祖先类</p>
<p>6.结果怎么传给客户端</p>
<p>7.yii 事件机制</p>
<p>8.nginx yii参数传递</p>
<p>9.view 和layout关系</p>
<p>###分析</p>
<p>4.框架加载（when）</p>
<p>index.php </p>
<pre><code>&lt;?php

// change the following paths if necessary
$yii=dirname(__FILE__).&apos;/../../framework/yii.php&apos;;
$config=dirname(__FILE__).&apos;/protected/config/main.php&apos;;

// remove the following line when in production mode
// defined(&apos;YII_DEBUG&apos;) or define(&apos;YII_DEBUG&apos;,true);

require_once($yii);
Yii::createWebApplication($config)-&gt;run();</code></pre><p>abstract class CApplication extends CModule</p>
<pre><code>public function __construct($config=null)
{
    Yii::setApplication($this);

    // set basePath at early as possible to avoid trouble
    if(is_string($config))
        $config=require($config);
    if(isset($config[&apos;basePath&apos;]))
    {
        $this-&gt;setBasePath($config[&apos;basePath&apos;]);
        unset($config[&apos;basePath&apos;]);
    }
    else
        $this-&gt;setBasePath(&apos;protected&apos;);
    Yii::setPathOfAlias(&apos;application&apos;,$this-&gt;getBasePath());
    Yii::setPathOfAlias(&apos;webroot&apos;,dirname($_SERVER[&apos;SCRIPT_FILENAME&apos;]));
    if(isset($config[&apos;extensionPath&apos;]))
    {
        $this-&gt;setExtensionPath($config[&apos;extensionPath&apos;]);
        unset($config[&apos;extensionPath&apos;]);
    }
    else
        Yii::setPathOfAlias(&apos;ext&apos;,$this-&gt;getBasePath().DIRECTORY_SEPARATOR.&apos;extensions&apos;);
    if(isset($config[&apos;aliases&apos;]))
    {
        $this-&gt;setAliases($config[&apos;aliases&apos;]);
        unset($config[&apos;aliases&apos;]);
    }

    $this-&gt;preinit();

    $this-&gt;initSystemHandlers();
    $this-&gt;registerCoreComponents();

    $this-&gt;configure($config);
    $this-&gt;attachBehaviors($this-&gt;behaviors);
    $this-&gt;preloadComponents();

    $this-&gt;init();
}</code></pre><p>CModule.php</p>
<pre><code>public function configure($config)
{
    if(is_array($config))
    {
        foreach($config as $key=&gt;$value)
            $this-&gt;$key=$value;
    }
}</code></pre><p>CWebApplication.run</p>
<pre><code>if($this-&gt;hasEventHandler(&apos;onBeginRequest&apos;))
    $this-&gt;onBeginRequest(new CEvent($this));
register_shutdown_function(array($this,&apos;end&apos;),0,false);
$this-&gt;processRequest();
if($this-&gt;hasEventHandler(&apos;onEndRequest&apos;))
    $this-&gt;onEndRequest(new CEvent($this));</code></pre><p>CComponent.php</p>
<pre><code>public function raiseEvent($name,$event)
{
    $name=strtolower($name);
    if(isset($this-&gt;_e[$name]))
    {
        foreach($this-&gt;_e[$name] as $handler)
        {
            if(is_string($handler))
                call_user_func($handler,$event);
            elseif(is_callable($handler,true))
            {
                if(is_array($handler))
                {
                    // an array: 0 - object, 1 - method name
                    list($object,$method)=$handler;
                    if(is_string($object))    // static method call
                        call_user_func($handler,$event);
                    elseif(method_exists($object,$method))
                        $object-&gt;$method($event);
                    else
                        throw new CException(Yii::t(&apos;yii&apos;,&apos;Event &quot;{class}.{event}&quot; is attached with an invalid handler &quot;{handler}&quot;.&apos;,
                            array(&apos;{class}&apos;=&gt;get_class($this), &apos;{event}&apos;=&gt;$name, &apos;{handler}&apos;=&gt;$handler[1])));
                }
                else // PHP 5.3: anonymous function
                    call_user_func($handler,$event);
            }
            else
                throw new CException(Yii::t(&apos;yii&apos;,&apos;Event &quot;{class}.{event}&quot; is attached with an invalid handler &quot;{handler}&quot;.&apos;,
                    array(&apos;{class}&apos;=&gt;get_class($this), &apos;{event}&apos;=&gt;$name, &apos;{handler}&apos;=&gt;gettype($handler))));
            // stop further handling if param.handled is set true
            if(($event instanceof CEvent) &amp;&amp; $event-&gt;handled)
                return;
        }
    }
    elseif(YII_DEBUG &amp;&amp; !$this-&gt;hasEvent($name))
        throw new CException(Yii::t(&apos;yii&apos;,&apos;Event &quot;{class}.{event}&quot; is not defined.&apos;,
            array(&apos;{class}&apos;=&gt;get_class($this), &apos;{event}&apos;=&gt;$name)));
}</code></pre><p>CWebApplication.php</p>
<pre><code>    /**
 * Processes the current request.
 * It first resolves the request into controller and action,
 * and then creates the controller to perform the action.
 */
public function processRequest()
{
    if(is_array($this-&gt;catchAllRequest) &amp;&amp; isset($this-&gt;catchAllRequest[0]))
    {
        $route=$this-&gt;catchAllRequest[0];
        foreach(array_splice($this-&gt;catchAllRequest,1) as $name=&gt;$value)
            $_GET[$name]=$value;
    }
    else
        $route=$this-&gt;getUrlManager()-&gt;parseUrl($this-&gt;getRequest());
    $this-&gt;runController($route);
}





public function runController($route)
{
    if(($ca=$this-&gt;createController($route))!==null)
    {
        list($controller,$actionID)=$ca;
        $oldController=$this-&gt;_controller;
        $this-&gt;_controller=$controller;
        $controller-&gt;init();
        $controller-&gt;run($actionID);
        $this-&gt;_controller=$oldController;
    }
    else
        throw new CHttpException(404,Yii::t(&apos;yii&apos;,&apos;Unable to resolve the request &quot;{route}&quot;.&apos;,
            array(&apos;{route}&apos;=&gt;$route===&apos;&apos;?$this-&gt;defaultController:$route)));
}</code></pre><p>CController.php</p>
<pre><code>public function run($actionID)
{
    if(($action=$this-&gt;createAction($actionID))!==null)
    {
        if(($parent=$this-&gt;getModule())===null)
            $parent=Yii::app();
        if($parent-&gt;beforeControllerAction($this,$action))
        {
            $this-&gt;runActionWithFilters($action,$this-&gt;filters());
            $parent-&gt;afterControllerAction($this,$action);
        }
    }
    else
        $this-&gt;missingAction($actionID);
}



public function runActionWithFilters($action,$filters)
{
    if(empty($filters))
        $this-&gt;runAction($action);
    else
    {
        $priorAction=$this-&gt;_action;
        $this-&gt;_action=$action;
        CFilterChain::create($this,$action,$filters)-&gt;run();
        $this-&gt;_action=$priorAction;
    }
}


public function runAction($action)
{
    $priorAction=$this-&gt;_action;
    $this-&gt;_action=$action;
    if($this-&gt;beforeAction($action))
    {
        if($action-&gt;runWithParams($this-&gt;getActionParams())===false)
            $this-&gt;invalidActionParams($action);
        else
            $this-&gt;afterAction($action);
    }
    $this-&gt;_action=$priorAction;
}</code></pre><p>CAction.php</p>
<pre><code>public function runWithParams($params)
{
    $method=new ReflectionMethod($this, &apos;run&apos;);
    if($method-&gt;getNumberOfParameters()&gt;0)
        return $this-&gt;runWithParamsInternal($this, $method, $params);
    else
        return $this-&gt;run();
}


protected function runWithParamsInternal($object, $method, $params)
{
    $ps=array();
    foreach($method-&gt;getParameters() as $i=&gt;$param)
    {
        $name=$param-&gt;getName();
        if(isset($params[$name]))
        {
            if($param-&gt;isArray())
                $ps[]=is_array($params[$name]) ? $params[$name] : array($params[$name]);
            elseif(!is_array($params[$name]))
                $ps[]=$params[$name];
            else
                return false;
        }
        elseif($param-&gt;isDefaultValueAvailable())
            $ps[]=$param-&gt;getDefaultValue();
        else
            return false;
    }
    $method-&gt;invokeArgs($object,$ps);
    return true;
}</code></pre><p>CViewAction.php</p>
<pre><code>public function run()
{
    $this-&gt;resolveView($this-&gt;getRequestedView());
    $controller=$this-&gt;getController();
    if($this-&gt;layout!==null)
    {
        $layout=$controller-&gt;layout;
        $controller-&gt;layout=$this-&gt;layout;
    }

    $this-&gt;onBeforeRender($event=new CEvent($this));
    if(!$event-&gt;handled)
    {
        if($this-&gt;renderAsText)
        {
            $text=file_get_contents($controller-&gt;getViewFile($this-&gt;view));
            $controller-&gt;renderText($text);
        }
        else
            $controller-&gt;render($this-&gt;view);
        $this-&gt;onAfterRender(new CEvent($this));
    }

    if($this-&gt;layout!==null)
        $controller-&gt;layout=$layout;
}</code></pre><p>CController.php</p>
<pre><code>public function renderText($text,$return=false)
{
    if(($layoutFile=$this-&gt;getLayoutFile($this-&gt;layout))!==false)
        $text=$this-&gt;renderFile($layoutFile,array(&apos;content&apos;=&gt;$text),true);

    $text=$this-&gt;processOutput($text);

    if($return)
        return $text;
    else
        echo $text;
}

public function render($view,$data=null,$return=false)
{
    if($this-&gt;beforeRender($view))
    {
        $output=$this-&gt;renderPartial($view,$data,true);
        if(($layoutFile=$this-&gt;getLayoutFile($this-&gt;layout))!==false)
            $output=$this-&gt;renderFile($layoutFile,array(&apos;content&apos;=&gt;$output),true);

        $this-&gt;afterRender($view,$output);

        $output=$this-&gt;processOutput($output);

        if($return)
            return $output;
        else
            echo $output;
    }
}</code></pre><p>5.祖先类</p>
<p>CComponent</p>
<p>6.结果怎么传给客户端</p>
<p>php echo HTML 给web服务器，web服务器会打包成HTTP reponse给浏览器</p>
<p>###流程</p>
<p>请求url-&gt;解析url-&gt;controller-&gt;view</p>
<p>###模块</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/11/25/2014-11-25-yii/" data-id="ck521h107001glc7k7ymu8jf6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2014-11-25-work" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/11/25/2014-11-25-work/" class="article-date">
  <time datetime="2014-11-24T16:00:00.000Z" itemprop="datePublished">2014-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/25/2014-11-25-work/">work</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##个人作品</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/11/25/2014-11-25-work/" data-id="ck521h105001elc7k5h5h8awx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2014-9-24-privacy" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/24/2014-9-24-privacy/" class="article-date">
  <time datetime="2014-09-23T16:00:00.000Z" itemprop="datePublished">2014-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/24/2014-9-24-privacy/">艺考管家隐私政策</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##艺考管家隐私政策</p>
<p>###隐私政策</p>
<p>您在注册帐号或使用本服务的过程中，可能需要填写一些必要的信息。若国家法律法规有特殊规定的，您需要填写真实的身份信息。若您填写的信息不完整，则无法使用本服务或在使用过程中受到限制。</p>
<p>一般情况下，您可随时浏览、修改自己提交的信息，但出于安全性和身份识别（如号码申诉服务）的考虑，您可能无法修改注册时提供的初始注册信息及其他验证信息。</p>
<p>我们运用各种安全技术和程序建立完善的管理制度来保护您的个人信息，以免遭受未经授权的访问、使用或披露。</p>
<p>未经您的同意，我们不会向其他任何公司、组织和个人披露您的个人敏感信息，但法律法规或本协议另有规定的除外。</p>
<p>###隐私政策条款</p>
<p>使用本App即表示您同意此隐私政策的条款和条件。如果您不同意本政策，请不要使用该App。我们保留权利，在我们决定更改，修改，增加或删除本政策的部分，在任何时候。请定期浏览此网页查阅任何修改。如果您继续使用我们的App以后的任何更改这些条款的发布将意味着你已经接受了这些调整。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/09/24/2014-9-24-privacy/" data-id="ck521h10i001tlc7kg3vo6ixr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2014-8-5-ios_frame" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/05/2014-8-5-ios_frame/" class="article-date">
  <time datetime="2014-08-04T16:00:00.000Z" itemprop="datePublished">2014-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/05/2014-8-5-ios_frame/">iso frame</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##iso frame </p>
<p>The frame rectangle … describes the view’s location and size in its superview’s coordinate system.</p>
<p>The viewʼs bounds rectangle describe the position and size of the visible area.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/05/2014-8-5-ios_frame/" data-id="ck521h10h001slc7k41dy2bnd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/20/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/22/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/05/2020-1-5-datax/">离线同步工具DataX</a>
          </li>
        
          <li>
            <a href="/2019/12/31/2019-12-31-replicate/">分布式系统数据同步</a>
          </li>
        
          <li>
            <a href="/2019/12/28/2019-12-28-LCH/">LCH</a>
          </li>
        
          <li>
            <a href="/2019/12/26/2019-12-26-lambda/">lambda</a>
          </li>
        
          <li>
            <a href="/2019/12/26/2019-12-26-listener/">观察者模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
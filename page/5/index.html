<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="default-2019-7-11-springmvc" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/11/2019-7-11-springmvc/" class="article-date">
  <time datetime="2019-07-10T16:00:00.000Z" itemprop="datePublished">2019-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/11/2019-7-11-springmvc/">springmvc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h1><h2 id="tomcat触发"><a href="#tomcat触发" class="headerlink" title="tomcat触发"></a>tomcat触发</h2><p>org.apache.catalina.core.StandardContext#startInternal</p>
<p>org.apache.catalina.core.StandardContext#listenerStart</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; instances.length; i++) &#123;</span><br><span class="line">	listener.contextInitialized(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xml方式spring-ioc容器初始化（根上下文）"><a href="#xml方式spring-ioc容器初始化（根上下文）" class="headerlink" title="xml方式spring ioc容器初始化（根上下文）"></a>xml方式spring ioc容器初始化（根上下文）</h2><p><strong>Spring Framework本身没有Web功能，Spring MVC使用WebApplicationContext接口扩展ApplicationContext，使得拥有web功能，WebApplicationContext接口默认的实现是XmlWebApplicationContext</strong></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191217112839316.png" alt="image-20191217112839316"></p>
<p>application-context.xml配置context等全局信息，包括设置servlet和servlet-mapping、filter信息</p>
<p>mvc.xml配置DispatcherServlet信息</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">      	// context相关监听器，处理初始化和销毁事件</span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialize the root web application context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">		initWebApplicationContext(event.getServletContext());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Close the root web application context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">		closeWebApplicationContext(event.getServletContext());</span><br><span class="line">		ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在整个web应用中，只能有一个根上下文，判断ServletContext中是否已经有根上下文 </span></span><br><span class="line">  <span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"Cannot initialize context because there is already a root application context present - "</span> +</span><br><span class="line">            <span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Log logger = LogFactory.getLog(ContextLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Store context in local instance variable, to guarantee that</span></span><br><span class="line">      <span class="comment">// it is available on ServletContext shutdown.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判空 (以注解方式配置时非空)</span></span><br><span class="line">         <span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line">         <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">            <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">            <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">            <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line">               <span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">               <span class="comment">// 根上下文也有双亲上下文</span></span><br><span class="line">               ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">               cwac.setParent(parent);</span><br><span class="line">            &#125;</span><br><span class="line">           	<span class="comment">// 配置根上下文</span></span><br><span class="line">            configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 将applicationContext设置到servletContext中</span></span><br><span class="line">     servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line"></span><br><span class="line">      ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">      <span class="keyword">if</span> (ccl == ContextLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()) </span>&#123;</span><br><span class="line">         currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">         currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> +</span><br><span class="line">               WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">         <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">         logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">      logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">      logger.error(<span class="string">"Context initialization failed"</span>, err);</span><br><span class="line">      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ServletContext sc)</span> </span>&#123;</span><br><span class="line">   Class&lt;?&gt; contextClass = determineContextClass(sc);</span><br><span class="line">   <span class="keyword">if</span> (!ConfigurableWebApplicationContext<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">contextClass</span>)) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Custom context class ["</span> + contextClass.getName() +</span><br><span class="line">            "] is not of type [" + ConfigurableWebApplicationContext.class.getName() + "]");</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从initParameter的contextClass参数或者ContextLoader.properties文件中（org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext）获取contextClassName</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">   <span class="comment">// 根据web.xml的配置决定WebApplicationContext</span></span><br><span class="line">   String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line">   <span class="keyword">if</span> (contextClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">               <span class="string">"Failed to load custom context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 根据配置文件ContextLoader.properties决定WebApplicationContext</span></span><br><span class="line">      contextClassName = defaultStrategies.getProperty(WebApplicationContext<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">               <span class="string">"Failed to load default context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac, ServletContext sc)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">      <span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">      <span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">      String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line">      <span class="keyword">if</span> (idParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">         wac.setId(idParam);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Generate default id...</span></span><br><span class="line">         wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">               ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   wac.setServletContext(sc);</span><br><span class="line">   String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line">   <span class="keyword">if</span> (configLocationParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">      wac.setConfigLocation(configLocationParam);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The wac environment's #initPropertySources will be called in any case when the context</span></span><br><span class="line">   <span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line">   <span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">   ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">   <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">      ((ConfigurableWebEnvironment) env).initPropertySources(sc, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">	 <span class="comment">// 根据xml定制上下文（初始化ApplicationContextInitializer接口的实现）</span></span><br><span class="line">   customizeContext(sc, wac);</span><br><span class="line">   <span class="comment">// spring容器初始化</span></span><br><span class="line">   wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mvc容器diapatcherServlet的初始化（子上下文）"><a href="#mvc容器diapatcherServlet的初始化（子上下文）" class="headerlink" title="mvc容器diapatcherServlet的初始化（子上下文）"></a>mvc容器diapatcherServlet的初始化（子上下文）</h2><h3 id="tomcat端触发"><a href="#tomcat端触发" class="headerlink" title="tomcat端触发"></a>tomcat端触发</h3><p>org.apache.catalina.core.StandardWrapper#loadServlet</p>
<p>org.apache.catalina.core.StandardWrapper#initServlet</p>
<p>servlet.init(facade);</p>
<h3 id="servlet端"><a href="#servlet端" class="headerlink" title="servlet端"></a>servlet端</h3><p>由ContextLoaderListener首先启动的上下文为根上下文，该上下文是与ServletContext相伴而生的，在根上下文的基础上，Spring MVC对应持有的一个用来管理控制器需要的对象的子上下文</p>
<p><strong>ContextLoaderListener加载的时候已经创建了WebApplicationContext实例，而在这里是对这个实例的进一步补充初始化</strong></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191217134337828.png" alt="image-20191217134337828"></p>
<p>org.springframework.web.servlet.HttpServletBean#init</p>
<p>org.springframework.web.servlet.FrameworkServlet#initServletBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">  <span class="comment">// 读取web.xml中DispatchServlet定义中的&lt;init-param&gt;，对Bean属性进行配置</span></span><br><span class="line">   PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">   <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 生成一个BeanWrapper，将当前的这个Servlet类转化为一个BeanWrapper，从而能够以Spring的方式来对init-param的值进行注入</span></span><br><span class="line">         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">         ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">         bw.registerCustomEditor(Resource<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ResourceEditor</span>(<span class="title">resourceLoader</span>, <span class="title">getEnvironment</span>()))</span>;</span><br><span class="line">         initBeanWrapper(bw);</span><br><span class="line">         bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">  <span class="comment">// 创建子容器</span></span><br><span class="line">   initServletBean();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">   getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">      initFrameworkServlet();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">      <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">      <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization completed in "</span> +</span><br><span class="line">            elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>DispatcherServlet创建WebApplicationContext作为springmvc的上下文 并将ContextLoadListener创建的上下文设置为自身的parent</p>
<p>org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里调用WebApplicationContextUtils静态类来从ServletContext中得到根上下文，使用这个根上下文作为当前MVC上下文的双亲上下文。</span></span><br><span class="line">   WebApplicationContext rootContext =</span><br><span class="line">         WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">   WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">      wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">      <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">         <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">            <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">            <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">            <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">               <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">               cwac.setParent(rootContext);</span><br><span class="line">            &#125;</span><br><span class="line">            configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">      <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">      <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">      <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">      wac = findWebApplicationContext();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">     <span class="comment">// 在ServletContext没有context实例，所以需要创建一个WebApplicationContext，以根上下文为双亲下文创建</span></span><br><span class="line">      wac = createWebApplicationContext(rootContext);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">      <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">      <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">      <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">      onRefresh(wac);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">      <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">      String attrName = getServletContextAttributeName();</span><br><span class="line">      getServletContext().setAttribute(attrName, wac);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</span><br><span class="line">               <span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.web.servlet.DispatcherServlet#onRefresh</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">	initStrategies(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">		initMultipartResolver(context);</span><br><span class="line">		initLocaleResolver(context);</span><br><span class="line">		initThemeResolver(context);</span><br><span class="line">  	<span class="comment">// 初始化不同的handlermapping</span></span><br><span class="line">		initHandlerMappings(context);</span><br><span class="line">    <span class="comment">// 初始化不同的handlerAdpters，逻辑同上，如果没有adapter注入，使用DispatcherServlet.properties文件里是（org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter）</span></span><br><span class="line">		initHandlerAdapters(context);</span><br><span class="line">		initHandlerExceptionResolvers(context);</span><br><span class="line">		initRequestToViewNameTranslator(context);</span><br><span class="line">  	<span class="comment">// 初始化视图解析器</span></span><br><span class="line">		initViewResolvers(context);</span><br><span class="line">		initFlashMapManager(context);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="line">	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</span><br><span class="line">	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</span><br></pre></td></tr></table></figure>

<p>加了&lt;mvc:annotation-driven /&gt;注解会加载如下bean</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191217162033594.png" alt="image-20191217162033594"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">     <span class="comment">// 从srping容器里找实现HandlerMapping.class的bean，可以自己实现该handlerMapping</span></span><br><span class="line">		<span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">		Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">				BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">			<span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">			AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			<span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">			<span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line">	<span class="comment">// a default HandlerMapping if no other mappings are found.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 如果容器里找不到handlerMappings，即xml里没有配置handlerMapping</span></span><br><span class="line">     <span class="comment">// 从DispatcherServlet.properties读取handerMapping并放入spring容器里</span></span><br><span class="line">		<span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过文件初始化handlerMapping</p>
<p>定义在org/springframework/web/servlet/DispatcherServlet.properties文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</span><br></pre></td></tr></table></figure>

<p><strong>两种主要的handlerMapping，RequestMappingHandlerMapping，SimpleUrlHandlerMapping</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">The two main HandlerMapping implementations are RequestMappingHandlerMapping (which supports @RequestMapping annotated methods) and SimpleUrlHandlerMapping (which maintains explicit registrations of URI path patterns to handlers).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;urlMapping&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;interceptors&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;ref bean&#x3D;&quot;localeChangeInterceptor&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mappings&quot;&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;**&#x2F;*.view&#x3D;someController&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>



<p>DispatcherServlet类，加载DispatcherServlet.properties文件，初始化defaultStrategies</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">// Load default strategy implementations from properties file.</span></span><br><span class="line">		<span class="comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line">		<span class="comment">// by application developers.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH + <span class="string">"': "</span> + ex.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>有三种方式注册handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">Implements Controller</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">implements HttpRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.</span><br><span class="line"><span class="meta">@Controller</span></span><br></pre></td></tr></table></figure>



<p>Spring MVC提供了许多HandlerMapping的实现，默认使用的是BeanNameUrlHandlerMapping，可以根据Bean的name属性映射到URL中</p>
<p>HandlerMapping继承的ApplicationObjectSupport实现了ApplicationContextAware，spring的bean后置处理器，会调用他的setApplicationContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">   ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setApplicationContext里会调用子类的initApplicationContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(@Nullable ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (context == <span class="keyword">null</span> &amp;&amp; !isContextRequired()) &#123;</span><br><span class="line">      <span class="comment">// Reset internal context state.</span></span><br><span class="line">      <span class="keyword">this</span>.applicationContext = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Initialize with passed-in context.</span></span><br><span class="line">      <span class="keyword">if</span> (!requiredContextClass().isInstance(context)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">               <span class="string">"Invalid application context: needs to be of type ["</span> + requiredContextClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.applicationContext = context;</span><br><span class="line">      <span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">new</span> MessageSourceAccessor(context);</span><br><span class="line">      initApplicationContext(context);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Ignore reinitialization if same context passed in.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != context) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">               <span class="string">"Cannot reinitialize with different application context: current one is ["</span> +</span><br><span class="line">               <span class="keyword">this</span>.applicationContext + <span class="string">"], passed-in one is ["</span> + context + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDetectingUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractUrlHandlerMapping</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> ApplicationContextException </span>&#123;</span><br><span class="line">      <span class="comment">// 设置拦截器</span></span><br><span class="line">      <span class="keyword">super</span>.initApplicationContext();</span><br><span class="line">      detectHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注册url和handler bean的关联</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		ApplicationContext applicationContext = obtainApplicationContext();</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Looking for URL mappings in application context: "</span> + applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		String[] beanNames = (<span class="keyword">this</span>.detectHandlersInAncestorContexts ?</span><br><span class="line">				BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :</span><br><span class="line">				applicationContext.getBeanNamesForType(Object<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Take any bean name that we can determine URLs for.</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="comment">// 找到bean名开头是"/"的bean</span></span><br><span class="line">			String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line">			<span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">				<span class="comment">// URL paths found: Let's consider it a handler.</span></span><br><span class="line">        <span class="comment">// 把url和对应的bean注册到this.handlerMap，bean即handler</span></span><br><span class="line">				registerHandler(urls, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Rejected bean name '"</span> + beanName + <span class="string">"': no URL paths identified"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanNameUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractDetectingUrlHandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="comment">// 找到beanName开头是"/"或者别名里开头是"/"的bean</span></span><br><span class="line">	<span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">		List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (beanName.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">			urls.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliases = obtainApplicationContext().getAliases(beanName);</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			<span class="keyword">if</span> (alias.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">				urls.add(alias);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanNameUrlHandlerMapping-1"><a href="#BeanNameUrlHandlerMapping-1" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingHandlerMapping</span> <span class="keyword">extends</span> <span class="title">RequestMappingInfoHandlerMapping</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">MatchableHandlerMapping</span>, <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.config = <span class="keyword">new</span> RequestMappingInfo.BuilderConfiguration();</span><br><span class="line">      <span class="keyword">this</span>.config.setUrlPathHelper(getUrlPathHelper());</span><br><span class="line">      <span class="keyword">this</span>.config.setPathMatcher(getPathMatcher());</span><br><span class="line">      <span class="keyword">this</span>.config.setSuffixPatternMatch(<span class="keyword">this</span>.useSuffixPatternMatch);</span><br><span class="line">      <span class="keyword">this</span>.config.setTrailingSlashMatch(<span class="keyword">this</span>.useTrailingSlashMatch);</span><br><span class="line">      <span class="keyword">this</span>.config.setRegisteredSuffixPatternMatch(<span class="keyword">this</span>.useRegisteredSuffixPatternMatch);</span><br><span class="line">      <span class="keyword">this</span>.config.setContentNegotiationManager(getContentNegotiationManager());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHandlerMethodMapping</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractHandlerMapping</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">	org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#afterPropertiesSet-&gt;org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#initHandlerMethods</span><br><span class="line"></span><br><span class="line">	将uri mapping到方法</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Looking for request mappings in application context: "</span> + getApplicationContext());</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 获取spring容器里的所有bean</span></span><br><span class="line">		String[] beanNames = (<span class="keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">				BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :</span><br><span class="line">				obtainApplicationContext().getBeanNamesForType(Object<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">				Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="comment">// An unresolvable bean type, probably from a lazy bean - let's ignore it.</span></span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">"Could not resolve target class for bean with name '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">        <span class="comment">// 找到有Controller.class和RequestMapping.class注解的bean</span></span><br><span class="line">				<span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">          <span class="comment">// 找到类里所有RequestMapping注解的方法，映射uri和方法信息</span></span><br><span class="line">					detectHandlerMethods(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将url和bean method注册到urlLookup</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">				assertUniqueMethodMapping(handlerMethod, mapping);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(<span class="string">"Mapped \""</span> + mapping + <span class="string">"\" onto "</span> + handlerMethod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"></span><br><span class="line">				List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line">				<span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line">					<span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				String name = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">					name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">					addMappingName(name, handlerMethod);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line">				<span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<p>HandlerMapping的初始化过程主要分成两部分，通过initInterceptors()方法将SimpleUrlHandlerMapping中定义的interceptors包装成HandlerInterceptor对象保存在adaptedInterceptors数组中，同时通过registerHandlers()方法将SimpleHandlerMapping中定义的mappings（即URL与Handler的映射）注册到handlerMap集合中。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191217104942808.png" alt="image-20191217104942808"></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191217105507248.png" alt="image-20191217105507248"></p>
<h2 id="不使用web-xml，引入springmvc"><a href="#不使用web-xml，引入springmvc" class="headerlink" title="不使用web.xml，引入springmvc"></a>不使用web.xml，引入springmvc</h2><h4 id="重写onStartup方法，只创建1个上下文，不重写则会有2个上下文"><a href="#重写onStartup方法，只创建1个上下文，不重写则会有2个上下文" class="headerlink" title="重写onStartup方法，只创建1个上下文，不重写则会有2个上下文"></a>重写onStartup方法，只创建1个上下文，不重写则会有2个上下文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> </span>&#123;</span><br><span class="line">        XmlWebApplicationContext appContext = <span class="keyword">new</span> XmlWebApplicationContext();</span><br><span class="line">        appContext.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.Dynamic registration = container.addServlet(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> DispatcherServlet(appContext));</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletCxt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load Spring web application configuration</span></span><br><span class="line">        AnnotationConfigWebApplicationContext ac = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        ac.register(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ac.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create and register the DispatcherServlet</span></span><br><span class="line">      	<span class="comment">// 将spring容器复制给servlet</span></span><br><span class="line">        DispatcherServlet servlet = <span class="keyword">new</span> DispatcherServlet(ac);</span><br><span class="line">        ServletRegistration.Dynamic registration = servletCxt.addServlet(<span class="string">"app"</span>, servlet);</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">"/app/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用ServletContainerInitializer接口导入tomcat</p>
<h3 id="spring端"><a href="#spring端" class="headerlink" title="spring端"></a>spring端</h3><p>spring-web工程下有</p>
<p>META-INF/services/javax.servlet.ServletContainerInitializer文件，文件内容为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.SpringServletContainerInitializer</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HandlesTypes</span>(WebApplicationInitializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">		List&lt;WebApplicationInitializer&gt; initializers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (webAppInitializerClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line">				<span class="comment">// Be defensive: Some servlet containers provide us with invalid classes,</span></span><br><span class="line">				<span class="comment">// no matter what @HandlesTypes says...</span></span><br><span class="line">				<span class="keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">						WebApplicationInitializer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">waiClass</span>)) </span>&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						initializers.add((WebApplicationInitializer)</span><br><span class="line">								ReflectionUtils.accessibleConstructor(waiClass).newInstance());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Failed to instantiate WebApplicationInitializer class"</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (initializers.isEmpty()) &#123;</span><br><span class="line">			servletContext.log(<span class="string">"No Spring WebApplicationInitializer types detected on classpath"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		servletContext.log(initializers.size() + <span class="string">" Spring WebApplicationInitializers detected on classpath"</span>);</span><br><span class="line">		AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">		<span class="keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">			initializer.onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同xml一样，也有两个上下文"><a href="#同xml一样，也有两个上下文" class="headerlink" title="同xml一样，也有两个上下文"></a><strong>同xml一样，也有两个上下文</strong></h4><p>流程和xml一样</p>
<p>AbstractDispatcherServletInitializer#onStartup</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onStartup(servletContext);</span><br><span class="line">	<span class="comment">// 创建子上下文</span></span><br><span class="line">	registerDispatcherServlet(servletContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDispatcherServlet</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Servlet名称 一般用系统默认的即可，否则自己复写此方法也成</span></span><br><span class="line">	String servletName = getServletName();</span><br><span class="line">	Assert.hasLength(servletName, <span class="string">"getServletName() must not return null or empty"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建web的子容器。创建的代码和上面差不多，也是使用调用者提供的配置文件，创建AnnotationConfigWebApplicationContext.  备注：此处不可能为null哦</span></span><br><span class="line">	WebApplicationContext servletAppContext = createServletApplicationContext();</span><br><span class="line">	Assert.notNull(servletAppContext, <span class="string">"createServletApplicationContext() must not return null"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建DispatcherServlet，并且把子容器传进去了。其实就是new一个出来，最后加到容器里，就能够执行一些init初始化方法了~</span></span><br><span class="line">	FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);</span><br><span class="line">	Assert.notNull(dispatcherServlet, <span class="string">"createDispatcherServlet(WebApplicationContext) must not return null"</span>);</span><br><span class="line">	<span class="comment">//同样的 getServletApplicationContextInitializers()一般也为null即可</span></span><br><span class="line">	dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册servlet到web容器里面，这样就可以接收请求了</span></span><br><span class="line">	ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);</span><br><span class="line">	<span class="keyword">if</span> (registration == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to register servlet with name '"</span> + servletName + <span class="string">"'. "</span> +</span><br><span class="line">				<span class="string">"Check if there is another servlet registered under the same name."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">	registration.addMapping(getServletMappings()); <span class="comment">//调用者必须实现</span></span><br><span class="line">	registration.setAsyncSupported(isAsyncSupported()); <span class="comment">//默认就是开启了支持异步的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理自定义的Filter进来，一般我们Filter不这么加进来，而是自己@WebFilter，或者借助Spring，  备注：这里添加进来的Filter都仅仅只拦截过滤上面注册的dispatchServlet</span></span><br><span class="line">	Filter[] filters = getServletFilters();</span><br><span class="line">	<span class="keyword">if</span> (!ObjectUtils.isEmpty(filters)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">			registerServletFilter(servletContext, filter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这个很清楚：调用者若相对dispatcherServlet有自己更个性化的参数设置，复写此方法即可</span></span><br><span class="line">	customizeRegistration(registration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>如下：</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	<span class="comment">// 创建根上下文</span></span><br><span class="line">	registerContextLoaderListener(servletContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerContextLoaderListener</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">	WebApplicationContext rootAppContext = createRootApplicationContext();</span><br><span class="line">	<span class="keyword">if</span> (rootAppContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 创建listener 并且把已经创建好的容器放进去</span></span><br><span class="line">		ContextLoaderListener listener = <span class="keyword">new</span> ContextLoaderListener(rootAppContext);</span><br><span class="line">		<span class="comment">//放入监听器需要的一些上下文，此处木有。一般都为null即可~~~。若有需要（自己定制），子类复写此方法即可</span></span><br><span class="line">		listener.setContextInitializers(getRootApplicationContextInitializers());</span><br><span class="line">		<span class="comment">// 把监听器加入进来  这样该监听器就能监听ServletContext了，并且执行contextInitialized方法</span></span><br><span class="line">		servletContext.addListener(listener);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt;[] configClasses = getRootConfigClasses();</span><br><span class="line">	<span class="keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;</span><br><span class="line">		AnnotationConfigWebApplicationContext context = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">		<span class="comment">//配置文件可以有多个  会以累加的形式添加进去</span></span><br><span class="line">		context.register(configClasses);</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tomcat端"><a href="#tomcat端" class="headerlink" title="tomcat端"></a>tomcat端</h3><p>org.apache.catalina.startup.ContextConfig#processServletContainerInitializers</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ServletContainerInitializer&gt; detectedScis;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    WebappServiceLoader&lt;ServletContainerInitializer&gt; loader = <span class="keyword">new</span> WebappServiceLoader&lt;&gt;(context);</span><br><span class="line">    detectedScis = loader.load(ServletContainerInitializer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(sm.getString(</span><br><span class="line">            <span class="string">"contextConfig.servletContainerInitializerFail"</span>,</span><br><span class="line">            context.getName()),</span><br><span class="line">        e);</span><br><span class="line">    ok = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.apache.catalina.core.StandardContext#startInternal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call ServletContainerInitializers</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">    initializers.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entry.getKey().onStartup(entry.getValue(),</span><br><span class="line">                getServletContext());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"standardContext.sciFail"</span>), e);</span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><p>HandlerMapping</p>
<p>下面的图已经过时</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191217144119968.png" alt="image-20191217144119968"></p>
<p>HandlerAdapter</p>
<p>HandlerException</p>
<p>ResolverViewResolver</p>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>org.springframework.web.servlet.FrameworkServlet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">	HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">	<span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">		processRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">super</span>.service(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.web.servlet.FrameworkServlet#doGet</p>
<p>org.springframework.web.servlet.FrameworkServlet#processRequest</p>
<p>org.springframework.web.servlet.DispatcherServlet#doService</p>
<p>org.springframework.web.servlet.DispatcherServlet#doDispatch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	HttpServletRequest processedRequest = request;</span><br><span class="line">	HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">		Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			processedRequest = checkMultipart(request);</span><br><span class="line">			multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Determine handler for the current request.</span></span><br><span class="line">       <span class="comment">// 获取handler</span></span><br><span class="line">			mappedHandler = getHandler(processedRequest);</span><br><span class="line">			<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">				noHandlerFound(processedRequest, response);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">       <span class="comment">// 决定handler适配器，根据handler类型选择handlerAdapter（boolean supports(Object handler)）</span></span><br><span class="line">			HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">			String method = request.getMethod();</span><br><span class="line">			<span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">			<span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">				<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Actually invoke the handler.</span></span><br><span class="line">       <span class="comment">// 返回ModelAndView</span></span><br><span class="line">			mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			applyDefaultViewName(processedRequest, mv);</span><br><span class="line">			mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			dispatchException = ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">			<span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">			<span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">			dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">		&#125;</span><br><span class="line">     <span class="comment">// 处理ModelAndView</span></span><br><span class="line">		processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">		triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">				<span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">			<span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">				mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">			<span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">				cleanupMultipart(processedRequest);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成ModelAndView"><a href="#生成ModelAndView" class="headerlink" title="生成ModelAndView"></a>生成ModelAndView</h4><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#handleInternal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   ModelAndView mav;</span><br><span class="line">   checkRequest(request);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">      HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">         Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">         mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">      mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">         applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         prepareResponse(response);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已RequestMappingHandlerAdapter为例</p>
<p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">      ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">      ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">         invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">         invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">      &#125;</span><br><span class="line">      invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">      invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">      ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">      mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">      modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">      mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">      AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">      asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">      WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">      asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">      asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">      asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">      asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">         Object result = asyncManager.getConcurrentResult();</span><br><span class="line">         mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">         asyncManager.clearConcurrentResult();</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Found concurrent result value ["</span> + result + <span class="string">"]"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">      <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      webRequest.requestCompleted();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">		setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">				mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">		Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">"No return value handlers"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 选择结果处理器，处理结果</span></span><br><span class="line">			<span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Invoking '"</span> + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +</span><br><span class="line">            <span class="string">"' with arguments "</span> + Arrays.toString(args));</span><br><span class="line">   &#125;</span><br><span class="line">   Object returnValue = doInvoke(args);</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Method ["</span> + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +</span><br><span class="line">            <span class="string">"] returned ["</span> + returnValue + <span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.web.method.support.InvocableHandlerMethod#doInvoke</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the handler method with the given argument values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">      assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">      String text = (ex.getMessage() != <span class="keyword">null</span> ? ex.getMessage() : <span class="string">"Illegal argument"</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getInvocationErrorMessage(text, args), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">      <span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">      Throwable targetException = ex.getTargetException();</span><br><span class="line">      <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         String text = getInvocationErrorMessage(<span class="string">"Failed to invoke handler method"</span>, args);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(text, targetException);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理返回对象"><a href="#处理返回对象" class="headerlink" title="处理返回对象"></a>处理返回对象</h4><p>org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#handleReturnValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(@Nullable Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">      ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown return value type: "</span> + returnType.getParameterType().getName());</span><br><span class="line">   &#125;</span><br><span class="line">   handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title">selectHandler</span><span class="params">(@Nullable Object value, MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> isAsyncValue = isAsyncReturnValue(value, returnType);</span><br><span class="line">   <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="keyword">this</span>.returnValueHandlers) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isAsyncValue &amp;&amp; !(handler <span class="keyword">instanceof</span> AsyncHandlerMethodReturnValueHandler)) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (handler.supportsReturnType(returnType)) &#123;</span><br><span class="line">         <span class="keyword">return</span> handler;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor为例，处理有@ResponseBody注解的返回结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody<span class="class">.<span class="keyword">class</span>) ||</span></span><br><span class="line"><span class="class">         <span class="title">returnType</span>.<span class="title">hasMethodAnnotation</span>(<span class="title">ResponseBody</span>.<span class="title">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(@Nullable Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// RequestHandled设置true，则直接返回response，否则返回view，需要视图解析，</span></span><br><span class="line">		mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">		ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">		ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Try even with null return value. ResponseBodyAdvice could get involved.</span></span><br><span class="line">    <span class="comment">// 消息转换</span></span><br><span class="line">		writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消息转换</span></span><br><span class="line">	<span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithMessageConverters</span><span class="params">(@Nullable T value, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">			ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Object outputValue;</span><br><span class="line">		Class&lt;?&gt; valueType;</span><br><span class="line">		Type declaredType;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (value <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">			outputValue = value.toString();</span><br><span class="line">			valueType = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">			declaredType = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 返回值非字符串</span></span><br><span class="line">			outputValue = value;</span><br><span class="line">			valueType = getReturnValueType(outputValue, returnType);</span><br><span class="line">			declaredType = getGenericType(returnType);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (isResourceType(value, returnType)) &#123;</span><br><span class="line">			outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, <span class="string">"bytes"</span>);</span><br><span class="line">			<span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				Resource resource = (Resource) value;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					List&lt;HttpRange&gt; httpRanges = inputMessage.getHeaders().getRange();</span><br><span class="line">					outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());</span><br><span class="line">					outputValue = HttpRange.toResourceRegions(httpRanges, resource);</span><br><span class="line">					valueType = outputValue.getClass();</span><br><span class="line">					declaredType = RESOURCE_REGION_LIST_TYPE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">					outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, <span class="string">"bytes */"</span> + resource.contentLength());</span><br><span class="line">					outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		List&lt;MediaType&gt; mediaTypesToUse;</span><br><span class="line"></span><br><span class="line">		MediaType contentType = outputMessage.getHeaders().getContentType();</span><br><span class="line">		<span class="keyword">if</span> (contentType != <span class="keyword">null</span> &amp;&amp; contentType.isConcrete()) &#123;</span><br><span class="line">			mediaTypesToUse = Collections.singletonList(contentType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			HttpServletRequest request = inputMessage.getServletRequest();</span><br><span class="line">			List&lt;MediaType&gt; requestedMediaTypes = getAcceptableMediaTypes(request);</span><br><span class="line">			List&lt;MediaType&gt; producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (outputValue != <span class="keyword">null</span> &amp;&amp; producibleMediaTypes.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotWritableException(</span><br><span class="line">						<span class="string">"No converter found for return value of type: "</span> + valueType);</span><br><span class="line">			&#125;</span><br><span class="line">			mediaTypesToUse = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (MediaType requestedType : requestedMediaTypes) &#123;</span><br><span class="line">				<span class="keyword">for</span> (MediaType producibleType : producibleMediaTypes) &#123;</span><br><span class="line">					<span class="keyword">if</span> (requestedType.isCompatibleWith(producibleType)) &#123;</span><br><span class="line">						mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (mediaTypesToUse.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (outputValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotAcceptableException(producibleMediaTypes);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			MediaType.sortBySpecificityAndQuality(mediaTypesToUse);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MediaType selectedMediaType = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (MediaType mediaType : mediaTypesToUse) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mediaType.isConcrete()) &#123;</span><br><span class="line">				selectedMediaType = mediaType;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) &#123;</span><br><span class="line">				selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (selectedMediaType != <span class="keyword">null</span>) &#123;</span><br><span class="line">			selectedMediaType = selectedMediaType.removeQualityValue();</span><br><span class="line">      <span class="comment">// 遍历messageConverters</span></span><br><span class="line">			<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">				GenericHttpMessageConverter genericConverter = (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ?</span><br><span class="line">						(GenericHttpMessageConverter&lt;?&gt;) converter : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// canWrite判断该消息转换器是否支持该返回类型</span></span><br><span class="line">				<span class="keyword">if</span> (genericConverter != <span class="keyword">null</span> ?</span><br><span class="line">						((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) :</span><br><span class="line">						converter.canWrite(valueType, selectedMediaType)) &#123;</span><br><span class="line">          <span class="comment">// Advice拦截返回结果</span></span><br><span class="line">					outputValue = getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,</span><br><span class="line">							(Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),</span><br><span class="line">							inputMessage, outputMessage);</span><br><span class="line">					<span class="keyword">if</span> (outputValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">						addContentDispositionHeader(inputMessage, outputMessage);</span><br><span class="line">						<span class="keyword">if</span> (genericConverter != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 根据选择的messageConverter</span></span><br><span class="line">							genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">							logger.debug(<span class="string">"Written ["</span> + outputValue + <span class="string">"] as \""</span> + selectedMediaType +</span><br><span class="line">									<span class="string">"\" using ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (outputValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotAcceptableException(<span class="keyword">this</span>.allSupportedMediaTypes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>已Jackson2HttpMessageConverter为例</p>
<p>org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#writeInternal</p>
<h4 id="返回mav"><a href="#返回mav" class="headerlink" title="返回mav"></a>返回mav</h4><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getModelAndView</p>
<p><strong>将返回结果和viewName放入ModelAndViewContainer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">getModelAndView</span><span class="params">(ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">      ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line">   <span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ModelMap model = mavContainer.getModel();</span><br><span class="line">   ModelAndView mav = <span class="keyword">new</span> ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">   <span class="keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">      mav.setView((View) mavContainer.getView());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (model <span class="keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">      Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">      HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">         RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视图渲染"><a href="#视图渲染" class="headerlink" title="视图渲染"></a>视图渲染</h4><p>org.springframework.web.servlet.DispatcherServlet#processDispatchResult</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">         logger.debug(<span class="string">"ModelAndViewDefiningException encountered"</span>, exception);</span><br><span class="line">         mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">         mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">         errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">   <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">      <span class="comment">// 渲染视图</span></span><br><span class="line">      render(mv, request, response);</span><br><span class="line">      <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">         WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Null ModelAndView returned to DispatcherServlet with name '"</span> + getServletName() +</span><br><span class="line">               <span class="string">"': assuming HandlerAdapter completed request handling"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">      <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// Determine locale for request and apply it to the response.</span></span><br><span class="line">   Locale locale =</span><br><span class="line">         (<span class="keyword">this</span>.localeResolver != <span class="keyword">null</span> ? <span class="keyword">this</span>.localeResolver.resolveLocale(request) : request.getLocale());</span><br><span class="line">   response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">   View view;</span><br><span class="line">   String viewName = mv.getViewName();</span><br><span class="line">   <span class="keyword">if</span> (viewName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 视图名</span></span><br><span class="line">      <span class="comment">// We need to resolve the view name.</span></span><br><span class="line">      view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line">      <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Could not resolve view with name '"</span> + mv.getViewName() +</span><br><span class="line">               <span class="string">"' in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">     	<span class="comment">// 数据实体</span></span><br><span class="line">      <span class="comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">      view = mv.getView();</span><br><span class="line">      <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"ModelAndView ["</span> + mv + <span class="string">"] neither contains a view name nor a "</span> +</span><br><span class="line">               <span class="string">"View object in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Delegate to the View object for rendering.</span></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Rendering view ["</span> + view + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mv.getStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         response.setStatus(mv.getStatus().value());</span><br><span class="line">      &#125;</span><br><span class="line">     	<span class="comment">// 渲染视图</span></span><br><span class="line">      view.render(mv.getModelInternal(), request, response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Error rendering view ["</span> + view + <span class="string">"] in DispatcherServlet with name '"</span> +</span><br><span class="line">               getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">resolveViewName</span><span class="params">(String viewName, @Nullable Map&lt;String, Object&gt; model,</span></span></span><br><span class="line"><span class="function"><span class="params">      Locale locale, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.viewResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ViewResolver viewResolver : <span class="keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">        <span class="comment">// 遍历注册的viewResolvers</span></span><br><span class="line">         View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line">         <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!isCache()) &#123;</span><br><span class="line">     <span class="comment">// 如果子类重写，则调用子类createView</span></span><br><span class="line">      <span class="keyword">return</span> createView(viewName, locale);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      Object cacheKey = getCacheKey(viewName, locale);</span><br><span class="line">      View view = <span class="keyword">this</span>.viewAccessCache.get(cacheKey);</span><br><span class="line">      <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>.viewCreationCache) &#123;</span><br><span class="line">            view = <span class="keyword">this</span>.viewCreationCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// Ask the subclass to create the View object.</span></span><br><span class="line">               view = createView(viewName, locale);</span><br><span class="line">               <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.cacheUnresolved) &#123;</span><br><span class="line">                  view = UNRESOLVED_VIEW;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.viewAccessCache.put(cacheKey, view);</span><br><span class="line">                  <span class="keyword">this</span>.viewCreationCache.put(cacheKey, view);</span><br><span class="line">                  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                     logger.trace(<span class="string">"Cached view ["</span> + cacheKey + <span class="string">"]"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (view != UNRESOLVED_VIEW ? view : <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>已InternalResourceViewResolver为例子，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">*   &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.JstlView&quot;&#x2F;&gt;</span><br><span class="line">*   &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">*   &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;</span><br><span class="line">* &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">createView</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// If this resolver is not supposed to handle the given view,</span></span><br><span class="line">   <span class="comment">// return null to pass on to the next resolver in the chain.</span></span><br><span class="line">   <span class="keyword">if</span> (!canHandle(viewName, locale)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check for special "redirect:" prefix.</span></span><br><span class="line">   <span class="keyword">if</span> (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123;</span><br><span class="line">      String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());</span><br><span class="line">      RedirectView view = <span class="keyword">new</span> RedirectView(redirectUrl,</span><br><span class="line">            isRedirectContextRelative(), isRedirectHttp10Compatible());</span><br><span class="line">      String[] hosts = getRedirectHosts();</span><br><span class="line">      <span class="keyword">if</span> (hosts != <span class="keyword">null</span>) &#123;</span><br><span class="line">         view.setHosts(hosts);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> applyLifecycleMethods(REDIRECT_URL_PREFIX, view);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check for special "forward:" prefix.</span></span><br><span class="line">   <span class="keyword">if</span> (viewName.startsWith(FORWARD_URL_PREFIX)) &#123;</span><br><span class="line">      String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> InternalResourceView(forwardUrl);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Else fall back to superclass implementation: calling loadView.</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">super</span>.createView(viewName, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>org.springframework.web.servlet.view.UrlBasedViewResolver#buildView</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractUrlBasedView <span class="title">buildView</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// JstlView</span></span><br><span class="line">   Class&lt;?&gt; viewClass = getViewClass();</span><br><span class="line">   Assert.state(viewClass != <span class="keyword">null</span>, <span class="string">"No view class"</span>);</span><br><span class="line"></span><br><span class="line">   AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass);</span><br><span class="line">   <span class="comment">// 视图文件名getPrefix() + viewName + getSuffix()</span></span><br><span class="line">   view.setUrl(getPrefix() + viewName + getSuffix());</span><br><span class="line"></span><br><span class="line">   String contentType = getContentType();</span><br><span class="line">   <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      view.setContentType(contentType);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   view.setRequestContextAttribute(getRequestContextAttribute());</span><br><span class="line">   view.setAttributesMap(getAttributesMap());</span><br><span class="line"></span><br><span class="line">   Boolean exposePathVariables = getExposePathVariables();</span><br><span class="line">   <span class="keyword">if</span> (exposePathVariables != <span class="keyword">null</span>) &#123;</span><br><span class="line">      view.setExposePathVariables(exposePathVariables);</span><br><span class="line">   &#125;</span><br><span class="line">   Boolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes();</span><br><span class="line">   <span class="keyword">if</span> (exposeContextBeansAsAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">      view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] exposedContextBeanNames = getExposedContextBeanNames();</span><br><span class="line">   <span class="keyword">if</span> (exposedContextBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">      view.setExposedContextBeanNames(exposedContextBeanNames);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>view.render</p>
<p>org.springframework.web.servlet.view.AbstractView#render</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Rendering view with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"' with model "</span> + model +</span><br><span class="line">         <span class="string">" and static attributes "</span> + <span class="keyword">this</span>.staticAttributes);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response);</span><br><span class="line">   prepareResponse(request, response);</span><br><span class="line">   <span class="comment">// 这里进行真正渲染</span></span><br><span class="line">   renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.web.servlet.view.InternalResourceView#renderMergedOutputModel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">renderMergedOutputModel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Expose the model object as request attributes.</span></span><br><span class="line">   <span class="comment">// 将request属性都放入model</span></span><br><span class="line">   exposeModelAsRequestAttributes(model, request);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Expose helpers as request attributes, if any.</span></span><br><span class="line">   exposeHelpers(request);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Determine the path for the request dispatcher.</span></span><br><span class="line">   <span class="comment">// 要转发的资源地址（xxx.jsp）</span></span><br><span class="line">   String dispatcherPath = prepareForRendering(request, response);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Obtain a RequestDispatcher for the target resource (typically a JSP).</span></span><br><span class="line">   <span class="comment">// 得到web容器（例如tomcat）的request信息</span></span><br><span class="line">   RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);</span><br><span class="line">   <span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Could not get RequestDispatcher for ["</span> + getUrl() +</span><br><span class="line">            <span class="string">"]: Check that the corresponding file exists within your web application archive!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If already included or response already committed, perform include, else forward.</span></span><br><span class="line">   <span class="keyword">if</span> (useInclude(request, response)) &#123;</span><br><span class="line">      response.setContentType(getContentType());</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Including resource ["</span> + getUrl() + <span class="string">"] in InternalResourceView '"</span> + getBeanName() + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      rd.include(request, response);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Note: The forwarded resource is supposed to determine the content type itself.</span></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Forwarding to resource ["</span> + getUrl() + <span class="string">"] in InternalResourceView '"</span> + getBeanName() + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将请求转发到目标地址，之后的事情，JSP解析等等，就是服务器的事情了</span></span><br><span class="line">      rd.forward(request, response);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><ol>
<li>首先方法进入，doDispatch</li>
<li>checkMultipart，判断当前请求是否有文件</li>
<li>getHandler，通过HandleMapping去找一个Controller对象 <ol>
<li><strong>扩展点1</strong>：HandleMapping</li>
<li>Spring boot 扩展Spring mvc，其中就扩展了 HandleMapping 去解析静态资源</li>
</ol>
</li>
<li>getHandlerAdapter， 根据你controller的类型去找一个适配器<ol>
<li>因为Controller有很多种不同的注册方式，所以需要不同的适配器</li>
<li><strong>扩展点2</strong>：HandlerAdapter</li>
</ol>
</li>
<li>handle : 执行Controller逻辑并且进行视图裁决（判断是要重定向还是转发还是响应页面）<ol>
<li>invokeForRequest() 执行方法的全部逻辑</li>
<li>首先给参数赋值  <ol>
<li>参数赋值的<strong>扩展点3</strong>：HandlerMethodArgumentResolver </li>
</ol>
</li>
<li>调用invoke指定方法</li>
</ol>
</li>
<li>setResponseStatus设置ResponseStatus响应状态码 对标：@ResponseStatus注解</li>
<li>handleReturnValue 进行视图裁决<ol>
<li><strong>扩展点4</strong>：returnValueHandlers 通过这个对象来进行判断接下来视图怎么做</li>
</ol>
</li>
<li>handler.handleReturnValue 对重定向返回值处理（判断是否需要响应还是需要重定向）<ol>
<li>如果是@ResponseBody 注解又有一个扩展点:HttpMessageConverter</li>
</ol>
</li>
<li>getModelAndView() 重新封装一个ModelAndView对象 <ol>
<li>如果不需要渲染视图（如果是重定向 || 响应视图的话） 就会返回null</li>
<li>mavContainer.isRequestHandled() 判断是否需要重定向或响应</li>
<li>同时会把model里面的参数放到request.setAttribute（说明model的作用域是request作用域）</li>
</ol>
</li>
<li>processDispatchResult 开始做视图渲染<ol>
<li>判断是否需要响应异常视图</li>
<li><strong>扩展点5</strong>：ViewResolver</li>
<li>拿到视图名称 封装一个视图对象 进行forward</li>
</ol>
</li>
</ol>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191217141620825.png" alt="image-20191217141620825"></p>
<p>使用spring实现mvc设计模式</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/springmvc11.png" alt=""></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/springmvc.png" alt=""></p>
<p>url进入HandlerMapping，找到具体的controller实现类</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/springmvc2.png" alt=""></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/springmvc3.png" alt=""></p>
<p>核心组件</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/springmvc4.png" alt=""></p>
<p>理论上我们可以有任意多个容器（只是我们一般其它的都只放进主容器统一管理上，但Spring是提供了这样的功能的），比如</p>
<ul>
<li>主容器：applicationContext.xml(主文件，包括JDBC配置，hibernate.cfg.xml，与所有的Service与DAO基类)</li>
<li>web子容器：application-servlet.xml（管理Spring MVC9打组件以及相关的Bean）</li>
<li>cache子容器：applicationContext-cache.xml(cache策略配置，管理和缓存相关的Bean)</li>
<li>JMX子容器：applicationContext-jmx.xml(JMX相关的Bean)</li>
<li>…</li>
</ul>
<p><strong>与springmvc不同Spring Boot只有一个上下文</strong></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="http://www.it165.net/pro/html/201502/33644.html" target="_blank" rel="noopener">http://www.it165.net/pro/html/201502/33644.html</a></p>
<p><a href="https://blog.csdn.net/and1kaney/article/details/51214193" target="_blank" rel="noopener">https://blog.csdn.net/and1kaney/article/details/51214193</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1497830" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1497830</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/11/2019-7-11-springmvc/" data-id="ck521h1c5007flc7k1ci2duzw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2019-7-8-mycat" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/2019-7-8-mycat/" class="article-date">
  <time datetime="2019-07-07T16:00:00.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/2019-7-8-mycat/">mycat</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="mycat"><a href="#mycat" class="headerlink" title="mycat"></a>mycat</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/08/2019-7-8-mycat/" data-id="ck521h152006jlc7k8kk6h34j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2019-7-3-spi" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/03/2019-7-3-spi/" class="article-date">
  <time datetime="2019-07-02T16:00:00.000Z" itemprop="datePublished">2019-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/03/2019-7-3-spi/">spi</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="spi"><a href="#spi" class="headerlink" title="spi"></a>spi</h2><p>JDK中，基于SPI的思想，提供了默认具体的实现，<code>ServiceLoader</code>。利用JDK自带的<code>ServiceLoader</code>，可以轻松实现面向<code>服务的注册与发现</code>，完成服务提供与使用的<code>解耦</code></p>
<p>服务注册在META-INF/services文件夹下，通过serviceLoader发现META-INF下的服务。</p>
<p>由于应用面向接口编程，修改服务实现也不影响应用</p>
<p>从第三方包的META-INF/services/底下找类名，找到后初始化类，然后放入providers里</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191203140311725.png" alt="image-20191203140311725"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomServiceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPING_CONFIG_PREFIX = <span class="string">"META-INF/services"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">List&lt;S&gt; <span class="title">loade</span><span class="params">(Class&lt;S&gt; service)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String mappingConfigFile = MAPPING_CONFIG_PREFIX + <span class="string">"/"</span> + service.getName() ;</span><br><span class="line">        <span class="comment">//由于一个接口的实现类可能存在多个jar包中的META-INF目录下，所以下面使用getResources返回一个URL数组</span></span><br><span class="line">        Enumeration&lt;URL&gt; configFileUrls =  CustomServiceLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getResources</span>(<span class="title">mappingConfigFile</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(configFileUrls == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;S&gt; services = <span class="keyword">new</span> LinkedList&lt;S&gt;();</span><br><span class="line">        <span class="keyword">while</span>(configFileUrls.hasMoreElements())&#123;</span><br><span class="line">            URL configFileUrl = configFileUrls.nextElement();</span><br><span class="line">            String configContent = IOUtils.toString(configFileUrl.openStream());</span><br><span class="line">            String[] serviceNames = configContent.split(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(String serviceName : serviceNames)&#123;</span><br><span class="line">                Class serviceClass = CustomServiceLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">loadClass</span>(<span class="title">serviceName</span>)</span>;</span><br><span class="line">                Object serviceInstance = serviceClass.newInstance();</span><br><span class="line">                services.add((S)serviceInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> services ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></p>
<p><a href="https://juejin.im/post/5d2db85d6fb9a07ea7134408" target="_blank" rel="noopener">https://juejin.im/post/5d2db85d6fb9a07ea7134408</a></p>
<p><a href="https://blog.csdn.net/is_zhoufeng/article/details/50722440" target="_blank" rel="noopener">https://blog.csdn.net/is_zhoufeng/article/details/50722440</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/03/2019-7-3-spi/" data-id="ck521h14z006glc7kgg02hnv7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2019-6-27-jstat" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/27/2019-6-27-jstat/" class="article-date">
  <time datetime="2019-06-26T16:00:00.000Z" itemprop="datePublished">2019-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/27/2019-6-27-jstat/">jstat</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 6 1000 20</span><br><span class="line"></span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">1024.0 1024.0  0.0   669.1  172544.0 134976.9  349696.0   69865.2   85464.0 80813.5 10240.0 9412.9    431    2.412   3      0.507    2.918</span><br><span class="line"></span><br><span class="line">参数	描述</span><br><span class="line">S0C	年轻代中第一个survivor（幸存区）的容量 (字节)</span><br><span class="line">S1C	年轻代中第二个survivor（幸存区）的容量 (字节)</span><br><span class="line">S0U	年轻代中第一个survivor（幸存区）目前已使用空间 (字节)</span><br><span class="line">S1U	年轻代中第二个survivor（幸存区）目前已使用空间 (字节)</span><br><span class="line">EC	年轻代中Eden（伊甸园）的容量 (字节)</span><br><span class="line">EU	年轻代中Eden（伊甸园）目前已使用空间 (字节)</span><br><span class="line">OC	Old代的容量 (字节)</span><br><span class="line">OU	Old代目前已使用空间 (字节)</span><br><span class="line">PC	Perm(持久代)的容量 (字节)</span><br><span class="line">PU	Perm(持久代)目前已使用空间 (字节)</span><br><span class="line">YGC	从应用程序启动到采样时年轻代中gc次数</span><br><span class="line">YGCT	从应用程序启动到采样时年轻代中gc所用时间(s)</span><br><span class="line">FGC	从应用程序启动到采样时old代(全gc)gc次数</span><br><span class="line">FGCT	从应用程序启动到采样时old代(全gc)gc所用时间(s)</span><br><span class="line">GCT	从应用程序启动到采样时gc用的总时间(s)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 6</span><br><span class="line"></span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 46.88   0.00  35.86  19.98  94.56  91.92    432    2.416     3    0.507    2.923</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">S0	年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</span><br><span class="line">S1	年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</span><br><span class="line">E	年轻代中Eden（伊甸园）已使用的占当前容量百分比</span><br><span class="line">O	old代已使用的占当前容量百分比</span><br><span class="line">P	perm代已使用的占当前容量百分比</span><br><span class="line">YGC	从应用程序启动到采样时年轻代中gc次数</span><br><span class="line">YGCT	从应用程序启动到采样时年轻代中gc所用时间(s)</span><br><span class="line">FGC	从应用程序启动到采样时old代(全gc)gc次数</span><br><span class="line">FGCT	从应用程序启动到采样时old代(全gc)gc所用时间(s)</span><br><span class="line">GCT	从应用程序启动到采样时gc用的总时间(s)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/27/2019-6-27-jstat/" data-id="ck521h157006qlc7k432f2tr2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2019-6-21-druid" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/21/2019-6-21-druid/" class="article-date">
  <time datetime="2019-06-20T16:00:00.000Z" itemprop="datePublished">2019-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/21/2019-6-21-druid/">druid</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据库连接池druid"><a href="#数据库连接池druid" class="headerlink" title="数据库连接池druid"></a>数据库连接池druid</h2><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;druid</span><br><span class="line"></span><br><span class="line">一些变量命名不好且注释少，难理解</span><br></pre></td></tr></table></figure>
<h3 id="连接池概念"><a href="#连接池概念" class="headerlink" title="连接池概念"></a>连接池概念</h3><p><a href="http://garydai.github.io/2018/01/17/db_pool.html" target="_blank" rel="noopener">http://garydai.github.io/2018/01/17/db_pool.html</a></p>
<p>数据库连接不释放，放到池子里</p>
<p>取链接的时候从池子里拿</p>
<p>怎样保持连接不断开</p>
<p>如果连接一段时间内空闲，则关闭连接</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; init connections，创建连接，使得连接数达到initialSize大小</span><br><span class="line">while (poolingCount &lt; initialSize) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        PhysicalConnectionInfo pyConnectInfo &#x3D; createPhysicalConnection();</span><br><span class="line">        DruidConnectionHolder holder &#x3D; new DruidConnectionHolder(this, pyConnectInfo);</span><br><span class="line">        connections[poolingCount++] &#x3D; holder;</span><br><span class="line">    &#125; catch (SQLException ex) &#123;</span><br><span class="line">        LOG.error(&quot;init datasource error, url: &quot; + this.getUrl(), ex);</span><br><span class="line">        if (initExceptionThrow) &#123;</span><br><span class="line">            connectError &#x3D; ex;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createAndLogThread();</span><br><span class="line">&#x2F;&#x2F; 创建线程用于创建连接</span><br><span class="line">createAndStartCreatorThread();</span><br><span class="line">&#x2F;&#x2F; 创建线程用于关闭连接</span><br><span class="line">createAndStartDestroyThread();</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void createAndStartCreatorThread() &#123;</span><br><span class="line">    if (createScheduler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        不用线程池</span><br><span class="line">        String threadName &#x3D; &quot;Druid-ConnectionPool-Create-&quot; + System.identityHashCode(this);</span><br><span class="line">        createConnectionThread &#x3D; new CreateConnectionThread(threadName);</span><br><span class="line">        createConnectionThread.start();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    initedLatch.countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="createAndStartDestroyThread关闭空闲连接线程"><a href="#createAndStartDestroyThread关闭空闲连接线程" class="headerlink" title="createAndStartDestroyThread关闭空闲连接线程"></a>createAndStartDestroyThread关闭空闲连接线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果连接一段时间内空闲，则关闭连接，timeBetweenEvictionRunsMillis间隔处理一次，默认<span class="number">1</span>分钟</span><br><span class="line">DestroyConnectionThread</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timeBetweenEvictionRunsMillis间隔检测一次</span></span><br><span class="line">    <span class="keyword">if</span> (timeBetweenEvictionRunsMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Thread.sleep(timeBetweenEvictionRunsMillis);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    destroyTask.run();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DestroyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DestroyTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            shrink(<span class="keyword">true</span>, keepAlive);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isRemoveAbandoned()) &#123;</span><br><span class="line">                removeAbandoned();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shrink 销毁线程</span><br><span class="line"></span><br><span class="line">将销毁连接放入evictConnections数组，存活线程放入keepAliveConnections数组</span><br><span class="line"></span><br><span class="line">销毁逻辑：大于minEvictableIdleTimeMillis要连接要关闭，keepAliveConnections要活性检测</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (idleMillis &gt;= minEvictableIdleTimeMillis) &#123;</span><br><span class="line">    <span class="keyword">if</span> (checkTime &amp;&amp; i &lt; checkCount) &#123;</span><br><span class="line">        <span class="comment">// int checkCount = poolingCount - minIdle;</span></span><br><span class="line">        <span class="comment">// checkCount = poolingCount - minIdle个连接，保留&gt;=minIdle个连接，因为i不连续</span></span><br><span class="line">        evictConnections[evictCount++] = connection;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleMillis &gt; maxEvictableIdleTimeMillis) &#123;</span><br><span class="line">        <span class="comment">// 空闲时间大于maxEvictableIdleTimeMillis，则销毁</span></span><br><span class="line">        evictConnections[evictCount++] = connection;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keepAliveBetweenTimeMillis默认2分钟</span></span><br><span class="line"><span class="keyword">if</span> (keepAlive &amp;&amp; idleMillis &gt;= keepAliveBetweenTimeMillis) &#123;</span><br><span class="line">    <span class="comment">// 设置了keepAlive，空闲时间&gt;keepAliveBetweenTimeMillis，则进入keepAliveConnections数组</span></span><br><span class="line">    keepAliveConnections[keepAliveCount++] = connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建连接池，剔除evictConnections和keepAliveConnections里的连接</span></span><br><span class="line"><span class="keyword">int</span> removeCount = evictCount + keepAliveCount;</span><br><span class="line"><span class="keyword">if</span> (removeCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.arraycopy(connections, removeCount, connections, <span class="number">0</span>, poolingCount - removeCount);</span><br><span class="line">    Arrays.fill(connections, poolingCount - removeCount, poolingCount, <span class="keyword">null</span>);</span><br><span class="line">    poolingCount -= removeCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历evictConnections数组，close连接</span></span><br><span class="line"><span class="keyword">if</span> (evictCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; evictCount; ++i) &#123;</span><br><span class="line">        DruidConnectionHolder item = evictConnections[i];</span><br><span class="line">        Connection connection = item.getConnection();</span><br><span class="line">        JdbcUtils.close(connection);</span><br><span class="line">        destroyCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.fill(evictConnections, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历keepAliveConnections里的连接，验证连接</span></span><br><span class="line"><span class="keyword">this</span>.validateConnection(connection);</span><br><span class="line"><span class="comment">// 连接通过验证，则加入连接池，否则关闭连接</span></span><br><span class="line"><span class="keyword">boolean</span> putOk = put(holer, <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果连接数没达到minIdle，则增加连接</span></span><br><span class="line"><span class="keyword">int</span> fillCount = minIdle - (activeCount + poolingCount + createTaskCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fillCount; ++i) &#123;</span><br><span class="line">    emptySignal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>新建连接线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CreateConnectionThread</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 线程在等待唤起</span><br><span class="line">    empty.wait();</span><br><span class="line"></span><br><span class="line">    connection &#x3D; createPhysicalConnection();</span><br><span class="line">    </span><br><span class="line">    放入线程池，put里会执行notEmpty.signal();</span><br><span class="line">    put(physicalConnection);</span><br></pre></td></tr></table></figure>


<h3 id="getConnect"><a href="#getConnect" class="headerlink" title="getConnect"></a>getConnect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取到连接poolcount会减1，</span><br><span class="line">poolableConnection &#x3D; getConnectionInternal(maxWaitMillis);</span><br><span class="line"></span><br><span class="line">if(testOnBorrow) &#123;</span><br><span class="line">    &#x2F;&#x2F; 检测连接是否正常</span><br><span class="line">    testConnectionInternal</span><br><span class="line">&#125; else if(testWhileIdle) &#123;</span><br><span class="line">    if(currentTimeMillis - lastActiveTimeMillis &gt;&#x3D; timeBetweenEvictionRunsMillis) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个连接上次活跃距离现在的时间超过规定的空闲时间</span><br><span class="line">        testConnectionInternal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getConnectionInternal</span><br><span class="line"></span><br><span class="line">    if (maxWait &gt; 0) &#123;</span><br><span class="line">        holder &#x3D; pollLast(nanos);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        holder &#x3D; takeLast();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pollLast</span><br><span class="line"></span><br><span class="line">    if(poolingCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果连接池为空，通知生产者生成连接</span><br><span class="line">        emptySignal();</span><br><span class="line">        &#x2F;&#x2F; 等待生产连接成功</span><br><span class="line">        notEmpty.awaitNanos(estimate);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 从连接池的最后一项获取连接poolingCount--</span><br><span class="line">    decrementPoolingCount();</span><br><span class="line">    DruidConnectionHolder last &#x3D; connections[poolingCount];</span><br><span class="line">    connections[poolingCount] &#x3D; null;</span><br><span class="line"></span><br><span class="line">takeLast</span><br><span class="line"></span><br><span class="line">    if(poolingCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果连接池为空，通知生产者生成连接</span><br><span class="line">        emptySignal();</span><br><span class="line">        &#x2F;&#x2F; 等待生产连接成功</span><br><span class="line">        notEmpty.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; poolingCount--</span><br><span class="line">    decrementPoolingCount();</span><br><span class="line">    DruidConnectionHolder last &#x3D; connections[poolingCount];</span><br><span class="line">    connections[poolingCount] &#x3D; null;</span><br></pre></td></tr></table></figure>


<h3 id="testConnectionInternal获取连接前进行活性检测"><a href="#testConnectionInternal获取连接前进行活性检测" class="headerlink" title="testConnectionInternal获取连接前进行活性检测"></a>testConnectionInternal获取连接前进行活性检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">DruidAbstractDataSource</span><br><span class="line"></span><br><span class="line">    if (validConnectionChecker !&#x3D; null) &#123;</span><br><span class="line">        validConnectionChecker.isValidConnection(conn, validationQuery, validationQueryTimeout)</span><br><span class="line"></span><br><span class="line">        if (valid &amp;&amp; isMySql) &#123; &#x2F;&#x2F; unexcepted branch</span><br><span class="line">            long lastPacketReceivedTimeMs &#x3D; MySqlUtils.getLastPacketReceivedTimeMs(conn);</span><br><span class="line">            if (lastPacketReceivedTimeMs &gt; 0) &#123;</span><br><span class="line">                long mysqlIdleMillis &#x3D; currentTimeMillis - lastPacketReceivedTimeMs;</span><br><span class="line">                if (lastPacketReceivedTimeMs &gt; 0 &#x2F;&#x2F;</span><br><span class="line">                        &amp;&amp; mysqlIdleMillis &gt;&#x3D; timeBetweenEvictionRunsMillis) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 如果连接长时间未使用，则抛弃连接</span><br><span class="line">                    discardConnection(conn);</span><br><span class="line">                    String errorMsg &#x3D; &quot;discard long time none received connection. &quot;</span><br><span class="line">                            + &quot;, jdbcUrl : &quot; + jdbcUrl</span><br><span class="line">                            + &quot;, jdbcUrl : &quot; + jdbcUrl</span><br><span class="line">                            + &quot;, lastPacketReceivedIdleMillis : &quot; + mysqlIdleMillis;</span><br><span class="line">                    LOG.error(errorMsg);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    如果没有设置checker</span><br><span class="line">    Statement stmt &#x3D; null;</span><br><span class="line">    ResultSet rset &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        stmt &#x3D; conn.createStatement();</span><br><span class="line">        if (getValidationQueryTimeout() &gt; 0) &#123;</span><br><span class="line">            stmt.setQueryTimeout(validationQueryTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">        rset &#x3D; stmt.executeQuery(validationQuery);</span><br><span class="line">        if (!rset.next()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        JdbcUtils.close(rset);</span><br><span class="line">        JdbcUtils.close(stmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 抛弃连接，不进行回收，而是抛弃</span><br><span class="line">     * </span><br><span class="line">     * @param realConnection</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void discardConnection(Connection realConnection) &#123;</span><br><span class="line">        JdbcUtils.close(realConnection);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            activeCount--;</span><br><span class="line">            discardCount++;</span><br><span class="line"></span><br><span class="line">            if (activeCount &lt;&#x3D; minIdle) &#123;</span><br><span class="line">                emptySignal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">mysql连接检查器</span><br><span class="line">public class MSSQLValidConnectionChecker extends ValidConnectionCheckerAdapter implements ValidConnectionChecker, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public boolean isValidConnection(final Connection c, String validateQuery, int validationQueryTimeout) throws Exception &#123;</span><br><span class="line">            if (c.isClosed()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Statement stmt &#x3D; null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                stmt &#x3D; c.createStatement();</span><br><span class="line">                if (validationQueryTimeout &gt; 0) &#123;</span><br><span class="line">                    stmt.setQueryTimeout(validationQueryTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                stmt.execute(validateQuery);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                JdbcUtils.close(stmt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="recycle关闭连接池"><a href="#recycle关闭连接池" class="headerlink" title="recycle关闭连接池"></a>recycle关闭连接池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">recycle</span><br><span class="line"></span><br><span class="line">    if (testOnReturn) &#123;</span><br><span class="line">        testConnectionInternal(holder, physicalConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 放回连接池</span><br><span class="line">    putLast(holder, currentTimeMillis);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">putLast</span><br><span class="line">    e.lastActiveTimeMillis &#x3D; lastActiveTimeMillis;</span><br><span class="line">    connections[poolingCount] &#x3D; e;</span><br><span class="line">    incrementPoolingCount();</span><br><span class="line"></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    notEmptySignalCount++;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/druid.png" alt=""></p>
<p>使用ReentrantLock重入锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                                   ConnectionPool</span><br><span class="line">                              |---------------------------| </span><br><span class="line">                              |                           |</span><br><span class="line">       getConnection          |                           |    </span><br><span class="line">      (notEmpty.await)        |                           |   </span><br><span class="line">      (lowWater.signal)       |                           |</span><br><span class="line">      (maxActive.await)       |                           |</span><br><span class="line">  &lt;-------------------------- |                           |</span><br><span class="line">  &lt;-------------------------- |                           |</span><br><span class="line">  &lt;-------------------------- |                           |</span><br><span class="line">                              |                           |</span><br><span class="line">                              |                           |</span><br><span class="line">  --------------------------&gt; |                           |</span><br><span class="line">  --------------------------&gt; |                           |    销毁多余连接的线程</span><br><span class="line">  --------------------------&gt; |                           |    (highWater.awati, idleTimeout.await)</span><br><span class="line">    close                     |                           | --------------------------------------&gt; </span><br><span class="line">    (highWater.signal)        |                           |</span><br><span class="line">    (maxActive.signal)        |                           |  </span><br><span class="line">                              |                           |</span><br><span class="line">                              |                           |</span><br><span class="line">              产生连接的线程     |                           |</span><br><span class="line">     (lowWater.await)         |                           |</span><br><span class="line">     (notEmpty.signal)        |                           |</span><br><span class="line">  --------------------------&gt; |                           |</span><br><span class="line">                              |                           |</span><br><span class="line">                              |---------------------------|</span><br><span class="line">                              </span><br><span class="line">五个Condition：notEmpty、maxActive、lowWater、hightWater, idleTime</span><br></pre></td></tr></table></figure>



<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p>druid配置说明：<a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/21/2019-6-21-druid/" data-id="ck521h17u0072lc7k0uc3gqq2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2019-6-15-zookeeper" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/15/2019-6-15-zookeeper/" class="article-date">
  <time datetime="2019-06-14T16:00:00.000Z" itemprop="datePublished">2019-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/15/2019-6-15-zookeeper/">zookeeper</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>创建唯一顺序id怎么做到的</p>
<p>高性能、高可用、写操作顺序性</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>ls /</p>
<p>create /test 1</p>
<p>set /test 2</p>
<p>get /test</p>
<p>delete</p>
<p>rmr</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ol>
<li>持久节点</li>
</ol>
<p>creste </p>
<ol start="2">
<li>临时节点</li>
</ol>
<p>create -e</p>
<ol start="3">
<li>持久顺序节点</li>
</ol>
<p>create -s</p>
<ol start="4">
<li>临时顺序节点</li>
</ol>
<p>create -s -e</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>存放在内存</p>
<p>树形存储结构</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>leader</p>
<p>follower</p>
<p>learner</p>
<p>ack过半</p>
<p>zab协议</p>
<p>一个节点默认最大数据量是1M</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>同步端口</p>
<p>选举端口</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/zookeeper.png" alt=""></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/zookeeper2.png" alt=""></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>使用nio连接服务器</p>
<p>开启两个线程<br>sendThread</p>
<p>eventThread</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>树形结构，和文件系统的目录结构相似</p>
<p>DataTree</p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>leader 读、写、选举</p>
<p>follower 读、选举</p>
<p>observer 读</p>
<h3 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h3><p>允许用户在指定节点上注册一些watcher</p>
<h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><p>leader为follower服务器各自分配一个单独的队列，然后将需要广播的事务proposal依次放入队列中，并且根据fifo策略进行消息发送。</p>
<p>每个follower服务器在接收到这个事务之后，首先将其以事务日志的形式写入本地磁盘，成功写入之后发反馈给leader服务器一个ack响应。</p>
<p>当leader服务器收到超过半数follower的ack之后，广播一个commit消息给所有follower，同时自身也会完成事务提交。</p>
<p>follower收到commit之后，完成事务提价</p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><h3 id="选举策略"><a href="#选举策略" class="headerlink" title="选举策略"></a>选举策略</h3><p>事务id最大</p>
<h3 id="server工作状态"><a href="#server工作状态" class="headerlink" title="server工作状态"></a>server工作状态</h3><p>LOOKING：当前Server不知道leader是谁，正在搜寻<br>LEADING：当前Server即为选举出来的leader<br>FOLLOWING：leader已经选举出来，当前Server与之同步</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Follower主要有四个功能：</span><br><span class="line">1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</span><br><span class="line">2 .接收Leader消息并进行处理；</span><br><span class="line">3 .接收Client的请求，如果为写请求，发送给Leader进行投票；</span><br><span class="line">4 .返回Client结果。</span><br><span class="line">Follower的消息循环处理如下几种来自Leader的消息：</span><br><span class="line">1 .PING消息： 心跳消息；</span><br><span class="line">2 .PROPOSAL消息：Leader发起的提案，要求Follower投票；</span><br><span class="line">3 .COMMIT消息：服务器端最新一次提案的信息；</span><br><span class="line">4 .UPTODATE消息：表明同步完成；</span><br><span class="line">5 .REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</span><br><span class="line">6 .SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/15/2019-6-15-zookeeper/" data-id="ck521h14y006elc7kca6gehci" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2019-6-6-iptable" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/06/2019-6-6-iptable/" class="article-date">
  <time datetime="2019-06-05T16:00:00.000Z" itemprop="datePublished">2019-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/06/2019-6-6-iptable/">iptables</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><h3 id="iptables-1"><a href="#iptables-1" class="headerlink" title="iptables"></a>iptables</h3><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/iptables.png" alt=""></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/iptables2.png" alt=""></p>
<p>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</p>
<p>nat表：network address translation，网络地址转换功能；内核模块：iptable_nat</p>
<p>mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle</p>
<p>raw表：关闭nat表上启用的连接追踪机制；iptable_raw</p>
<p>PREROUTING    的规则可以存在于：raw表，mangle表，nat表。</p>
<p>INPUT      的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。</p>
<p>FORWARD     的规则可以存在于：mangle表，filter表。</p>
<p>OUTPUT     的规则可以存在于：raw表mangle表，nat表，filter表。</p>
<p>POSTROUTING    的规则可以存在于：mangle表，nat表。</p>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><h4 id="容器对外请求数据"><a href="#容器对外请求数据" class="headerlink" title="容器对外请求数据"></a>容器对外请求数据</h4><p>如果Docker0中的容器请求外部的数据，那么他的数据包将会发送到网关172.17.0.1处。当数据包到达网关后，将会查询主机的路由表，确定数据包将从那个网卡发出。iptables负责对数据包进行snat转换，将原地址转为对应网卡的地址，因此容器对外是不可见的。</p>
<h4 id="外部对容器请求数据"><a href="#外部对容器请求数据" class="headerlink" title="外部对容器请求数据"></a>外部对容器请求数据</h4><p>外部想要访问容器内的数据，首先需要将容器的端口映射到宿主机上。这时候docker会在iptables添加转发规则，把接收到的数据转发给容器。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/iptables3.png" alt=""></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/iptables4.png" alt=""></p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://www.zsythink.net/archives/1199" target="_blank" rel="noopener">https://www.zsythink.net/archives/1199</a></p>
<p>nat<a href="https://blog.csdn.net/jk110333/article/details/8229828" target="_blank" rel="noopener">https://blog.csdn.net/jk110333/article/details/8229828</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/06/2019-6-6-iptable/" data-id="ck521h14w006dlc7k2xw9gd8w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2019-5-29-ssh" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/29/2019-5-29-ssh/" class="article-date">
  <time datetime="2019-05-28T16:00:00.000Z" itemprop="datePublished">2019-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/29/2019-5-29-ssh/">ssh</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="非对称加密概念"><a href="#非对称加密概念" class="headerlink" title="非对称加密概念"></a>非对称加密概念</h3><p>公钥加密，私钥解密</p>
<p>私钥加密=签名，公钥解密=验签</p>
<h3 id="密码登录"><a href="#密码登录" class="headerlink" title="密码登录"></a>密码登录</h3><p>远程主机收到用户的登录请求，把自己的公钥发给用户</p>
<p>用户使用这个公钥，将登录密码加密后，发送回来</p>
<p>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录</p>
<h3 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h3><p>用户将自己的公钥储存在远程主机上</p>
<p>登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来</p>
<p>远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/29/2019-5-29-ssh/" data-id="ck521h14w006clc7khmwlamoh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2019-4-30-kafka" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/30/2019-4-30-kafka/" class="article-date">
  <time datetime="2019-04-29T16:00:00.000Z" itemprop="datePublished">2019-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/30/2019-4-30-kafka/">kafka</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h1><h2 id="网络通信模型"><a href="#网络通信模型" class="headerlink" title="网络通信模型"></a>网络通信模型</h2><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191204220047825.png" alt="image-20191204220047825"></p>
<p>（1）<strong>Acceptor</strong>：1个接收线程，负责监听新的连接请求，同时注册OP_ACCEPT 事件，将新的连接按照<strong>“round robin”</strong>方式交给对应的 Processor 线程处理；<br> （2）<strong>Processor</strong>：N个处理器线程，其中每个 Processor 都有自己的 selector，它会向 Acceptor 分配的 SocketChannel 注册相应的 OP_READ 事件，N 的大小由<strong>“num.networker.threads”</strong>决定；<br> （3）<strong>KafkaRequestHandler</strong>：M个请求处理线程，包含在线程池—KafkaRequestHandlerPool内部，从RequestChannel的全局请求队列—requestQueue中获取请求数据并交给KafkaApis处理，M的大小由<strong>“num.io.threads”</strong>决定；<br> （4）<strong>RequestChannel</strong>：其为Kafka服务端的请求通道，该数据结构中包含了一个全局的请求队列 requestQueue和多个与Processor处理器相对应的响应队列responseQueue，提供给Processor与请求处理线程KafkaRequestHandler和KafkaApis交换数据的地方。<br> （5）<strong>NetworkClient</strong>：其底层是对 Java NIO 进行相应的封装，位于Kafka的网络接口层。Kafka消息生产者对象—KafkaProducer的send方法主要调用NetworkClient完成消息发送；<br> （6）<strong>SocketServer</strong>：其是一个NIO的服务，它同时启动一个Acceptor接收线程和多个Processor处理器线程。提供了一种典型的Reactor多线程模式，将接收客户端请求和处理请求相分离；<br> （7）<strong>KafkaServer</strong>：代表了一个Kafka Broker的实例；其startup方法为实例启动的入口；<br> （8）<strong>KafkaApis</strong>：Kafka的业务逻辑处理Api，负责处理不同类型的请求；比如<strong>“发送消息”</strong>、<strong>“获取消息偏移量—offset”</strong>和<strong>“处理心跳请求”</strong>等；</p>
<h3 id="acceptor"><a href="#acceptor" class="headerlink" title="acceptor"></a>acceptor</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">def run() &#123;</span><br><span class="line">  <span class="comment">// 注册accept事件</span></span><br><span class="line">  serverChannel.register(nioSelector, SelectionKey.OP_ACCEPT)</span><br><span class="line">  startupComplete()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentProcessorIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> ready = nioSelector.select(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">if</span> (ready &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">val</span> keys = nioSelector.selectedKeys()</span><br><span class="line">          <span class="keyword">val</span> iter = keys.iterator()</span><br><span class="line">          <span class="keyword">while</span> (iter.hasNext &amp;&amp; isRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">val</span> key = iter.next</span><br><span class="line">              iter.remove()</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (key.isAcceptable) &#123;</span><br><span class="line">                accept(key).foreach &#123; socketChannel =&gt;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// Assign the channel to the next processor (using round-robin) to which the</span></span><br><span class="line">                  <span class="comment">// channel can be added without blocking. If newConnections queue is full on</span></span><br><span class="line">                  <span class="comment">// all processors, block until the last one is able to accept a connection.</span></span><br><span class="line">                  <span class="keyword">var</span> retriesLeft = synchronized(processors.length)</span><br><span class="line">                  <span class="keyword">var</span> processor: Processor = <span class="literal">null</span></span><br><span class="line">                  <span class="keyword">do</span> &#123;</span><br><span class="line">                    retriesLeft -= <span class="number">1</span></span><br><span class="line">                    processor = synchronized &#123;</span><br><span class="line">                      <span class="comment">// adjust the index (if necessary) and retrieve the processor atomically for</span></span><br><span class="line">                      <span class="comment">// correct behaviour in case the number of processors is reduced dynamically						</span></span><br><span class="line">                      <span class="comment">// round robin算法找到处理线程</span></span><br><span class="line">                      currentProcessorIndex = currentProcessorIndex % processors.length</span><br><span class="line">                      processors(currentProcessorIndex)</span><br><span class="line">                    &#125;</span><br><span class="line">                    currentProcessorIndex += <span class="number">1</span></span><br><span class="line">                    <span class="comment">// 处理连接</span></span><br><span class="line">                  &#125; <span class="keyword">while</span> (!assignNewConnection(socketChannel, processor, retriesLeft == <span class="number">0</span>))</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> new IllegalStateException(<span class="string">"Unrecognized key state for acceptor thread."</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">              case e: Throwable =&gt; error(<span class="string">"Error while accepting connection"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// We catch all the throwables to prevent the acceptor thread from exiting on exceptions due</span></span><br><span class="line">        <span class="comment">// to a select operation on a specific channel or a bad request. We don't want</span></span><br><span class="line">        <span class="comment">// the broker to stop responding to requests from other clients in these scenarios.</span></span><br><span class="line">        case e: ControlThrowable =&gt; <span class="keyword">throw</span> e</span><br><span class="line">        case e: Throwable =&gt; error(<span class="string">"Error occurred"</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    debug(<span class="string">"Closing server socket and selector."</span>)</span><br><span class="line">    CoreUtils.swallow(serverChannel.close(), <span class="keyword">this</span>, Level.ERROR)</span><br><span class="line">    CoreUtils.swallow(nioSelector.close(), <span class="keyword">this</span>, Level.ERROR)</span><br><span class="line">    shutdownComplete()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> def assignNewConnection(socketChannel: SocketChannel, processor: Processor, mayBlock: <span class="built_in">Boolean</span>): <span class="built_in">Boolean</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (processor.accept(socketChannel, mayBlock, blockedPercentMeter)) &#123;</span><br><span class="line">    debug(s<span class="string">"Accepted connection from <span class="subst">$&#123;socketChannel.socket.getRemoteSocketAddress&#125;</span> on"</span> +</span><br><span class="line">      s<span class="string">" <span class="subst">$&#123;socketChannel.socket.getLocalSocketAddress&#125;</span> and assigned it to processor <span class="subst">$&#123;processor.id&#125;</span>,"</span> +</span><br><span class="line">      s<span class="string">" sendBufferSize [actual|requested]: [<span class="subst">$&#123;socketChannel.socket.getSendBufferSize&#125;</span>|<span class="variable">$sendBufferSize</span>]"</span> +</span><br><span class="line">      s<span class="string">" recvBufferSize [actual|requested]: [<span class="subst">$&#123;socketChannel.socket.getReceiveBufferSize&#125;</span>|<span class="variable">$recvBufferSize</span>]"</span>)</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="processor"><a href="#processor" class="headerlink" title="processor"></a>processor</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> newConnections = new ArrayBlockingQueue[SocketChannel](connectionQueueSize)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> inflightResponses = mutable.Map[String, RequestChannel.Response]()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> responseQueue = new LinkedBlockingDeque[RequestChannel.Response]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	def accept(socketChannel: SocketChannel,</span><br><span class="line">             mayBlock: <span class="built_in">Boolean</span>,</span><br><span class="line">             acceptorIdlePercentMeter: com.yammer.metrics.core.Meter): <span class="built_in">Boolean</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> accepted = &#123;</span><br><span class="line">      <span class="comment">// 加入队列newConnection，队列属于ArrayBlockingQueue</span></span><br><span class="line">      <span class="keyword">if</span> (newConnections.offer(socketChannel))</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (mayBlock) &#123;</span><br><span class="line">        <span class="keyword">val</span> startNs = time.nanoseconds</span><br><span class="line">        newConnections.put(socketChannel)</span><br><span class="line">        acceptorIdlePercentMeter.mark(time.nanoseconds() - startNs)</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (accepted)</span><br><span class="line">    <span class="comment">// 马上唤醒selector.pool()，继续从newConnections里拿新连接</span></span><br><span class="line">      wakeup()</span><br><span class="line">    accepted</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">override</span> def run() &#123;</span><br><span class="line">    startupComplete()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// setup any new connections that have been queued up</span></span><br><span class="line">          <span class="comment">//  newConnections.poll()，从队列中拿到连接成功的socket，并注册到nio selector</span></span><br><span class="line">          configureNewConnections()</span><br><span class="line">          <span class="comment">// register any new responses for writing</span></span><br><span class="line">          <span class="comment">// 处理响应队列responseQueue里的响应，注册OP_WRITE到nio selector</span></span><br><span class="line">          processNewResponses()</span><br><span class="line">          <span class="comment">// selector.poll()监听事件</span></span><br><span class="line">          poll()</span><br><span class="line">          <span class="comment">// read事件被触发；selector.completedReceives.asScala.foreach；将请求Request添加至requestChannel的全局请求队列—requestQueue中，等待KafkaRequestHandler来处理</span></span><br><span class="line">          processCompletedReceives()</span><br><span class="line">          <span class="comment">// write事件被触发；selector.completedSends.asScala.foreach，将response发送给客户端，则将其从inflightResponses移除，同时通过调用“selector.unmute”方法为对应的连接通道重新注册OP_READ事件</span></span><br><span class="line">          processCompletedSends()</span><br><span class="line">          <span class="comment">// 断开事件被触发；处理断开连接的队列；selector.disconnected.keySet.asScala.foreach；将该response从inflightResponses集合中移除，同时将connectionQuotas统计计数减1</span></span><br><span class="line">          processDisconnected()</span><br><span class="line">          closeExcessConnections()</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="comment">// We catch all the throwables here to prevent the processor thread from exiting. We do this because</span></span><br><span class="line">          <span class="comment">// letting a processor exit might cause a bigger impact on the broker. This behavior might need to be</span></span><br><span class="line">          <span class="comment">// reviewed if we see an exception that needs the entire broker to stop. Usually the exceptions thrown would</span></span><br><span class="line">          <span class="comment">// be either associated with a specific socket channel or a bad request. These exceptions are caught and</span></span><br><span class="line">          <span class="comment">// processed by the individual methods above which close the failing channel and continue processing other</span></span><br><span class="line">          <span class="comment">// channels. So this catch block should only ever see ControlThrowables.</span></span><br><span class="line">          case e: Throwable =&gt; processException(<span class="string">"Processor got uncaught exception."</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      debug(s<span class="string">"Closing selector - processor <span class="variable">$id</span>"</span>)</span><br><span class="line">      CoreUtils.swallow(closeAll(), <span class="keyword">this</span>, Level.ERROR)</span><br><span class="line">      shutdownComplete()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `protected` for test usage</span></span><br><span class="line">  <span class="keyword">protected</span>[network] def sendResponse(response: RequestChannel.Response, responseSend: Send) &#123;</span><br><span class="line">    <span class="keyword">val</span> connectionId = response.request.context.connectionId</span><br><span class="line">    trace(s<span class="string">"Socket server received response to send to <span class="variable">$connectionId</span>, registering for write and sending data: <span class="variable">$response</span>"</span>)</span><br><span class="line">    <span class="comment">// `channel` can be None if the connection was closed remotely or if selector closed it for being idle for too long</span></span><br><span class="line">    <span class="keyword">if</span> (channel(connectionId).isEmpty) &#123;</span><br><span class="line">      warn(s<span class="string">"Attempting to send response via channel for which there is no open connection, connection id <span class="variable">$connectionId</span>"</span>)</span><br><span class="line">      response.request.updateRequestMetrics(<span class="number">0L</span>, response)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Invoke send for closingChannel as well so that the send is failed and the channel closed properly and</span></span><br><span class="line">    <span class="comment">// removed from the Selector after discarding any pending staged receives.</span></span><br><span class="line">    <span class="comment">// `openOrClosingChannel` can be None if the selector closed the connection because it was idle for too long</span></span><br><span class="line">    <span class="keyword">if</span> (openOrClosingChannel(connectionId).isDefined) &#123;</span><br><span class="line">      <span class="comment">// 通过“selector.send”注册OP_WRITE事件</span></span><br><span class="line">      selector.send(responseSend)</span><br><span class="line">      <span class="comment">// 将该Response从responseQueue响应队列中移至inflightResponses集合中</span></span><br><span class="line">      inflightResponses += (connectionId -&gt; response)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="requestChannel"><a href="#requestChannel" class="headerlink" title="requestChannel"></a>requestChannel</h3><p>RequestChannel为Processor处理器线程与KafkaRequestHandler线程之间的数据交换提供了一个数据缓冲区，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestChannel</span></span>(<span class="keyword">val</span> queueSize: <span class="built_in">Int</span>, <span class="keyword">val</span> metricNamePrefix : String) extends KafkaMetricsGroup &#123;</span><br><span class="line">  <span class="keyword">import</span> RequestChannel._</span><br><span class="line">  <span class="keyword">val</span> metrics = new RequestChannel.Metrics</span><br><span class="line">  <span class="comment">// 请求队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> requestQueue = new ArrayBlockingQueue[BaseRequest](queueSize)</span><br><span class="line">  <span class="comment">// 线程组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> processors = new ConcurrentHashMap[<span class="built_in">Int</span>, Processor]()</span><br><span class="line">  <span class="keyword">val</span> requestQueueSizeMetricName = metricNamePrefix.concat(RequestQueueSizeMetric)</span><br><span class="line">  <span class="keyword">val</span> responseQueueSizeMetricName = metricNamePrefix.concat(ResponseQueueSizeMetric)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KafkaRequestHandler"><a href="#KafkaRequestHandler" class="headerlink" title="KafkaRequestHandler"></a>KafkaRequestHandler</h3><p>KafkaRequestHandler也是一种线程类，在KafkaServer实例启动时候会实例化一个线程池—KafkaRequestHandlerPool对象（包含了若干个KafkaRequestHandler线程），这些线程以守护线程的方式在后台运行。在KafkaRequestHandler的run方法中会循环地从RequestChannel中阻塞式读取request，读取后再交由KafkaApis来具体处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">def run() &#123;</span><br><span class="line">  <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">    <span class="comment">// We use a single meter for aggregate idle percentage for the thread pool.</span></span><br><span class="line">    <span class="comment">// Since meter is calculated as total_recorded_value / time_window and</span></span><br><span class="line">    <span class="comment">// time_window is independent of the number of threads, each recorded idle</span></span><br><span class="line">    <span class="comment">// time should be discounted by # threads.</span></span><br><span class="line">    <span class="keyword">val</span> startSelectTime = time.nanoseconds</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有300毫秒超时时间</span></span><br><span class="line">    <span class="keyword">val</span> req = requestChannel.receiveRequest(<span class="number">300</span>)</span><br><span class="line">    <span class="keyword">val</span> endTime = time.nanoseconds</span><br><span class="line">    <span class="keyword">val</span> idleTime = endTime - startSelectTime</span><br><span class="line">    aggregateIdleMeter.mark(idleTime / totalHandlerThreads.<span class="keyword">get</span>)</span><br><span class="line"></span><br><span class="line">    req match &#123;</span><br><span class="line">      case RequestChannel.ShutdownRequest =&gt;</span><br><span class="line">        debug(s<span class="string">"Kafka request handler <span class="variable">$id</span> on broker <span class="variable">$brokerId</span> received shut down command"</span>)</span><br><span class="line">        shutdownComplete.countDown()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      case request: RequestChannel.Request =&gt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          request.requestDequeueTimeNanos = endTime</span><br><span class="line">          trace(s<span class="string">"Kafka request handler <span class="variable">$id</span> on broker <span class="variable">$brokerId</span> handling request <span class="variable">$request</span>"</span>)</span><br><span class="line">          <span class="comment">// 正常io请求，让apis处理</span></span><br><span class="line">          apis.handle(request)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          case e: FatalExitError =&gt;</span><br><span class="line">            shutdownComplete.countDown()</span><br><span class="line">            Exit.exit(e.statusCode)</span><br><span class="line">          case e: Throwable =&gt; error(<span class="string">"Exception when handling request"</span>, e)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          request.releaseBuffer()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      case <span class="literal">null</span> =&gt; <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  shutdownComplete.countDown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaRequestHandlerPool</span></span>(<span class="keyword">val</span> brokerId: <span class="built_in">Int</span>,</span><br><span class="line">                              <span class="keyword">val</span> requestChannel: RequestChannel,</span><br><span class="line">                              <span class="keyword">val</span> apis: KafkaApis,</span><br><span class="line">                              time: Time,</span><br><span class="line">                              numThreads: <span class="built_in">Int</span>,</span><br><span class="line">                              requestHandlerAvgIdleMetricName: String,</span><br><span class="line">                              logAndThreadNamePrefix : String) extends Logging with KafkaMetricsGroup &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> threadPoolSize: AtomicInteger = new AtomicInteger(numThreads)</span><br><span class="line">  <span class="comment">/* a meter to track the average free capacity of the request handlers */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> aggregateIdleMeter = newMeter(requestHandlerAvgIdleMetricName, <span class="string">"percent"</span>, TimeUnit.NANOSECONDS)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.logIdent = <span class="string">"["</span> + logAndThreadNamePrefix + <span class="string">" Kafka Request Handler on Broker "</span> + brokerId + <span class="string">"], "</span></span><br><span class="line">  <span class="keyword">val</span> runnables = new mutable.ArrayBuffer[KafkaRequestHandler](numThreads)</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numThreads) &#123;</span><br><span class="line">    <span class="comment">// 创建KafkaRequestHandler线程</span></span><br><span class="line">    createHandler(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def createHandler(id: <span class="built_in">Int</span>): <span class="built_in">Unit</span> = synchronized &#123;</span><br><span class="line">    runnables += new KafkaRequestHandler(id, brokerId, aggregateIdleMeter, threadPoolSize, requestChannel, apis, time)</span><br><span class="line">    KafkaThread.daemon(logAndThreadNamePrefix + <span class="string">"-kafka-request-handler-"</span> + id, runnables(id)).start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KafkaApis"><a href="#KafkaApis" class="headerlink" title="KafkaApis"></a>KafkaApis</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">def handle(request: RequestChannel.Request) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    trace(s<span class="string">"Handling request:<span class="subst">$&#123;request.requestDesc(true)&#125;</span> from connection <span class="subst">$&#123;request.context.connectionId&#125;</span>;"</span> +</span><br><span class="line">      s<span class="string">"securityProtocol:<span class="subst">$&#123;request.context.securityProtocol&#125;</span>,principal:<span class="subst">$&#123;request.context.principal&#125;</span>"</span>)</span><br><span class="line">    request.header.apiKey match &#123;</span><br><span class="line">      case ApiKeys.PRODUCE =&gt; handleProduceRequest(request)</span><br><span class="line">      case ApiKeys.FETCH =&gt; handleFetchRequest(request)</span><br><span class="line">      case ApiKeys.LIST_OFFSETS =&gt; handleListOffsetRequest(request)</span><br><span class="line">      case ApiKeys.METADATA =&gt; handleTopicMetadataRequest(request)</span><br><span class="line">      case ApiKeys.LEADER_AND_ISR =&gt; handleLeaderAndIsrRequest(request)</span><br><span class="line">      case ApiKeys.STOP_REPLICA =&gt; handleStopReplicaRequest(request)</span><br><span class="line">      case ApiKeys.UPDATE_METADATA =&gt; handleUpdateMetadataRequest(request)</span><br><span class="line">      case ApiKeys.CONTROLLED_SHUTDOWN =&gt; handleControlledShutdownRequest(request)</span><br><span class="line">      case ApiKeys.OFFSET_COMMIT =&gt; handleOffsetCommitRequest(request)</span><br><span class="line">      case ApiKeys.OFFSET_FETCH =&gt; handleOffsetFetchRequest(request)</span><br><span class="line">      case ApiKeys.FIND_COORDINATOR =&gt; handleFindCoordinatorRequest(request)</span><br><span class="line">      case ApiKeys.JOIN_GROUP =&gt; handleJoinGroupRequest(request)</span><br><span class="line">      case ApiKeys.HEARTBEAT =&gt; handleHeartbeatRequest(request)</span><br><span class="line">      case ApiKeys.LEAVE_GROUP =&gt; handleLeaveGroupRequest(request)</span><br><span class="line">      case ApiKeys.SYNC_GROUP =&gt; handleSyncGroupRequest(request)</span><br><span class="line">      case ApiKeys.DESCRIBE_GROUPS =&gt; handleDescribeGroupRequest(request)</span><br><span class="line">      case ApiKeys.LIST_GROUPS =&gt; handleListGroupsRequest(request)</span><br><span class="line">      case ApiKeys.SASL_HANDSHAKE =&gt; handleSaslHandshakeRequest(request)</span><br><span class="line">      case ApiKeys.API_VERSIONS =&gt; handleApiVersionsRequest(request)</span><br><span class="line">      case ApiKeys.CREATE_TOPICS =&gt; handleCreateTopicsRequest(request)</span><br><span class="line">      case ApiKeys.DELETE_TOPICS =&gt; handleDeleteTopicsRequest(request)</span><br><span class="line">      case ApiKeys.DELETE_RECORDS =&gt; handleDeleteRecordsRequest(request)</span><br><span class="line">      case ApiKeys.INIT_PRODUCER_ID =&gt; handleInitProducerIdRequest(request)</span><br><span class="line">      case ApiKeys.OFFSET_FOR_LEADER_EPOCH =&gt; handleOffsetForLeaderEpochRequest(request)</span><br><span class="line">      case ApiKeys.ADD_PARTITIONS_TO_TXN =&gt; handleAddPartitionToTxnRequest(request)</span><br><span class="line">      case ApiKeys.ADD_OFFSETS_TO_TXN =&gt; handleAddOffsetsToTxnRequest(request)</span><br><span class="line">      case ApiKeys.END_TXN =&gt; handleEndTxnRequest(request)</span><br><span class="line">      case ApiKeys.WRITE_TXN_MARKERS =&gt; handleWriteTxnMarkersRequest(request)</span><br><span class="line">      case ApiKeys.TXN_OFFSET_COMMIT =&gt; handleTxnOffsetCommitRequest(request)</span><br><span class="line">      case ApiKeys.DESCRIBE_ACLS =&gt; handleDescribeAcls(request)</span><br><span class="line">      case ApiKeys.CREATE_ACLS =&gt; handleCreateAcls(request)</span><br><span class="line">      case ApiKeys.DELETE_ACLS =&gt; handleDeleteAcls(request)</span><br><span class="line">      case ApiKeys.ALTER_CONFIGS =&gt; handleAlterConfigsRequest(request)</span><br><span class="line">      case ApiKeys.DESCRIBE_CONFIGS =&gt; handleDescribeConfigsRequest(request)</span><br><span class="line">      case ApiKeys.ALTER_REPLICA_LOG_DIRS =&gt; handleAlterReplicaLogDirsRequest(request)</span><br><span class="line">      case ApiKeys.DESCRIBE_LOG_DIRS =&gt; handleDescribeLogDirsRequest(request)</span><br><span class="line">      case ApiKeys.SASL_AUTHENTICATE =&gt; handleSaslAuthenticateRequest(request)</span><br><span class="line">      case ApiKeys.CREATE_PARTITIONS =&gt; handleCreatePartitionsRequest(request)</span><br><span class="line">      case ApiKeys.CREATE_DELEGATION_TOKEN =&gt; handleCreateTokenRequest(request)</span><br><span class="line">      case ApiKeys.RENEW_DELEGATION_TOKEN =&gt; handleRenewTokenRequest(request)</span><br><span class="line">      case ApiKeys.EXPIRE_DELEGATION_TOKEN =&gt; handleExpireTokenRequest(request)</span><br><span class="line">      case ApiKeys.DESCRIBE_DELEGATION_TOKEN =&gt; handleDescribeTokensRequest(request)</span><br><span class="line">      case ApiKeys.DELETE_GROUPS =&gt; handleDeleteGroupsRequest(request)</span><br><span class="line">      case ApiKeys.ELECT_PREFERRED_LEADERS =&gt; handleElectPreferredReplicaLeader(request)</span><br><span class="line">      case ApiKeys.INCREMENTAL_ALTER_CONFIGS =&gt; handleIncrementalAlterConfigsRequest(request)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    case e: FatalExitError =&gt; <span class="keyword">throw</span> e</span><br><span class="line">    case e: Throwable =&gt; handleError(request, e)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    request.apiLocalCompleteTimeNanos = time.nanoseconds</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191108092730192.png" alt="image-20191108092730192"></p>
<p>一个主题多个分区</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191211105451796.png" alt="image-20191211105451796"></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191211105517601.png" alt="image-20191211105517601"></p>
<h3 id="增加主题"><a href="#增加主题" class="headerlink" title="增加主题"></a>增加主题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure>

<p>指定副本数和分区数，新增主题涉及的操作有分区、副本状态的转化、分区leader的分配、分区存储日志的创建</p>
<h2 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h2><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191108151921837.png" alt="image-20191108151921837"></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191108152125545.png" alt="image-20191108152125545"></p>
<ol>
<li><p>每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本。</p>
</li>
<li><p><strong>追随者副本是不对外提供服务</strong>的，它唯一的任务就是从领导者副本异步拉取消息，并写入到自己的提交日志中，从而实现与领导者副本的同步。</p>
</li>
<li><p><strong>当领导者副本挂掉了，或者说领导者副本所在的 Broker 宕机时，Kafka 依托于 ZooKeeper 提供的监控功能能够实时感知到</strong>，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。老 Leader 副本重启回来后，只能作为追随者副本加入到集群中。</p>
</li>
</ol>
<h3 id="In-sync-Replicas（ISR）"><a href="#In-sync-Replicas（ISR）" class="headerlink" title="In-sync Replicas（ISR）"></a>In-sync Replicas（ISR）</h3><p>所有与leader同步的副本，包括leader</p>
<p><strong>如何算同步：</strong></p>
<p>Broker 端参数 replica.lag.time.max.ms 参数值。这个参数的含义是 Follower 副本能够落后 Leader 副本的最长时间间隔，当前默认值是 10 秒。这就是说，<strong>只要一个 Follower 副本落后 Leader 副本的时间不连续超过 10 秒，那么 Kafka 就认为该 Follower 副本与 Leader 是同步的</strong>，即使此时 Follower 副本中保存的消息明显少于 Leader 副本中的消息。</p>
<h3 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h3><p>Kafka 把所有不在 ISR 中的存活副本都称为非同步副本。通常来说，非同步副本落后 Leader 太多，因此，如果选择这些副本作为新 Leader，就可能出现数据的丢失。毕竟，这些副本中保存的消息远远落后于老 Leader 中的消息。在 Kafka 中，选举这种副本的过程称为 Unclean 领导者选举。Broker 端参数 unclean.leader.election.enable 控制是否允许 Unclean 领导者选举。</p>
<p>默认不开启该设置</p>
<p>如何选举</p>
<p>kafka通过轮询算法保证副本是均匀分布在多个broker上</p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>在创建 KafkaProducer 实例时，生产者应用会在后台创建并启动一个名为 Sender 的线程，该 Sender 线程开始运行时首先会创建与 Broker 的连接，<strong>连接 bootstrap.servers 参数指定的所有 Broker</strong></p>
<p>Producer 每 5 分钟都会强制刷新一次元数据以保证它是最及时的数据</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191107221809350.png" alt="image-20191107221809350"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sender任务从RecordAccumulator取消息</span><br><span class="line">this.ioThread &#x3D; new KafkaThread(ioThreadName, this.sender, true);</span><br><span class="line">this.ioThread.start();</span><br></pre></td></tr></table></figure>



<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191107223940194.png" alt="image-20191107223940194"></p>
<h3 id="无丢失消息"><a href="#无丢失消息" class="headerlink" title="无丢失消息"></a>无丢失消息</h3><ol>
<li>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。</li>
<li>设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li>
<li>设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</li>
<li>设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</li>
<li>设置 replication.factor &gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</li>
<li>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li>
<li>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</li>
<li>确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</li>
</ol>
<h3 id="消息重发"><a href="#消息重发" class="headerlink" title="消息重发"></a>消息重发</h3><p>最多一次（at most once）：消息可能会丢失，但绝不会被重复发送。</p>
<p>至少一次（at least once）：消息不会丢失，但有可能被重复发送。</p>
<p>精确一次（exactly once）：消息不会丢失，也不会被重复发送。</p>
<p>倘若消息成功“提交”，但 Broker 的应答没有成功发送回 Producer 端（比如网络出现瞬时抖动），那么 Producer 就无法确定消息是否真的提交成功了。因此，它只能选择重试，也就是再次发送相同的消息。这就是 Kafka 默认提供至少一次可靠性保障的原因，不过这会导致消息重复发送</p>
<h4 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h4><p>去重重发消息设置。</p>
<p>指定 Producer 幂等性的方法很简单，仅需要设置一个参数即可，即 props.put(“enable.idempotence”, ture)，或 props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG， true)。enable.idempotence 被设置成 true 后，Producer 自动升级成幂等性 Producer，其他所有的代码逻辑都不需要改变。<strong>Kafka 自动帮你做消息的重复去重</strong>。</p>
<ol>
<li>它只能保证单分区上的幂等性，即一个幂等性 Producer 能够保证某个主题的一个分区上不出现重复消息，它无法实现多个分区的幂等性</li>
<li>它只能实现单会话上的幂等性，不能实现跨会话的幂等性。这里的会话，你可以理解为 Producer 进程的一次运行。当你重启了 Producer 进程之后，这种幂等性保证就丧失了</li>
</ol>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ol>
<li>和幂等性 Producer 一样，开启 enable.idempotence = true。</li>
<li>设置 Producer 端参数 transactional. id。最好为其设置一个有意义的名字。<ol>
<li>read_uncommitted：这是默认值，表明 Consumer 能够读取到 Kafka 写入的任何消息，不论事务型 Producer 提交事务还是终止事务，其写入的消息都可以读取。很显然，如果你用了事务型 Producer，那么对应的 Consumer 就不要使用这个值。</li>
<li>read_committed：表明 Consumer 只会读取事务型 Producer 成功提交事务写入的消息。当然了，它也能看到非事务型 Producer 写入的所有消息。</li>
</ol>
</li>
</ol>
<p>事务型 Producer 也不惧进程的重启。Producer 重启回来后，Kafka 依然保证它们发送消息的精确一次处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">producer.initTransactions();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            producer.beginTransaction();</span><br><span class="line">            producer.send(record1);</span><br><span class="line">            producer.send(record2);</span><br><span class="line">            producer.commitTransaction();</span><br><span class="line">&#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">            producer.abortTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事务能够保证跨分区、跨会话间的幂等性</p>
<h3 id="客户端生产者"><a href="#客户端生产者" class="headerlink" title="客户端生产者"></a>客户端生产者</h3><p>多线程单队列</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191212095641531.png" alt="image-20191212095641531"></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191212135157447.png" alt="image-20191212135157447"></p>
<p>KafkaProducer实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">KafkaProducer(Map&lt;String, Object&gt; configs,</span><br><span class="line">              Serializer&lt;K&gt; keySerializer,</span><br><span class="line">              Serializer&lt;V&gt; valueSerializer,</span><br><span class="line">              ProducerMetadata metadata,</span><br><span class="line">              KafkaClient kafkaClient,</span><br><span class="line">              ProducerInterceptors interceptors,</span><br><span class="line">              Time time) &#123;</span><br><span class="line">    ProducerConfig config = <span class="keyword">new</span> ProducerConfig(ProducerConfig.addSerializerToConfig(configs, keySerializer,</span><br><span class="line">            valueSerializer));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; userProvidedConfigs = config.originals();</span><br><span class="line">        <span class="keyword">this</span>.producerConfig = config;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">        String clientId = config.getString(ProducerConfig.CLIENT_ID_CONFIG);</span><br><span class="line">        <span class="keyword">if</span> (clientId.length() &lt;= <span class="number">0</span>)</span><br><span class="line">            clientId = <span class="string">"producer-"</span> + PRODUCER_CLIENT_ID_SEQUENCE.getAndIncrement();</span><br><span class="line">        <span class="keyword">this</span>.clientId = clientId;</span><br><span class="line"></span><br><span class="line">        String transactionalId = userProvidedConfigs.containsKey(ProducerConfig.TRANSACTIONAL_ID_CONFIG) ?</span><br><span class="line">                (String) userProvidedConfigs.get(ProducerConfig.TRANSACTIONAL_ID_CONFIG) : <span class="keyword">null</span>;</span><br><span class="line">        LogContext logContext;</span><br><span class="line">        <span class="keyword">if</span> (transactionalId == <span class="keyword">null</span>)</span><br><span class="line">            logContext = <span class="keyword">new</span> LogContext(String.format(<span class="string">"[Producer clientId=%s] "</span>, clientId));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            logContext = <span class="keyword">new</span> LogContext(String.format(<span class="string">"[Producer clientId=%s, transactionalId=%s] "</span>, clientId, transactionalId));</span><br><span class="line">        log = logContext.logger(KafkaProducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        log.trace(<span class="string">"Starting the Kafka producer"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; metricTags = Collections.singletonMap(<span class="string">"client-id"</span>, clientId);</span><br><span class="line">        MetricConfig metricConfig = <span class="keyword">new</span> MetricConfig().samples(config.getInt(ProducerConfig.METRICS_NUM_SAMPLES_CONFIG))</span><br><span class="line">                .timeWindow(config.getLong(ProducerConfig.METRICS_SAMPLE_WINDOW_MS_CONFIG), TimeUnit.MILLISECONDS)</span><br><span class="line">                .recordLevel(Sensor.RecordingLevel.forName(config.getString(ProducerConfig.METRICS_RECORDING_LEVEL_CONFIG)))</span><br><span class="line">                .tags(metricTags);</span><br><span class="line">        List&lt;MetricsReporter&gt; reporters = config.getConfiguredInstances(ProducerConfig.METRIC_REPORTER_CLASSES_CONFIG,</span><br><span class="line">                MetricsReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">Collections</span>.<span class="title">singletonMap</span>(<span class="title">ProducerConfig</span>.<span class="title">CLIENT_ID_CONFIG</span>, <span class="title">clientId</span>))</span>;</span><br><span class="line">        reporters.add(<span class="keyword">new</span> JmxReporter(JMX_PREFIX));</span><br><span class="line">        <span class="keyword">this</span>.metrics = <span class="keyword">new</span> Metrics(metricConfig, reporters, time);</span><br><span class="line">        <span class="keyword">this</span>.partitioner = config.getConfiguredInstance(ProducerConfig.PARTITIONER_CLASS_CONFIG, Partitioner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">long</span> retryBackoffMs = config.getLong(ProducerConfig.RETRY_BACKOFF_MS_CONFIG);</span><br><span class="line">        <span class="keyword">if</span> (keySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.keySerializer = config.getConfiguredInstance(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                                                                                     Serializer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">this</span>.keySerializer.configure(config.originals(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            config.ignore(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG);</span><br><span class="line">            <span class="keyword">this</span>.keySerializer = keySerializer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.valueSerializer = config.getConfiguredInstance(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                                                                                       Serializer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">this</span>.valueSerializer.configure(config.originals(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            config.ignore(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG);</span><br><span class="line">            <span class="keyword">this</span>.valueSerializer = valueSerializer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load interceptors and make sure they get clientId</span></span><br><span class="line">        userProvidedConfigs.put(ProducerConfig.CLIENT_ID_CONFIG, clientId);</span><br><span class="line">        ProducerConfig configWithClientId = <span class="keyword">new</span> ProducerConfig(userProvidedConfigs, <span class="keyword">false</span>);</span><br><span class="line">        List&lt;ProducerInterceptor&lt;K, V&gt;&gt; interceptorList = (List) configWithClientId.getConfiguredInstances(</span><br><span class="line">                ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, ProducerInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (interceptors != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.interceptors = interceptors;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.interceptors = <span class="keyword">new</span> ProducerInterceptors&lt;&gt;(interceptorList);</span><br><span class="line">        ClusterResourceListeners clusterResourceListeners = configureClusterResourceListeners(keySerializer,</span><br><span class="line">                valueSerializer, interceptorList, reporters);</span><br><span class="line">        <span class="keyword">this</span>.maxRequestSize = config.getInt(ProducerConfig.MAX_REQUEST_SIZE_CONFIG);</span><br><span class="line">        <span class="keyword">this</span>.totalMemorySize = config.getLong(ProducerConfig.BUFFER_MEMORY_CONFIG);</span><br><span class="line">        <span class="keyword">this</span>.compressionType = CompressionType.forName(config.getString(ProducerConfig.COMPRESSION_TYPE_CONFIG));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.maxBlockTimeMs = config.getLong(ProducerConfig.MAX_BLOCK_MS_CONFIG);</span><br><span class="line">        <span class="keyword">this</span>.transactionManager = configureTransactionState(config, logContext, log);</span><br><span class="line">        <span class="keyword">int</span> deliveryTimeoutMs = configureDeliveryTimeout(config, log);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.apiVersions = <span class="keyword">new</span> ApiVersions();</span><br><span class="line">        <span class="keyword">this</span>.accumulator = <span class="keyword">new</span> RecordAccumulator(logContext,</span><br><span class="line">                config.getInt(ProducerConfig.BATCH_SIZE_CONFIG),</span><br><span class="line">                <span class="keyword">this</span>.compressionType,</span><br><span class="line">                lingerMs(config),</span><br><span class="line">                retryBackoffMs,</span><br><span class="line">                deliveryTimeoutMs,</span><br><span class="line">                metrics,</span><br><span class="line">                PRODUCER_METRIC_GROUP_NAME,</span><br><span class="line">                time,</span><br><span class="line">                apiVersions,</span><br><span class="line">                transactionManager,</span><br><span class="line">                <span class="keyword">new</span> BufferPool(<span class="keyword">this</span>.totalMemorySize, config.getInt(ProducerConfig.BATCH_SIZE_CONFIG), metrics, time, PRODUCER_METRIC_GROUP_NAME));</span><br><span class="line">        List&lt;InetSocketAddress&gt; addresses = ClientUtils.parseAndValidateAddresses(</span><br><span class="line">                config.getList(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG),</span><br><span class="line">                config.getString(ProducerConfig.CLIENT_DNS_LOOKUP_CONFIG));</span><br><span class="line">        <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.metadata = metadata;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.metadata = <span class="keyword">new</span> ProducerMetadata(retryBackoffMs,</span><br><span class="line">                    config.getLong(ProducerConfig.METADATA_MAX_AGE_CONFIG),</span><br><span class="line">                    logContext,</span><br><span class="line">                    clusterResourceListeners,</span><br><span class="line">                    Time.SYSTEM);</span><br><span class="line">          	<span class="comment">// 初始化了bootstrap地址</span></span><br><span class="line">            <span class="keyword">this</span>.metadata.bootstrap(addresses, time.milliseconds());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.errors = <span class="keyword">this</span>.metrics.sensor(<span class="string">"errors"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sender = newSender(logContext, kafkaClient, <span class="keyword">this</span>.metadata);</span><br><span class="line">        String ioThreadName = NETWORK_THREAD_PREFIX + <span class="string">" | "</span> + clientId;</span><br><span class="line">        <span class="keyword">this</span>.ioThread = <span class="keyword">new</span> KafkaThread(ioThreadName, <span class="keyword">this</span>.sender, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.ioThread.start();</span><br><span class="line">        config.logUnused();</span><br><span class="line">        AppInfoParser.registerAppInfo(JMX_PREFIX, clientId, metrics, time.milliseconds());</span><br><span class="line">        log.debug(<span class="string">"Kafka producer started"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// call close methods if internal objects are already constructed this is to prevent resource leak. see KAFKA-2121</span></span><br><span class="line">        close(Duration.ofMillis(<span class="number">0</span>), <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// now propagate the exception</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Failed to construct kafka producer"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>org.apache.kafka.clients.producer.KafkaProducer#doSend</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;RecordMetadata&gt; <span class="title">doSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">     TopicPartition tp = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         throwIfProducerClosed();</span><br><span class="line">         <span class="comment">// first make sure the metadata for the topic is available</span></span><br><span class="line">         ClusterAndWaitTime clusterAndWaitTime;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           	<span class="comment">// 获取topic的meta信息，如果没有，则需要发送获取meta请求</span></span><br><span class="line">             clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">             <span class="keyword">if</span> (metadata.isClosed())</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>, e);</span><br><span class="line">             <span class="keyword">throw</span> e;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br><span class="line">         Cluster cluster = clusterAndWaitTime.cluster;</span><br><span class="line">         <span class="keyword">byte</span>[] serializedKey;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Can't convert key of class "</span> + record.key().getClass().getName() +</span><br><span class="line">                     <span class="string">" to class "</span> + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                     <span class="string">" specified in key.serializer"</span>, cce);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">byte</span>[] serializedValue;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Can't convert value of class "</span> + record.value().getClass().getName() +</span><br><span class="line">                     <span class="string">" to class "</span> + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                     <span class="string">" specified in value.serializer"</span>, cce);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">         tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br><span class="line"></span><br><span class="line">         setReadOnly(record.headers());</span><br><span class="line">         Header[] headers = record.headers().toArray();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),</span><br><span class="line">                 compressionType, serializedKey, serializedValue, headers);</span><br><span class="line">         ensureValidRecordSize(serializedSize);</span><br><span class="line">         <span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? time.milliseconds() : record.timestamp();</span><br><span class="line">         log.trace(<span class="string">"Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;"</span>, record, callback, record.topic(), partition);</span><br><span class="line">         <span class="comment">// producer callback will make sure to call both 'callback' and interceptor callback</span></span><br><span class="line">         Callback interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; transactionManager.isTransactional())</span><br><span class="line">             transactionManager.maybeAddPartitionToTransaction(tp);</span><br><span class="line"></span><br><span class="line">       	<span class="comment">// 将请求放入RecordAccumulator，队列的封装</span></span><br><span class="line">         RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey,</span><br><span class="line">                 serializedValue, headers, interceptCallback, remainingWaitMs);</span><br><span class="line">         <span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">             log.trace(<span class="string">"Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch"</span>, record.topic(), partition);</span><br><span class="line">             <span class="keyword">this</span>.sender.wakeup();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result.future;</span><br><span class="line">         <span class="comment">// handling exceptions and record the errors;</span></span><br><span class="line">         <span class="comment">// for API exceptions return them in the future,</span></span><br><span class="line">         <span class="comment">// for other exceptions throw directly</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (ApiException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RecordAppendResult <span class="title">append</span><span class="params">(TopicPartition tp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Header[] headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Callback callback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">long</span> maxTimeToBlock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// We keep track of the number of appending thread to make sure we do not miss batches in</span></span><br><span class="line">    <span class="comment">// abortIncompleteBatches().</span></span><br><span class="line">    appendsInProgress.incrementAndGet();</span><br><span class="line">    ByteBuffer buffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (headers == <span class="keyword">null</span>) headers = Record.EMPTY_HEADERS;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check if we have an in-progress batch</span></span><br><span class="line">      	<span class="comment">// 找到分区对应的消息队列</span></span><br><span class="line">        Deque&lt;ProducerBatch&gt; dq = getOrCreateDeque(tp);</span><br><span class="line">        <span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>);</span><br><span class="line">            RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">            <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> appendResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we don't have an in-progress record batch try to allocate a new batch</span></span><br><span class="line">        <span class="keyword">byte</span> maxUsableMagic = apiVersions.maxUsableProduceMagic();</span><br><span class="line">        <span class="keyword">int</span> size = Math.max(<span class="keyword">this</span>.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(maxUsableMagic, compression, key, value, headers));</span><br><span class="line">        log.trace(<span class="string">"Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;"</span>, size, tp.topic(), tp.partition());</span><br><span class="line">        buffer = free.allocate(size, maxTimeToBlock);</span><br><span class="line">        <span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">            <span class="comment">// Need to check if producer is closed again after grabbing the dequeue lock.</span></span><br><span class="line">            <span class="keyword">if</span> (closed)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Producer closed while send in progress"</span>);</span><br><span class="line"></span><br><span class="line">            RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">            <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Somebody else found us a batch, return the one we waited for! Hopefully this doesn't happen often...</span></span><br><span class="line">                <span class="keyword">return</span> appendResult;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MemoryRecordsBuilder recordsBuilder = recordsBuilder(buffer, maxUsableMagic);</span><br><span class="line">            ProducerBatch batch = <span class="keyword">new</span> ProducerBatch(tp, recordsBuilder, time.milliseconds());</span><br><span class="line">            FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, headers, callback, time.milliseconds()));</span><br><span class="line"></span><br><span class="line">            dq.addLast(batch);</span><br><span class="line">            incomplete.add(batch);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't deallocate this buffer in the finally block as it's being used in the record batch</span></span><br><span class="line">            buffer = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RecordAppendResult(future, dq.size() &gt; <span class="number">1</span> || batch.isFull(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer != <span class="keyword">null</span>)</span><br><span class="line">            free.deallocate(buffer);</span><br><span class="line">        appendsInProgress.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordAccumulator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger flushesInProgress;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger appendsInProgress;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> batchSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompressionType compression;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> lingerMs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> retryBackoffMs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> deliveryTimeoutMs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BufferPool free;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Time time;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApiVersions apiVersions;</span><br><span class="line">  	<span class="comment">// 一个分区一个消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; batches;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IncompleteBatches incomplete;</span><br><span class="line">    <span class="comment">// The following variables are only accessed by the sender thread, so we don't need to protect them.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;TopicPartition, Long&gt; muted;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> drainIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionManager transactionManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextBatchExpiryTimeMs = Long.MAX_VALUE; <span class="comment">// the earliest time (absolute) a batch will expire.</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ClusterAndWaitTime <span class="title">waitOnMetadata</span><span class="params">(String topic, Integer partition, <span class="keyword">long</span> maxWaitMs)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// add topic to metadata topic list if it is not there already and reset expiry</span></span><br><span class="line">    Cluster cluster = metadata.fetch();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cluster.invalidTopics().contains(topic))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTopicException(topic);</span><br><span class="line"></span><br><span class="line">    metadata.add(topic);</span><br><span class="line"></span><br><span class="line">    Integer partitionsCount = cluster.partitionCountForTopic(topic);</span><br><span class="line">    <span class="comment">// Return cached metadata if we have it, and if the record's partition is either undefined</span></span><br><span class="line">    <span class="comment">// or within the known partition range</span></span><br><span class="line">    <span class="keyword">if</span> (partitionsCount != <span class="keyword">null</span> &amp;&amp; (partition == <span class="keyword">null</span> || partition &lt; partitionsCount))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClusterAndWaitTime(cluster, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = time.milliseconds();</span><br><span class="line">    <span class="keyword">long</span> remainingWaitMs = maxWaitMs;</span><br><span class="line">    <span class="keyword">long</span> elapsed;</span><br><span class="line">    <span class="comment">// Issue metadata requests until we have metadata for the topic and the requested partition,</span></span><br><span class="line">    <span class="comment">// or until maxWaitTimeMs is exceeded. This is necessary in case the metadata</span></span><br><span class="line">    <span class="comment">// is stale and the number of partitions for this topic has increased in the meantime.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (partition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.trace(<span class="string">"Requesting metadata update for partition &#123;&#125; of topic &#123;&#125;."</span>, partition, topic);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.trace(<span class="string">"Requesting metadata update for topic &#123;&#125;."</span>, topic);</span><br><span class="line">        &#125;</span><br><span class="line">        metadata.add(topic);</span><br><span class="line">      	<span class="comment">// 设置更新标记</span></span><br><span class="line">        <span class="keyword">int</span> version = metadata.requestUpdate();</span><br><span class="line">      	<span class="comment">// 唤醒sender线程</span></span><br><span class="line">        sender.wakeup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        		<span class="comment">// 等待meta更新完成  	</span></span><br><span class="line">            metadata.awaitUpdate(version, remainingWaitMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException ex) &#123;</span><br><span class="line">            <span class="comment">// Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(</span><br><span class="line">                    String.format(<span class="string">"Topic %s not present in metadata after %d ms."</span>,</span><br><span class="line">                            topic, maxWaitMs));</span><br><span class="line">        &#125;</span><br><span class="line">        cluster = metadata.fetch();</span><br><span class="line">        elapsed = time.milliseconds() - begin;</span><br><span class="line">        <span class="keyword">if</span> (elapsed &gt;= maxWaitMs) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(partitionsCount == <span class="keyword">null</span> ?</span><br><span class="line">                    String.format(<span class="string">"Topic %s not present in metadata after %d ms."</span>,</span><br><span class="line">                            topic, maxWaitMs) :</span><br><span class="line">                    String.format(<span class="string">"Partition %d of topic %s with partition count %d is not present in metadata after %d ms."</span>,</span><br><span class="line">                            partition, topic, partitionsCount, maxWaitMs));</span><br><span class="line">        &#125;</span><br><span class="line">        metadata.maybeThrowException();</span><br><span class="line">        remainingWaitMs = maxWaitMs - elapsed;</span><br><span class="line">        partitionsCount = cluster.partitionCountForTopic(topic);</span><br><span class="line">      	<span class="comment">// do while，死循环直到获取到partitions</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (partitionsCount == <span class="keyword">null</span> || (partition != <span class="keyword">null</span> &amp;&amp; partition &gt;= partitionsCount));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClusterAndWaitTime(cluster, elapsed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">awaitUpdate</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> lastVersion, <span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> currentTimeMs = time.milliseconds();</span><br><span class="line">       <span class="keyword">long</span> deadlineMs = currentTimeMs + timeoutMs &lt; <span class="number">0</span> ? Long.MAX_VALUE : currentTimeMs + timeoutMs;</span><br><span class="line">       time.waitObject(<span class="keyword">this</span>, () -&gt; &#123;</span><br><span class="line">           maybeThrowException();</span><br><span class="line">           <span class="keyword">return</span> updateVersion() &gt; lastVersion || isClosed();</span><br><span class="line">       &#125;, deadlineMs);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (isClosed())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">"Requested metadata update after close"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="sender线程"><a href="#sender线程" class="headerlink" title="sender线程"></a>sender线程</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.kafka.clients.producer.internals.Sender#run</span><br><span class="line">org.apache.kafka.clients.producer.internals.Sender#runOnce</span><br><span class="line">org.apache.kafka.clients.NetworkClient#poll</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (transactionManager.shouldResetProducerStateAfterResolvingSequences())</span><br><span class="line">                <span class="comment">// Check if the previous run expired batches which requires a reset of the producer state.</span></span><br><span class="line">                transactionManager.resetProducerId();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!transactionManager.isTransactional()) &#123;</span><br><span class="line">                <span class="comment">// this is an idempotent producer, so make sure we have a producer id</span></span><br><span class="line">                maybeWaitForProducerId();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionManager.hasUnresolvedSequences() &amp;&amp; !transactionManager.hasFatalError()) &#123;</span><br><span class="line">                transactionManager.transitionToFatalError(</span><br><span class="line">                    <span class="keyword">new</span> KafkaException(<span class="string">"The client hasn't received acknowledgment for "</span> +</span><br><span class="line">                        <span class="string">"some previously sent messages and can no longer retry them. It isn't safe to continue."</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionManager.hasInFlightTransactionalRequest() || maybeSendTransactionalRequest()) &#123;</span><br><span class="line">                <span class="comment">// as long as there are outstanding transactional requests, we simply wait for them to return</span></span><br><span class="line">                client.poll(retryBackoffMs, time.milliseconds());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do not continue sending if the transaction manager is in a failed state or if there</span></span><br><span class="line">            <span class="comment">// is no producer id (for the idempotent case).</span></span><br><span class="line">            <span class="keyword">if</span> (transactionManager.hasFatalError() || !transactionManager.hasProducerId()) &#123;</span><br><span class="line">                RuntimeException lastError = transactionManager.lastError();</span><br><span class="line">                <span class="keyword">if</span> (lastError != <span class="keyword">null</span>)</span><br><span class="line">                    maybeAbortBatches(lastError);</span><br><span class="line">                client.poll(retryBackoffMs, time.milliseconds());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionManager.hasAbortableError()) &#123;</span><br><span class="line">                accumulator.abortUndrainedBatches(transactionManager.lastError());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="comment">// This is already logged as error, but propagated here to perform any clean ups.</span></span><br><span class="line">            log.trace(<span class="string">"Authentication exception while processing transactional request: &#123;&#125;"</span>, e);</span><br><span class="line">            transactionManager.authenticationFailed(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> currentTimeMs = time.milliseconds();</span><br><span class="line">  	<span class="comment">// 从accumulator拿出将要发送的数据，并发送client.send</span></span><br><span class="line">    <span class="keyword">long</span> pollTimeout = sendProducerData(currentTimeMs);</span><br><span class="line">    client.poll(pollTimeout, currentTimeMs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">sendProducerData</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    Cluster cluster = metadata.fetch();</span><br><span class="line">    <span class="comment">// get the list of partitions with data ready to send</span></span><br><span class="line">    RecordAccumulator.ReadyCheckResult result = <span class="keyword">this</span>.accumulator.ready(cluster, now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there are any partitions whose leaders are not known yet, force metadata update</span></span><br><span class="line">    <span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// The set of topics with unknown leader contains topics with leader election pending as well as</span></span><br><span class="line">        <span class="comment">// topics which may have expired. Add the topic again to metadata to ensure it is included</span></span><br><span class="line">        <span class="comment">// and request metadata update, since there are messages to send to the topic.</span></span><br><span class="line">        <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</span><br><span class="line">            <span class="keyword">this</span>.metadata.add(topic);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"Requesting metadata update due to unknown leader topics from the batched records: &#123;&#125;"</span>,</span><br><span class="line">            result.unknownLeaderTopics);</span><br><span class="line">        <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove any nodes we aren't ready to send to</span></span><br><span class="line">    Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</span><br><span class="line">    <span class="keyword">long</span> notReadyTimeout = Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Node node = iter.next();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.client.ready(node, now)) &#123;</span><br><span class="line">            iter.remove();</span><br><span class="line">            notReadyTimeout = Math.min(notReadyTimeout, <span class="keyword">this</span>.client.pollDelayMs(node, now));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create produce requests</span></span><br><span class="line">    Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; batches = <span class="keyword">this</span>.accumulator.drain(cluster, result.readyNodes, <span class="keyword">this</span>.maxRequestSize, now);</span><br><span class="line">    addToInflightBatches(batches);</span><br><span class="line">    <span class="keyword">if</span> (guaranteeMessageOrder) &#123;</span><br><span class="line">        <span class="comment">// Mute all the partitions drained</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;ProducerBatch&gt; batchList : batches.values()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ProducerBatch batch : batchList)</span><br><span class="line">                <span class="keyword">this</span>.accumulator.mutePartition(batch.topicPartition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    accumulator.resetNextBatchExpiryTime();</span><br><span class="line">    List&lt;ProducerBatch&gt; expiredInflightBatches = getExpiredInflightBatches(now);</span><br><span class="line">    List&lt;ProducerBatch&gt; expiredBatches = <span class="keyword">this</span>.accumulator.expiredBatches(now);</span><br><span class="line">    expiredBatches.addAll(expiredInflightBatches);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the producer id if an expired batch has previously been sent to the broker. Also update the metrics</span></span><br><span class="line">    <span class="comment">// for expired batches. see the documentation of @TransactionState.resetProducerId to understand why</span></span><br><span class="line">    <span class="comment">// we need to reset the producer id here.</span></span><br><span class="line">    <span class="keyword">if</span> (!expiredBatches.isEmpty())</span><br><span class="line">        log.trace(<span class="string">"Expired &#123;&#125; batches in accumulator"</span>, expiredBatches.size());</span><br><span class="line">    <span class="keyword">for</span> (ProducerBatch expiredBatch : expiredBatches) &#123;</span><br><span class="line">        String errorMessage = <span class="string">"Expiring "</span> + expiredBatch.recordCount + <span class="string">" record(s) for "</span> + expiredBatch.topicPartition</span><br><span class="line">            + <span class="string">":"</span> + (now - expiredBatch.createdMs) + <span class="string">" ms has passed since batch creation"</span>;</span><br><span class="line">        failBatch(expiredBatch, -<span class="number">1</span>, NO_TIMESTAMP, <span class="keyword">new</span> TimeoutException(errorMessage), <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; expiredBatch.inRetry()) &#123;</span><br><span class="line">            <span class="comment">// This ensures that no new batches are drained until the current in flight batches are fully resolved.</span></span><br><span class="line">            transactionManager.markSequenceUnresolved(expiredBatch.topicPartition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sensors.updateProduceRequestMetrics(batches);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have any nodes that are ready to send + have sendable data, poll with 0 timeout so this can immediately</span></span><br><span class="line">    <span class="comment">// loop and try sending more data. Otherwise, the timeout will be the smaller value between next batch expiry</span></span><br><span class="line">    <span class="comment">// time, and the delay time for checking data availability. Note that the nodes may have data that isn't yet</span></span><br><span class="line">    <span class="comment">// sendable due to lingering, backing off, etc. This specifically does not include nodes with sendable data</span></span><br><span class="line">    <span class="comment">// that aren't ready to send since they would cause busy looping.</span></span><br><span class="line">    <span class="keyword">long</span> pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</span><br><span class="line">    pollTimeout = Math.min(pollTimeout, <span class="keyword">this</span>.accumulator.nextExpiryTimeMs() - now);</span><br><span class="line">    pollTimeout = Math.max(pollTimeout, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result.readyNodes.isEmpty()) &#123;</span><br><span class="line">        log.trace(<span class="string">"Nodes with data ready to send: &#123;&#125;"</span>, result.readyNodes);</span><br><span class="line">        <span class="comment">// if some partitions are already ready to be sent, the select time would be 0;</span></span><br><span class="line">        <span class="comment">// otherwise if some partition already has some data accumulated but not ready yet,</span></span><br><span class="line">        <span class="comment">// the select time will be the time difference between now and its linger expiry time;</span></span><br><span class="line">        <span class="comment">// otherwise the select time will be the time difference between now and the metadata expiry time;</span></span><br><span class="line">        pollTimeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sendProduceRequests(batches, now);</span><br><span class="line">    <span class="keyword">return</span> pollTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendProduceRequest</span><span class="params">(<span class="keyword">long</span> now, <span class="keyword">int</span> destination, <span class="keyword">short</span> acks, <span class="keyword">int</span> timeout, List&lt;ProducerBatch&gt; batches)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (batches.isEmpty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;TopicPartition, MemoryRecords&gt; produceRecordsByPartition = <span class="keyword">new</span> HashMap&lt;&gt;(batches.size());</span><br><span class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, ProducerBatch&gt; recordsByPartition = <span class="keyword">new</span> HashMap&lt;&gt;(batches.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the minimum magic version used when creating the record sets</span></span><br><span class="line">    <span class="keyword">byte</span> minUsedMagic = apiVersions.maxUsableProduceMagic();</span><br><span class="line">    <span class="keyword">for</span> (ProducerBatch batch : batches) &#123;</span><br><span class="line">        <span class="keyword">if</span> (batch.magic() &lt; minUsedMagic)</span><br><span class="line">            minUsedMagic = batch.magic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProducerBatch batch : batches) &#123;</span><br><span class="line">        TopicPartition tp = batch.topicPartition;</span><br><span class="line">        MemoryRecords records = batch.records();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// down convert if necessary to the minimum magic used. In general, there can be a delay between the time</span></span><br><span class="line">        <span class="comment">// that the producer starts building the batch and the time that we send the request, and we may have</span></span><br><span class="line">        <span class="comment">// chosen the message format based on out-dated metadata. In the worst case, we optimistically chose to use</span></span><br><span class="line">        <span class="comment">// the new message format, but found that the broker didn't support it, so we need to down-convert on the</span></span><br><span class="line">        <span class="comment">// client before sending. This is intended to handle edge cases around cluster upgrades where brokers may</span></span><br><span class="line">        <span class="comment">// not all support the same message format version. For example, if a partition migrates from a broker</span></span><br><span class="line">        <span class="comment">// which is supporting the new magic version to one which doesn't, then we will need to convert.</span></span><br><span class="line">        <span class="keyword">if</span> (!records.hasMatchingMagic(minUsedMagic))</span><br><span class="line">            records = batch.records().downConvert(minUsedMagic, <span class="number">0</span>, time).records();</span><br><span class="line">        produceRecordsByPartition.put(tp, records);</span><br><span class="line">        recordsByPartition.put(tp, batch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String transactionalId = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; transactionManager.isTransactional()) &#123;</span><br><span class="line">        transactionalId = transactionManager.transactionalId();</span><br><span class="line">    &#125;</span><br><span class="line">    ProduceRequest.Builder requestBuilder = ProduceRequest.Builder.forMagic(minUsedMagic, acks, timeout,</span><br><span class="line">            produceRecordsByPartition, transactionalId);</span><br><span class="line">    RequestCompletionHandler callback = <span class="keyword">new</span> RequestCompletionHandler() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(ClientResponse response)</span> </span>&#123;</span><br><span class="line">            handleProduceResponse(response, recordsByPartition, time.milliseconds());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    String nodeId = Integer.toString(destination);</span><br><span class="line">    ClientRequest clientRequest = client.newClientRequest(nodeId, requestBuilder, now, acks != <span class="number">0</span>,</span><br><span class="line">            requestTimeoutMs, callback);</span><br><span class="line">  	<span class="comment">// 发送请求</span></span><br><span class="line">    client.send(clientRequest, now);</span><br><span class="line">    log.trace(<span class="string">"Sent produce request to &#123;&#125;: &#123;&#125;"</span>, nodeId, requestBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSend</span><span class="params">(ClientRequest clientRequest, <span class="keyword">boolean</span> isInternalRequest, <span class="keyword">long</span> now, AbstractRequest request)</span> </span>&#123;</span><br><span class="line">    String destination = clientRequest.destination();</span><br><span class="line">    RequestHeader header = clientRequest.makeHeader(request.version());</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">int</span> latestClientVersion = clientRequest.apiKey().latestVersion();</span><br><span class="line">        <span class="keyword">if</span> (header.apiVersion() == latestClientVersion) &#123;</span><br><span class="line">            log.trace(<span class="string">"Sending &#123;&#125; &#123;&#125; with correlation id &#123;&#125; to node &#123;&#125;"</span>, clientRequest.apiKey(), request,</span><br><span class="line">                    clientRequest.correlationId(), destination);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"Using older server API v&#123;&#125; to send &#123;&#125; &#123;&#125; with correlation id &#123;&#125; to node &#123;&#125;"</span>,</span><br><span class="line">                    header.apiVersion(), clientRequest.apiKey(), request, clientRequest.correlationId(), destination);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Send send = request.toSend(destination, header);</span><br><span class="line">    InFlightRequest inFlightRequest = <span class="keyword">new</span> InFlightRequest(</span><br><span class="line">            clientRequest,</span><br><span class="line">            header,</span><br><span class="line">            isInternalRequest,</span><br><span class="line">            request,</span><br><span class="line">            send,</span><br><span class="line">            now);</span><br><span class="line">    <span class="keyword">this</span>.inFlightRequests.add(inFlightRequest);</span><br><span class="line">  	<span class="comment">// 暂存在channel</span></span><br><span class="line">    selector.send(send);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Send send)</span> </span>&#123;</span><br><span class="line">        String connectionId = send.destination();</span><br><span class="line">        KafkaChannel channel = openOrClosingChannelOrFail(connectionId);</span><br><span class="line">        <span class="keyword">if</span> (closingChannels.containsKey(connectionId)) &#123;</span><br><span class="line">            <span class="comment">// ensure notification via `disconnected`, leave channel in the state in which closing was triggered</span></span><br><span class="line">            <span class="keyword">this</span>.failedSends.add(connectionId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.setSend(send);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// update the state for consistency, the channel will be discarded after `close`</span></span><br><span class="line">                channel.state(ChannelState.FAILED_SEND);</span><br><span class="line">                <span class="comment">// ensure notification via `disconnected` when `failedSends` are processed in the next poll</span></span><br><span class="line">                <span class="keyword">this</span>.failedSends.add(connectionId);</span><br><span class="line">                close(channel, CloseMode.DISCARD_NO_NOTIFY);</span><br><span class="line">                <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> CancelledKeyException)) &#123;</span><br><span class="line">                    log.error(<span class="string">"Unexpected exception during send, closing connection &#123;&#125; and rethrowing exception &#123;&#125;"</span>,</span><br><span class="line">                            connectionId, e);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    ensureActive();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!abortedSends.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// If there are aborted sends because of unsupported version exceptions or disconnects,</span></span><br><span class="line">        <span class="comment">// handle them immediately without waiting for Selector#poll.</span></span><br><span class="line">        List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        handleAbortedSends(responses);</span><br><span class="line">        completeResponses(responses);</span><br><span class="line">        <span class="keyword">return</span> responses;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果需要更新meta，则发送获取meta请求</span></span><br><span class="line">    <span class="keyword">long</span> metadataTimeout = metadataUpdater.maybeUpdate(now);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, defaultRequestTimeoutMs));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"Unexpected error during I/O"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process completed actions</span></span><br><span class="line">    <span class="keyword">long</span> updatedNow = <span class="keyword">this</span>.time.milliseconds();</span><br><span class="line">    List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    handleCompletedSends(responses, updatedNow);</span><br><span class="line">    handleCompletedReceives(responses, updatedNow);</span><br><span class="line">    handleDisconnections(responses, updatedNow);</span><br><span class="line">    handleConnections();</span><br><span class="line">    handleInitiateApiVersionRequests(updatedNow);</span><br><span class="line">    handleTimedOutRequests(responses, updatedNow);</span><br><span class="line">    completeResponses(responses);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maybeUpdate</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// should we update our metadata?</span></span><br><span class="line">        <span class="keyword">long</span> timeToNextMetadataUpdate = metadata.timeToNextUpdate(now);</span><br><span class="line">        <span class="keyword">long</span> waitForMetadataFetch = hasFetchInProgress() ? defaultRequestTimeoutMs : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> metadataTimeout = Math.max(timeToNextMetadataUpdate, waitForMetadataFetch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (metadataTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> metadataTimeout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Beware that the behavior of this method and the computation of timeouts for poll() are</span></span><br><span class="line">        <span class="comment">// highly dependent on the behavior of leastLoadedNode.</span></span><br><span class="line">        Node node = leastLoadedNode(now);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">"Give up sending metadata request since no node is available"</span>);</span><br><span class="line">            <span class="keyword">return</span> reconnectBackoffMs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maybeUpdate(now, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">maybeUpdate</span><span class="params">(<span class="keyword">long</span> now, Node node)</span> </span>&#123;</span><br><span class="line">        String nodeConnectionId = node.idString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (canSendRequest(nodeConnectionId, now)) &#123;</span><br><span class="line">          	<span class="comment">// 已建立连接</span></span><br><span class="line">            Metadata.MetadataRequestAndVersion requestAndVersion = metadata.newMetadataRequestAndVersion();</span><br><span class="line">            <span class="keyword">this</span>.inProgressRequestVersion = requestAndVersion.requestVersion;</span><br><span class="line">            MetadataRequest.Builder metadataRequest = requestAndVersion.requestBuilder;</span><br><span class="line">            log.debug(<span class="string">"Sending metadata request &#123;&#125; to node &#123;&#125;"</span>, metadataRequest, node);</span><br><span class="line"> 						<span class="comment">// 发送meta请求，相当于生成者发送消息，最终调用selector.send</span></span><br><span class="line">            sendInternalMetadataRequest(metadataRequest, nodeConnectionId, now);</span><br><span class="line">            <span class="keyword">return</span> defaultRequestTimeoutMs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there's any connection establishment underway, wait until it completes. This prevents</span></span><br><span class="line">        <span class="comment">// the client from unnecessarily connecting to additional nodes while a previous connection</span></span><br><span class="line">        <span class="comment">// attempt has not been completed.</span></span><br><span class="line">        <span class="keyword">if</span> (isAnyNodeConnecting()) &#123;</span><br><span class="line">            <span class="comment">// Strictly the timeout we should return here is "connect timeout", but as we don't</span></span><br><span class="line">            <span class="comment">// have such application level configuration, using reconnect backoff instead.</span></span><br><span class="line">            <span class="keyword">return</span> reconnectBackoffMs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connectionStates.canConnect(nodeConnectionId, now)) &#123;</span><br><span class="line">            <span class="comment">// We don't have a connection to this node right now, make one</span></span><br><span class="line">            log.debug(<span class="string">"Initialize connection to node &#123;&#125; for sending metadata request"</span>, node);</span><br><span class="line">          	<span class="comment">// 如果还没有连接，则初始化连接</span></span><br><span class="line">            initiateConnect(node, now);</span><br><span class="line">            <span class="keyword">return</span> reconnectBackoffMs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// connected, but can't send more OR connecting</span></span><br><span class="line">        <span class="comment">// In either case, we just need to wait for a network event to let us know the selected</span></span><br><span class="line">        <span class="comment">// connection might be usable again.</span></span><br><span class="line">        <span class="keyword">return</span> Long.MAX_VALUE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initiateConnect</span><span class="params">(Node node, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">     String nodeConnectionId = node.idString();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         connectionStates.connecting(nodeConnectionId, now, node.host(), clientDnsLookup);</span><br><span class="line">         InetAddress address = connectionStates.currentAddress(nodeConnectionId);</span><br><span class="line">         log.debug(<span class="string">"Initiating connection to node &#123;&#125; using address &#123;&#125;"</span>, node, address);</span><br><span class="line">         selector.connect(nodeConnectionId,</span><br><span class="line">                 <span class="keyword">new</span> InetSocketAddress(address, node.port()),</span><br><span class="line">                 <span class="keyword">this</span>.socketSendBuffer,</span><br><span class="line">                 <span class="keyword">this</span>.socketReceiveBuffer);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         log.warn(<span class="string">"Error connecting to node &#123;&#125;"</span>, node, e);</span><br><span class="line">         <span class="comment">/* attempt failed, we'll try again after the backoff */</span></span><br><span class="line">         connectionStates.disconnected(nodeConnectionId, now);</span><br><span class="line">         <span class="comment">/* maybe the problem is our metadata, update it */</span></span><br><span class="line">         metadataUpdater.requestUpdate();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Send send)</span> </span>&#123;</span><br><span class="line">       String connectionId = send.destination();</span><br><span class="line">  			<span class="comment">// 拿到一个socketChannel</span></span><br><span class="line">       KafkaChannel channel = openOrClosingChannelOrFail(connectionId);</span><br><span class="line">       <span class="keyword">if</span> (closingChannels.containsKey(connectionId)) &#123;</span><br><span class="line">           <span class="comment">// ensure notification via `disconnected`, leave channel in the state in which closing was triggered</span></span><br><span class="line">           <span class="keyword">this</span>.failedSends.add(connectionId);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">             	<span class="comment">// 设置请求到socketChannel</span></span><br><span class="line">               channel.setSend(send);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="comment">// update the state for consistency, the channel will be discarded after `close`</span></span><br><span class="line">               channel.state(ChannelState.FAILED_SEND);</span><br><span class="line">               <span class="comment">// ensure notification via `disconnected` when `failedSends` are processed in the next poll</span></span><br><span class="line">               <span class="keyword">this</span>.failedSends.add(connectionId);</span><br><span class="line">               close(channel, CloseMode.DISCARD_NO_NOTIFY);</span><br><span class="line">               <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> CancelledKeyException)) &#123;</span><br><span class="line">                   log.error(<span class="string">"Unexpected exception during send, closing connection &#123;&#125; and rethrowing exception &#123;&#125;"</span>,</span><br><span class="line">                           connectionId, e);</span><br><span class="line">                   <span class="keyword">throw</span> e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSend</span><span class="params">(Send send)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.send != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Attempt to begin a send operation with prior send operation still in progress, connection id is "</span> + id);</span><br><span class="line">    <span class="keyword">this</span>.send = send;</span><br><span class="line">    <span class="keyword">this</span>.transportLayer.addInterestOps(SelectionKey.OP_WRITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout should be &gt;= 0"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> madeReadProgressLastCall = madeReadProgressLastPoll;</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> dataInBuffers = !keysWithBufferedRead.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasStagedReceives() || !immediatelyConnectedKeys.isEmpty() || (madeReadProgressLastCall &amp;&amp; dataInBuffers))</span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!memoryPool.isOutOfMemory() &amp;&amp; outOfMemory) &#123;</span><br><span class="line">        <span class="comment">//we have recovered from memory pressure. unmute any channel not explicitly muted for other reasons</span></span><br><span class="line">        log.trace(<span class="string">"Broker no longer low on memory - unmuting incoming sockets"</span>);</span><br><span class="line">        <span class="keyword">for</span> (KafkaChannel channel : channels.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.isInMutableState() &amp;&amp; !explicitlyMutedChannels.contains(channel)) &#123;</span><br><span class="line">                channel.maybeUnmute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        outOfMemory = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check ready keys */</span></span><br><span class="line">    <span class="keyword">long</span> startSelect = time.nanoseconds();</span><br><span class="line">    <span class="keyword">int</span> numReadyKeys = select(timeout);</span><br><span class="line">    <span class="keyword">long</span> endSelect = time.nanoseconds();</span><br><span class="line">    <span class="keyword">this</span>.sensors.selectTime.record(endSelect - startSelect, time.milliseconds());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numReadyKeys &gt; <span class="number">0</span> || !immediatelyConnectedKeys.isEmpty() || dataInBuffers) &#123;</span><br><span class="line">        Set&lt;SelectionKey&gt; readyKeys = <span class="keyword">this</span>.nioSelector.selectedKeys();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poll from channels that have buffered data (but nothing more from the underlying socket)</span></span><br><span class="line">        <span class="keyword">if</span> (dataInBuffers) &#123;</span><br><span class="line">            keysWithBufferedRead.removeAll(readyKeys); <span class="comment">//so no channel gets polled twice</span></span><br><span class="line">            Set&lt;SelectionKey&gt; toPoll = keysWithBufferedRead;</span><br><span class="line">            keysWithBufferedRead = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">//poll() calls will repopulate if needed</span></span><br><span class="line">            pollSelectionKeys(toPoll, <span class="keyword">false</span>, endSelect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poll from channels where the underlying socket has more data</span></span><br><span class="line">        pollSelectionKeys(readyKeys, <span class="keyword">false</span>, endSelect);</span><br><span class="line">        <span class="comment">// Clear all selected keys so that they are included in the ready count for the next select</span></span><br><span class="line">        readyKeys.clear();</span><br><span class="line"></span><br><span class="line">        pollSelectionKeys(immediatelyConnectedKeys, <span class="keyword">true</span>, endSelect);</span><br><span class="line">        immediatelyConnectedKeys.clear();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        madeReadProgressLastPoll = <span class="keyword">true</span>; <span class="comment">//no work is also "progress"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endIo = time.nanoseconds();</span><br><span class="line">    <span class="keyword">this</span>.sensors.ioTime.record(endIo - endSelect, time.milliseconds());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close channels that were delayed and are now ready to be closed</span></span><br><span class="line">    completeDelayedChannelClose(endIo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we use the time at the end of select to ensure that we don't close any connections that</span></span><br><span class="line">    <span class="comment">// have just been processed in pollSelectionKeys</span></span><br><span class="line">    maybeCloseOldestConnection(endSelect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add to completedReceives after closing expired connections to avoid removing</span></span><br><span class="line">    <span class="comment">// channels with completed receives until all staged receives are completed.</span></span><br><span class="line">    addToCompletedReceives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>request，response头部，首先是一个定长的，4字节的头，表示完整数据包的大小，用于分包、粘包处理</p>
<p>在InFlightRequests中，存放了所有发出去，但是response还没有回来的request。request发出去的时候，入队；response回来，就把相对应的request出队</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InFlightRequests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxInFlightRequestsPerConnection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Deque&lt;NetworkClient.InFlightRequest&gt;&gt; requests = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Thread safe total number of in flight requests. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger inFlightRequestCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>服务端，保持同一个连接请求的顺序性，每当一个channel上面接收到一个request，这个channel就会被mute，然后等response返回之后，才会再unmute。这样就保证了同1个连接上面，同时只会有1个请求被处理</p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>单线程</p>
<h3 id="消费组"><a href="#消费组" class="headerlink" title="消费组"></a>消费组</h3><p>Consumer Group 是 Kafka 提供的可扩展且具有容错性的消费者机制</p>
<p>组内必然可以有多个消费者或消费者实例（Consumer Instance），它们共享一个公共的 ID，这个 ID 被称为 Group ID。组内的所有消费者协调在一起来消费订阅主题（Subscribed Topics）的所有分区（Partition）</p>
<p><strong>每个分区只能由同一个消费者组内的一个 Consumer 实例来消费</strong></p>
<p>服务器保存(topic, partition, consumer_group_id) – offset对应关系</p>
<h4 id="消费者入组"><a href="#消费者入组" class="headerlink" title="消费者入组"></a>消费者入组</h4><ol>
<li><p>对于每1个consumer group，Kafka集群为其从broker集群中选择一个broker作为其coordinator。因此，第1步就是找到这个coordinator</p>
</li>
<li><p>找到coordinator之后，发送JoinGroup请求</p>
<p>第一个发送 JoinGroup 请求的成员自动成为领导者</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191213094928449.png" alt="image-20191213094928449"></p>
</li>
<li><p>JoinGroup返回之后，发送SyncGroup，得到自己所分配到的partition</p>
</li>
</ol>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191213094951652.png" alt="image-20191213094951652"></p>
<p>为什么要在consumer中选一个leader出来，进行分配，而不是由coordinator直接分配呢？关于这个, Kafka的官方文档有详细的分析。其中一个重要原因是为了灵活性：如果让server分配，一旦需要新的分配策略，server集群要重新部署，这对于已经在线上运行的集群来说，代价是很大的；而让client分配，server集群就不需要重新部署了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 确保单线程</span></span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Consumer is not subscribed to any topics or assigned any partitions"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll for new data until the timeout expires</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            client.maybeTriggerWakeup();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!updateAssignmentMetadataIfNeeded(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE))) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Still waiting for metadata"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(timer);</span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// before returning the fetched records, we can send off the next round of fetches</span></span><br><span class="line">                <span class="comment">// and avoid block waiting for their responses to enable pipelining while the user</span></span><br><span class="line">                <span class="comment">// is handling the fetched records.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> since the consumed position has already been updated, we must not allow</span></span><br><span class="line">                <span class="comment">// wakeups or any other errors to be triggered prior to returning the fetched records.</span></span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;</span><br><span class="line">                    client.pollNoWakeup();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (timer.notExpired());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="偏移量提交"><a href="#偏移量提交" class="headerlink" title="偏移量提交"></a>偏移量提交</h3><p>老版本 Consumer 的位移管理是依托于 Apache ZooKeeper，ZooKeeper 其实并不适用于这种高频的写操作。</p>
<p>新版本把位移保存在 Kafka Broker内部的主题中，主题名叫__consumer_offsets</p>
<p>从用户的角度来说，位移提交分为自动提交和手动提交；从 Consumer 端的角度来说，位移提交分为同步提交和异步提交</p>
<h4 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records &#x3D;</span><br><span class="line">                        consumer.poll(Duration.ofSeconds(1));</span><br><span class="line">            process(records); &#x2F;&#x2F; 处理消息</span><br><span class="line">            try &#123;</span><br><span class="line">                        consumer.commitSync();</span><br><span class="line">            &#125; catch (CommitFailedException e) &#123;</span><br><span class="line">                        handle(e); &#x2F;&#x2F; 处理提交失败异常</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有重试机制</p>
<h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p>设置enable.auto.commit为true</p>
<p>设置auto.commit.interval.ms，它的默认值是 5 秒，表明Kafka每5秒会为你自动提交一次位移。</p>
<p>poll 方法的逻辑是先提交上一批消息的位移，再处理下一批消息</p>
<p>调用 commitSync() 时，Consumer 程序会处于阻塞状态，直到远端的 Broker 返回提交结果</p>
<p>有重复消费情况</p>
<p>结合两种提交策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                        ConsumerRecords&lt;String, String&gt; records = </span><br><span class="line">                                    consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">                        process(records); <span class="comment">// 处理消息</span></span><br><span class="line">                        commitAysnc(); <span class="comment">// 使用异步提交规避阻塞</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            handle(e); <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                        consumer.commitSync(); <span class="comment">// 最后一次提交使用同步阻塞式提交</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       consumer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="重平衡"><a href="#重平衡" class="headerlink" title="重平衡"></a>重平衡</h2><p>Rebalance 本质上是一种协议，规定了一个 Consumer Group 下的所有 Consumer 如何达成一致，来分配订阅 Topic 的每个分区</p>
<ol>
<li>组成员数发生变更。比如有新的 Consumer 实例加入组或者离开组，抑或是有 Consumer 实例崩溃被“踢出”组。</li>
<li>订阅主题数发生变更。Consumer Group 可以使用正则表达式的方式订阅主题，比如 consumer.subscribe(Pattern.compile(“t.*c”)) 就表明该 Group 订阅所有以字母 t 开头、字母 c 结尾的主题。在 Consumer Group 的运行过程中，你新创建了一个满足这样条件的主题，那么该 Group 就会发生 Rebalance。</li>
<li>订阅主题的分区数发生变更。Kafka 当前只能允许增加一个主题的分区数。当分区数增加时，就会触发订阅该主题的所有 Group 开启 Rebalance。</li>
</ol>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191108114145781.png" alt="image-20191108114145781"></p>
<p>在 Rebalance 过程中，所有 Consumer 实例都会停止消费，等待 Rebalance 完成。</p>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>每个broker就是一个kafka的实例或者称之为kafka的服务。其实控制器也是一个broker，控制器也叫leader broker。</p>
<ol>
<li>主题管理（创建、删除、增加分区）</li>
<li>分区重分配</li>
<li>Preferred 领导者选举</li>
<li>集群成员管理（新增 Broker、Broker 主动关闭、Broker 宕机）</li>
<li>数据服务</li>
</ol>
<h3 id="controller选举"><a href="#controller选举" class="headerlink" title="controller选举"></a>controller选举</h3><p>通过在zookeeper上创建临时节点的方式，选举为leader broker，即控制器</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191211114800350.png" alt="image-20191211114800350"></p>
<h3 id="分区leader选举"><a href="#分区leader选举" class="headerlink" title="分区leader选举"></a>分区leader选举</h3><p>ar集合中第一个存活副本，且在isr集合中</p>
<h3 id="控制器故障转移（Failover）"><a href="#控制器故障转移（Failover）" class="headerlink" title="控制器故障转移（Failover）"></a>控制器故障转移（Failover）</h3><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191210174046139.png" alt="image-20191210174046139"></p>
<p>最开始时，Broker 0 是控制器。当 Broker 0 宕机后，ZooKeeper 通过 Watch 机制感知到并删除了 /controller 临时节点。之后，所有存活的 Broker 开始竞选新的控制器身份。Broker 3 最终赢得了选举，成功地在 ZooKeeper 上重建了 /controller 节点。之后，Broker 3 会从 ZooKeeper 中读取集群元数据信息，并初始化到自己的缓存中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">elect</span><span class="params">()</span>: Unit </span>= &#123;</span><br><span class="line">    activeControllerId = zkClient.getControllerId.getOrElse(-<span class="number">1</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can get here during the initial startup and the handleDeleted ZK callback. Because of the potential race condition,</span></span><br><span class="line"><span class="comment">     * it's possible that the controller has already been elected when we get here. This check will prevent the following</span></span><br><span class="line"><span class="comment">     * createEphemeralPath method from getting into an infinite loop if this broker is already the controller.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (activeControllerId != -<span class="number">1</span>) &#123;</span><br><span class="line">      debug(s<span class="string">"Broker $activeControllerId has been elected as the controller, so stopping the election process."</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果没抛异常，则该实例选举成功，成为leader</span></span><br><span class="line">      val (epoch, epochZkVersion) = zkClient.registerControllerAndIncrementControllerEpoch(config.brokerId)</span><br><span class="line">      controllerContext.epoch = epoch</span><br><span class="line">      controllerContext.epochZkVersion = epochZkVersion</span><br><span class="line">      activeControllerId = config.brokerId</span><br><span class="line"></span><br><span class="line">      info(s<span class="string">"$&#123;config.brokerId&#125; successfully elected as the controller. Epoch incremented to $&#123;controllerContext.epoch&#125; "</span> +</span><br><span class="line">        s<span class="string">"and epoch zk version is now $&#123;controllerContext.epochZkVersion&#125;"</span>)</span><br><span class="line"></span><br><span class="line">      onControllerFailover()</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191210181215208.png" alt="image-20191210181215208"></p>
<p>在分区高水位以下的消息被认为是已提交消息，反之就是未提交消息。消费者只能消费已提交消息</p>
<p>高水位和 LEO 是副本对象的两个重要属性。Kafka 所有副本都有对应的高水位和 LEO 值，而不仅仅是 Leader 副本。只不过 Leader 副本比较特殊，Kafka 使用 Leader 副本的高水位来定义所在分区的高水位。换句话说，分区的高水位就是其 Leader 副本的高水位。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191211093647072.png" alt="image-20191211093647072"></p>
<p>Broker 0 上保存了某分区的 Leader 副本和所有 Follower 副本的 LEO 值，而 Broker 1 上仅仅保存了该分区的某个 Follower 副本</p>
<h4 id="处理生产者请求的逻辑如下："><a href="#处理生产者请求的逻辑如下：" class="headerlink" title="处理生产者请求的逻辑如下："></a>处理生产者请求的逻辑如下：</h4><ol>
<li><p>写入消息到本地磁盘。</p>
</li>
<li><p>更新分区高水位值。</p>
</li>
</ol>
<p>​    i. 获取 Leader 副本所在 Broker 端保存的所有远程副本 LEO 值（LEO-1，LEO-2，……，LEO-n）。</p>
<p>​    ii. 获取 Leader 副本高水位值：currentHW。iii. 更新 currentHW = max{currentHW, min（LEO-1, LEO-2, ……，LEO-n）}。</p>
<h4 id="处理-Follower-副本拉取消息的逻辑如下："><a href="#处理-Follower-副本拉取消息的逻辑如下：" class="headerlink" title="处理 Follower 副本拉取消息的逻辑如下："></a>处理 Follower 副本拉取消息的逻辑如下：</h4><ol>
<li><p>读取磁盘（或页缓存）中的消息数据。</p>
</li>
<li><p>使用 Follower 副本发送请求中的位移值更新远程副本 LEO 值。</p>
</li>
<li><p>更新分区高水位值（具体步骤与处理生产者请求的步骤相同）。</p>
</li>
</ol>
<h4 id="从-Leader-拉取消息的处理逻辑如下："><a href="#从-Leader-拉取消息的处理逻辑如下：" class="headerlink" title="从 Leader 拉取消息的处理逻辑如下："></a>从 Leader 拉取消息的处理逻辑如下：</h4><ol>
<li><p>写入消息到本地磁盘。</p>
</li>
<li><p>更新 LEO 值。更新高水位值。</p>
<p>i. 获取 Leader 发送的高水位值：currentHW。</p>
<p>ii. 获取步骤 2 中更新过的 LEO 值：currentLEO。</p>
<p>iii. 更新高水位为 min(currentHW, currentLEO)。</p>
</li>
</ol>
<p>所有 Broker 都有各自的 Coordinator 组件，专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等。</p>
<p>Kafka 为某个Consumer Group确定Coordinator 所在的 Broker 的算法有 2 个步骤。</p>
<p>第 1 步：确定由位移主题的哪个分区来保存该 Group 数据：partitionId=Math.abs(groupId.hashCode() % offsetsTopicPartitionCount)。</p>
<p>第 2 步：找出该分区 Leader 副本所在的 Broker，该 Broker 即为对应的 Coordinator。</p>
<p>第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。</p>
<p>第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。</p>
<p>第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</p>
<p>最后，客户端程序只能与分区的领导者副本进行交互。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191025140100157.png" alt="image-20191025140100157"></p>
<h2 id="协调器"><a href="#协调器" class="headerlink" title="协调器"></a>协调器</h2><ol>
<li>消费者协调器（ConsumerCoordinator）</li>
<li>组协调器（GroupCoordinator）</li>
<li>任务管理协调器（WorkCoordinator）</li>
</ol>
<h2 id="rocketMQ"><a href="#rocketMQ" class="headerlink" title="rocketMQ"></a>rocketMQ</h2><h3 id="namesrv-VS-zk"><a href="#namesrv-VS-zk" class="headerlink" title="namesrv VS zk"></a>namesrv VS zk</h3><p>  1、我们可以对比下kafka和rocketMq在协调节点选择上的差异，kafka通过zookeeper来进行协调，而rocketMq通过自身的namesrv进行协调。</p>
<p>  2、kafka在具备选举功能，在Kafka里面，Master/Slave的选举，有2步：第1步，先通过ZK在所有机器中，选举出一个KafkaController；第2步，再由这个Controller，决定每个partition的Master是谁，Slave是谁。因为有了选举功能，所以kafka某个partition的master挂了，该partition对应的某个slave会升级为主对外提供服务。</p>
<p>  3、rocketMQ不具备选举，Master/Slave的角色也是固定的。当一个Master挂了之后，你可以写到其他Master上，但不能让一个Slave切换成Master。那么rocketMq是如何实现高可用的呢，其实很简单，rocketMq的所有broker节点的角色都是一样，上面分配的topic和对应的queue的数量也是一样的，Mq只能保证当一个broker挂了，把原本写到这个broker的请求迁移到其他broker上面，而并不是这个broker对应的slave升级为主。</p>
<p> 4、rocketMq在协调节点的设计上显得更加轻量，用了另外一种方式解决高可用的问题，思路也是可以借鉴的。</p>
<h3 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h3><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191211173947135.png" alt="image-20191211173947135"></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://time.geekbang.org/column/article/105112" target="_blank" rel="noopener">https://time.geekbang.org/column/article/105112</a></p>
<p><a href="https://www.jianshu.com/p/a6b9e5342878" target="_blank" rel="noopener">https://www.jianshu.com/p/a6b9e5342878</a></p>
<p><a href="https://www.jianshu.com/p/c474ca9f9430" target="_blank" rel="noopener">https://www.jianshu.com/p/c474ca9f9430</a></p>
<p><a href="https://matt33.com/2017/07/08/kafka-producer-metadata/" target="_blank" rel="noopener">https://matt33.com/2017/07/08/kafka-producer-metadata/</a></p>
<p><a href="https://blog.csdn.net/chunlongyu/article/details/52651960" target="_blank" rel="noopener">https://blog.csdn.net/chunlongyu/article/details/52651960</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/30/2019-4-30-kafka/" data-id="ck521h1cb007hlc7kd3qzewhv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2019-4-28-io模式" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/2019-4-28-io%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2019-04-27T16:00:00.000Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/28/2019-4-28-io%E6%A8%A1%E5%BC%8F/">io模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="io模式"><a href="#io模式" class="headerlink" title="io模式"></a>io模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123; </span><br><span class="line">    socket &#x3D; accept(); </span><br><span class="line">    handle(socket) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">while(true)&#123; </span><br><span class="line">    socket &#x3D; accept(); </span><br><span class="line">    new thread(socket); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/2019-4-28-io%E6%A8%A1%E5%BC%8F/" data-id="ck521h14t0067lc7kbcok7k7h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/6/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/06/2018-6-3-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">2018-6-3-代码规范</a>
          </li>
        
          <li>
            <a href="/2020/01/05/2020-1-5-datax/">离线同步工具DataX</a>
          </li>
        
          <li>
            <a href="/2019/12/31/2019-12-31-replicate/">分布式系统数据同步</a>
          </li>
        
          <li>
            <a href="/2019/12/28/2019-12-28-LCH/">LCH</a>
          </li>
        
          <li>
            <a href="/2019/12/26/2019-12-26-lambda/">lambda</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
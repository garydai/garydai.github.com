<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/25/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="default-2013-6-11-c++_object_model" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/06/11/2013-6-11-c++_object_model/" class="article-date">
  <time datetime="2013-06-10T16:00:00.000Z" itemprop="datePublished">2013-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/06/11/2013-6-11-c++_object_model/">C++对象模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><h3 id="C-对象模型-1"><a href="#C-对象模型-1" class="headerlink" title="C++对象模型"></a>C++对象模型</h3><p>1非静态数据与指向存放虚函数地址的虚函数表的指针放在类的object内，其他静态数据、静态函数、非静态函数独立在object之外，包括虚函数表。<br>2继承基类的子类对象包含基类信息与自己的信息。<br>3虚继承的子类对象，     </p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="缺省构造函数"><a href="#缺省构造函数" class="headerlink" title="缺省构造函数"></a>缺省构造函数</h4><h5 id="没用的-trivial-缺省构造函数"><a href="#没用的-trivial-缺省构造函数" class="headerlink" title="没用的(trivial)缺省构造函数"></a>没用的(trivial)缺省构造函数</h5><p>对于一个类，没用用户声明的构造函数，编译器不会合成缺省构造函数，只合成以下四种有用的构造函数。没有的函数当然不需要合成，很合理。      </p>
<h5 id="有用的缺省构造函数"><a href="#有用的缺省构造函数" class="headerlink" title="有用的缺省构造函数"></a>有用的缺省构造函数</h5><h6 id="一个类包含具有有构造函数的成员类"><a href="#一个类包含具有有构造函数的成员类" class="headerlink" title="一个类包含具有有构造函数的成员类"></a>一个类包含具有有构造函数的成员类</h6><pre><code>Class A
{
public:
    B b;
    int i;
}
Class B
{
public:
    B();
}</code></pre><p>编译器会在A的构造函数里显式的调用B的构造函数   </p>
<pre><code>Class A
{
public:
    inline A()
    {
        B::B();
    }
    B b;
    int i;
}</code></pre><p>如果程序员已经定义了A的构造函数，则编译器也会在构造函数开头插入调用B的构造函数的代码。   </p>
<pre><code>Class A
{
public:
    A()
    {
        **B::B();**
        i = 0;
    }
    B b;
}</code></pre><h6 id="继承带有缺省构造函数的基类"><a href="#继承带有缺省构造函数的基类" class="headerlink" title="继承带有缺省构造函数的基类"></a>继承带有缺省构造函数的基类</h6><p>编译器会合成构造函数来调用基类的构造函数，如果有多个基类，则根据声明顺序调用之。  </p>
<h6 id="带有虚函数的类"><a href="#带有虚函数的类" class="headerlink" title="带有虚函数的类"></a>带有虚函数的类</h6><p>编译器安插构造函数初始化虚函数表指针   </p>
<h6 id="虚继承的类"><a href="#虚继承的类" class="headerlink" title="虚继承的类"></a>虚继承的类</h6><p>同上类似，编译器需要初始化一些关于操作虚基类的代码。以后介绍。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/06/11/2013-6-11-c++_object_model/" data-id="ck521h0zm000ulc7k51vvbr7f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2013-6-7-ucc_compiler_code_review" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/06/07/2013-6-7-ucc_compiler_code_review/" class="article-date">
  <time datetime="2013-06-06T16:00:00.000Z" itemprop="datePublished">2013-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/06/07/2013-6-7-ucc_compiler_code_review/">一款开源C语言编译器源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##一款开源C语言编译器源码解析<br>###预编译</p>
<p>###词法分析 lex.c<br>token表     </p>
<pre><code>//keywords
TOKEN(TK_AUTO,      &quot;auto&quot;)
TOKEN(TK_EXTERN,    &quot;extern&quot;)
TOKEN(TK_REGISTER,  &quot;register&quot;)
TOKEN(TK_STATIC,    &quot;static&quot;)
TOKEN(TK_TYPEDEF,   &quot;typedef&quot;)
TOKEN(TK_CONST,     &quot;const&quot;)
TOKEN(TK_VOLATILE,  &quot;volatile&quot;)
TOKEN(TK_SIGNED,    &quot;signed&quot;)
TOKEN(TK_UNSIGNED,  &quot;unsigned&quot;)
TOKEN(TK_SHORT,     &quot;short&quot;)
TOKEN(TK_LONG,      &quot;long&quot;)
TOKEN(TK_CHAR,      &quot;char&quot;)
TOKEN(TK_INT,       &quot;int&quot;)
TOKEN(TK_INT64,     &quot;__int64&quot;)
TOKEN(TK_FLOAT,     &quot;float&quot;)
TOKEN(TK_DOUBLE,    &quot;double&quot;)
TOKEN(TK_ENUM,      &quot;enum&quot;)
TOKEN(TK_STRUCT,    &quot;struct&quot;)
TOKEN(TK_UNION,     &quot;union&quot;)
TOKEN(TK_VOID,      &quot;void&quot;)
TOKEN(TK_BREAK,     &quot;break&quot;)
TOKEN(TK_CASE,      &quot;case&quot;)
TOKEN(TK_CONTINUE,  &quot;continue&quot;)
TOKEN(TK_DEFAULT,   &quot;default&quot;)
TOKEN(TK_DO,        &quot;do&quot;)
TOKEN(TK_ELSE,      &quot;else&quot;)
TOKEN(TK_FOR,       &quot;for&quot;)
TOKEN(TK_GOTO,      &quot;goto&quot;)
TOKEN(TK_IF,        &quot;if&quot;)
TOKEN(TK_RETURN,    &quot;return&quot;)
TOKEN(TK_SWITCH,    &quot;switch&quot;)
TOKEN(TK_WHILE,     &quot;while&quot;)
TOKEN(TK_SIZEOF,    &quot;sizeof&quot;)

//identifier
TOKEN(TK_ID,        &quot;ID&quot;)

//constant
TOKEN(TK_INTCONST,     &quot;int&quot;)
TOKEN(TK_UINTCONST,    &quot;unsigned int&quot;)
TOKEN(TK_LONGCONST,    &quot;long&quot;)
TOKEN(TK_ULONGCONST,   &quot;unsigned long&quot;)
TOKEN(TK_LLONGCONST,   &quot;long long&quot;)
TOKEN(TK_ULLONGCONST,  &quot;unsigned long long&quot;)
TOKEN(TK_FLOATCONST,   &quot;float&quot;)
TOKEN(TK_DOUBLECONST,  &quot;double&quot;)
TOKEN(TK_LDOUBLECONST, &quot;long double&quot;)
TOKEN(TK_STRING,       &quot;STR&quot;)
TOKEN(TK_WIDESTRING,   &quot;WSTR&quot;)

//operators
TOKEN(TK_COMMA,         &quot;,&quot;)
TOKEN(TK_QUESTION,      &quot;?&quot;)
TOKEN(TK_COLON,         &quot;:&quot;)
TOKEN(TK_ASSIGN,        &quot;=&quot;)
TOKEN(TK_BITOR_ASSIGN,  &quot;|=&quot;)
TOKEN(TK_BITXOR_ASSIGN, &quot;^=&quot;)
TOKEN(TK_BITAND_ASSIGN, &quot;&amp;=&quot;)
TOKEN(TK_LSHIFT_ASSIGN, &quot;&lt;&lt;=&quot;)
TOKEN(TK_RSHIFT_ASSIGN, &quot;&gt;&gt;=&quot;)
TOKEN(TK_ADD_ASSIGN,    &quot;+=&quot;)
TOKEN(TK_SUB_ASSIGN,    &quot;-=&quot;)
TOKEN(TK_MUL_ASSIGN,    &quot;*=&quot;)
TOKEN(TK_DIV_ASSIGN,    &quot;/=&quot;)
TOKEN(TK_MOD_ASSIGN,    &quot;%=&quot;)
TOKEN(TK_OR,            &quot;||&quot;)
TOKEN(TK_AND,           &quot;&amp;&amp;&quot;)
TOKEN(TK_BITOR,         &quot;|&quot;)
TOKEN(TK_BITXOR,        &quot;^&quot;)
TOKEN(TK_BITAND,        &quot;&amp;&quot;)
TOKEN(TK_EQUAL,         &quot;==&quot;)
TOKEN(TK_UNEQUAL,       &quot;!=&quot;)
TOKEN(TK_GREAT,         &quot;&gt;&quot;)
TOKEN(TK_LESS,          &quot;&lt;&quot;)
TOKEN(TK_GREAT_EQ,      &quot;&gt;=&quot;)
TOKEN(TK_LESS_EQ,       &quot;&lt;=&quot;)
TOKEN(TK_LSHIFT,        &quot;&lt;&lt;&quot;)
TOKEN(TK_RSHIFT,        &quot;&gt;&gt;&quot;)
TOKEN(TK_ADD,           &quot;+&quot;)
TOKEN(TK_SUB,           &quot;-&quot;)
TOKEN(TK_MUL,           &quot;*&quot;)
TOKEN(TK_DIV,           &quot;/&quot;)
TOKEN(TK_MOD,           &quot;%&quot;)
TOKEN(TK_INC,           &quot;++&quot;)
TOKEN(TK_DEC,           &quot;--&quot;)
TOKEN(TK_NOT,           &quot;!&quot;)
TOKEN(TK_COMP,          &quot;~&quot;)
TOKEN(TK_DOT,           &quot;.&quot;)
TOKEN(TK_POINTER,       &quot;-&gt;&quot;)
TOKEN(TK_LPAREN,        &quot;(&quot;)
TOKEN(TK_RPAREN,        &quot;)&quot;)
TOKEN(TK_LBRACKET,      &quot;[&quot;)
TOKEN(TK_RBRACKET,      &quot;]&quot;)

//punctuators
TOKEN(TK_LBRACE,        &quot;{&quot;)
TOKEN(TK_RBRACE,        &quot;}&quot;)
TOKEN(TK_SEMICOLON,     &quot;;&quot;)
TOKEN(TK_ELLIPSE,       &quot;...&quot;)
TOKEN(TK_POUND,         &quot;#&quot;)
TOKEN(TK_NEWLINE,       &quot;\n&quot;)

TOKEN(TK_END,           &quot;EOF&quot;)</code></pre><p>各种处理字符的函数scanxxx，组成函数指针数组。 </p>
<pre><code>static Scanner        Scanners[256]; </code></pre><p>得到每个token    </p>
<pre><code>#define NEXT_TOKEN  CurrentToken = GetNextToken();</code></pre><p>###语法解析<br>语法解析与词法分析一起执行，取一个token然后解析。 </p>
<p>将整个cpp，解析成一个语法树。 </p>
<pre><code>Decl.c
transUnit = ParseTranslationUnit(file);</code></pre><p>####语法解析程序结构</p>
<pre><code>ParseTranslationUnit

    ParseExternalDeclaration//解析外部声明

        ParseCommonHeader//各种声明的共同部分

            ParseDeclarationSpecifiers//处理类型限定符(const)、说明符(int)、存储地说明符(auto)

            ParseInitDeclarator

                ParseDeclarator

                ParsePostfixDeclarator

                    ParseDirectDeclarator

        GetFunctionDeclarator

        ParseCompoundStatement//如果是函数定义，解析函数的实现、

            ParseDeclaration

            ParseStatement

                ParseLabelStatement

                ParseCaseStatement

                ParseDefaultStatement

                ParseIfStatement

                ParseSwitchStatement

                ParseWhileStatement

                ParseDoStatement

                ParseForStatement

                ParseGotoStatement

                ParseContinueStatement

                ParseBreakStatement

                ParseReturnStatement

                ParseCompoundStatement

                ParseExpressionStatement                                        </code></pre><p>####解析表达式</p>
<pre><code>ParseExpression

/**
 *  assignment-expression:
 *      conditional-expression

 *      unary-expression assignment-operator assignment-expression
 *  assignment-operator:
 *      = *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
 *  There is a little twist here: the parser always treats the first nonterminal
 *  as a conditional expression.
 */    
    ParseAssignmentExpression

        ParseConditionalExpression

        ParseAssignmentExpression</code></pre><p>####语法树<br>    typedef struct astNode<br>    {<br>        AST_NODE_COMMON<br>    } *AstNode;</p>
<pre><code>ast节点结构
#define AST_NODE_COMMON   \
    int kind;             \节点类型
    struct astNode *next; \
    struct coord coord;

节点类型
enum nodeKind 
{ 
    NK_TranslationUnit,     NK_Function,           NK_Declaration,
    NK_TypeName,            NK_Specifiers,         NK_Token,                
    NK_TypedefName,         NK_EnumSpecifier,      NK_Enumerator,            
    NK_StructSpecifier,     NK_UnionSpecifier,     NK_StructDeclaration,    
    NK_StructDeclarator,    NK_PointerDeclarator,  NK_ArrayDeclarator,        
    NK_FunctionDeclarator,  NK_ParameterTypeList,  NK_ParameterDeclaration,
    NK_NameDeclarator,      NK_InitDeclarator,     NK_Initializer,

    NK_Expression,

    NK_ExpressionStatement, NK_LabelStatement,     NK_CaseStatement,        
    NK_DefaultStatement,    NK_IfStatement,        NK_SwitchStatement,        
    NK_WhileStatement,      NK_DoStatement,        NK_ForStatement,        
    NK_GotoStatement,       NK_BreakStatement,     NK_ContinueStatement,        
    NK_ReturnStatement,     NK_CompoundStatement
};

编译单元cpp
struct astTranslationUnit
{
    AST_NODE_COMMON
    AstNode extDecls;
};</code></pre><p>###语义分析    </p>
<pre><code>CheckTranslationUnit(transUnit);</code></pre><p>####语法解析程序结构</p>
<pre><code>CheckFunction

CheckGlobalDeclaration</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/06/07/2013-6-7-ucc_compiler_code_review/" data-id="ck521h0zu0013lc7k364139b7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2013-6-3-memory" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/06/03/2013-6-3-memory/" class="article-date">
  <time datetime="2013-06-02T16:00:00.000Z" itemprop="datePublished">2013-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/06/03/2013-6-3-memory/">windows内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="windows内存模型"><a href="#windows内存模型" class="headerlink" title="windows内存模型"></a>windows内存模型</h2><p>系统调拨物理存储器(磁盘中的页交换文件和文件映像)给进程的数据与程序，把地址映射到进程地址空间。<br>一开始进程所有页面都在磁盘上，内存中没有数据与程序，所以要先从它们的物理存储器中调入内存。<br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/read_memory.PNG" alt="">    </p>
<h3 id="进程虚拟地址空间"><a href="#进程虚拟地址空间" class="headerlink" title="进程虚拟地址空间"></a>进程虚拟地址空间</h3><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/virtual_memory.PNG" alt="">        </p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>让磁盘空间看起来像内存一样，这部分磁盘空间称为页交换文件。<br>页交换文件在硬盘上，一种内存的后备存储器。把页交换文件映射到进程地址空间。      </p>
<h4 id="使用虚拟内存"><a href="#使用虚拟内存" class="headerlink" title="使用虚拟内存"></a>使用虚拟内存</h4><p>1.预定地址空间区域   </p>
<pre><code>PVOID VirtualAlloc(
    PVOID pvAddress,
    SIZE_T dwSize,
    DWORD fdwAllocationType,
    DWORD fdwProtect);</code></pre><p>fdwAllocationType设置为MEM_RESERVE    </p>
<p>2.调拨物理存储器(页交换文件)<br>fdwAllocationType设置为MEM_COMMIT<br>3.撤销调拨物理存储器及释放区域   </p>
<pre><code>BOOL VirtualFree(
    LPVOID pvAddress,
    SIZE_T dwSize,
    DWORD fdwFreeType);</code></pre><h4 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h4><p>系统创建线程时，会给线程栈预订一块地址空间区域，并调拨页交换文件(大小由.exe的PE文件头中变量指定)。</p>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>文件映像(.exe文件或DLL)，另一种后备存储器，称之为内存映射文件，映射到进程地址空间。<br>硬盘上的文件映射在进程的地址空间中。<br>1.创建或打开文件，创建文件内核对象    </p>
<pre><code>HANDLE CreateFile(
    PCSTR pszFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    PSECURITY_ATTRIBUTES psa,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile);</code></pre><p>2.创建内存映射文件内核对象   </p>
<pre><code>HANDLE CreateFileMapping(
    HANDLE hFile,
    PSECURITY_ATTRIBUTES psa,
    DWORD fdwProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    PCTSTR pszName);</code></pre><p>3.映射到进程地址空间，在地址空间中预订区域并调拨物理存储器  </p>
<pre><code>PVOID MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffSetHigh,
    DWORD dwFileOffSetLow,
    SIZE_T dwNumberOfBytesToMap);</code></pre><h4 id="用应用程序的共享段实现多个实例间的共享静态数据"><a href="#用应用程序的共享段实现多个实例间的共享静态数据" class="headerlink" title="用应用程序的共享段实现多个实例间的共享静态数据"></a>用应用程序的共享段实现多个实例间的共享静态数据</h4><p>告诉编译器把变量放入单独的段中    </p>
<pre><code>#pragma data_seg(&quot;shared&quot;)
#pragma data_set()
#pragma comment(linker, &quot;/SECTION:Shared,RWS&quot;)</code></pre><p>####用内存映射文件在进程间共享数据<br>当启动一个应用程序，系统会先调用CreateFile打开.exe文件，接着调用CreateFileMapping创建文件映射对象，最后调用MapViewOfFileEx映射到进程的固定地址空间(有.exe的PE文件指定基地址)。打开同一个应用程序，系统发现已经存在文件映射对象，就调用MapViewOfFileEx映射.exe文件到对应进程的地址空间。所以系统把相同文件映射到不同进程中，令进程共享程序的代码与数据。<br>####以页交换文件为后备存储器的内存映射文件<br>不再以磁盘文件作为后备存储器，则不需要打开文件创建文件内核对象，直接创建内存映射文件对象，把页交换文件映射到内存。<br>多进程可以利用页交换文件的内存映射文件来共享数据。利用对映射文件对象取别名来标记对象。<br>###堆<br>进程创建的时候，系统会分配一个默认堆。<br>调拨的物理存储器来自页交换文件。<br>####创建额外堆<br>    HeapCreate(<br>        DWORD fdwOptions,<br>        SIZE_T dwInitialSize,<br>        SIZE_T dwMaximumSize);<br>不能保证线程独占堆则不能设置fdwOptions为HEAP_NO_SERIALIZE，保证多线程对同一个堆的访问时依次进行。<br>####从堆中分配内存<br>    PVOID HeapAlloc(<br>        HANDLE hHeap,<br>        DWORD fdwFlags,<br>        SIZE_T dwBytes);</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/06/03/2013-6-3-memory/" data-id="ck521h0zt0012lc7kdl4ufo1k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2013-6-2-puzzle" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/06/02/2013-6-2-puzzle/" class="article-date">
  <time datetime="2013-06-01T16:00:00.000Z" itemprop="datePublished">2013-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/06/02/2013-6-2-puzzle/">面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##面试题<br>###题目<br>有一个淘宝商户，在某城市有n个仓库，每个仓库的储货量不同，现在要通过货物运输，将每个仓库的储货量变成一致的，n个仓库之间的运输线路围城一个圈，即1-&gt;2-&gt;3-&gt;4-&gt;…-&gt;n-&gt;1-&gt;…，货物只能通过连接的仓库运输，设计最小的运送成本（运货量*路程）达到淘宝商户的要求，并写出代码。<br>###思路<br>###code<br>###类似题目<br>均分纸牌<br>石子合并问题<br>矩阵连乘问题</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/06/02/2013-6-2-puzzle/" data-id="ck521h0zq000ylc7kgt3i682e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2013-6-1-IO" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/06/01/2013-6-1-IO/" class="article-date">
  <time datetime="2013-05-31T16:00:00.000Z" itemprop="datePublished">2013-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/06/01/2013-6-1-IO/">I/O</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阻塞式I/O(默认)，非阻塞式I/O(nonblock)，I/O复用(select/poll/epoll)都属于同步I/O，因为它们在数据由内核空间复制回进程缓冲区时都是阻塞的(不能干别的事)。只有异步I/O模型(AIO)是符合异步I/O操作的含义的，即在1数据准备完成、2由内核空间拷贝回缓冲区后 通知进程，在等待通知的这段时间里可以干别的事。</p>
<h2 id="windows-I-O"><a href="#windows-I-O" class="headerlink" title="windows I/O"></a>windows I/O</h2><h3 id="常见IO设备"><a href="#常见IO设备" class="headerlink" title="常见IO设备"></a>常见IO设备</h3><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/io.PNG" alt=""></p>
<h3 id="同步IO"><a href="#同步IO" class="headerlink" title="同步IO"></a>同步IO</h3><p>线程请求IO操作，会阻塞被挂起。  </p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>线程请求IO操作，线程继续进行，不会阻塞。  </p>
<h4 id="将IO请求添加到设备驱动程序处理队列"><a href="#将IO请求添加到设备驱动程序处理队列" class="headerlink" title="将IO请求添加到设备驱动程序处理队列"></a>将IO请求添加到设备驱动程序处理队列</h4><p>在CreateFile创建设备对象的时候，传入FILE_FLAG_OVERLAPPED参数，告诉系统以异步方式访问设备。调用读写设备函数ReadFile、WriteFile，系统会将IO请求加入到设备驱动程序的队列中，并马上返回。设备驱动程序以最合理的顺序处理队列中的IO请求并非先进先处理。<br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/readfile.PNG" alt=""><br>其中最重要的是OVERLAPPED结构，overlapped的意思是线程的执行与IO操作是同时发生的，执行时间是重叠的。<br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/overlapped.PNG" alt=""><br>IO请求处理结束会返回该结构地址，可以创建一个包含OVERLAPPED结构的context结构，保存上下文，根据返回的OVERLAPPED结构地址，通过以下宏可以算出context结构的地址。   </p>
<pre><code>#define CONTAINING_RECORD(address, type, field) ((type *)( \ 
(PCHAR)(address) - \ 
(ULONG_PTR)(&amp;((type *)0)-&gt;field)))  field=context结构中的OVERLAPPED结构</code></pre><h4 id="接收IO请求完成的通知"><a href="#接收IO请求完成的通知" class="headerlink" title="接收IO请求完成的通知"></a>接收IO请求完成的通知</h4><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/iocomplete.PNG" alt="">   </p>
<h5 id="1-触发设备内核对象："><a href="#1-触发设备内核对象：" class="headerlink" title="1.触发设备内核对象："></a>1.触发设备内核对象：</h5><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/ioc1.PNG" alt=""><br>缺点：同时发出多个IO请求，例如先read,然后write,最后waitforobject，不知道最后触发的设备内核对象是针对哪个IO请求。  </p>
<h5 id="2-触发事件内核对象："><a href="#2-触发事件内核对象：" class="headerlink" title="2.触发事件内核对象："></a>2.触发事件内核对象：</h5><p>对不同请求创建事件并赋值给OVERLAPPED结构里的hEvent成员变量。<br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/ioc2_1.PNG" alt=""><br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/ioc2_2.PNG" alt="">  </p>
<h5 id="3-可提醒IO："><a href="#3-可提醒IO：" class="headerlink" title="3.可提醒IO："></a>3.可提醒IO：</h5><p>当系统创建线程的时候，会创建与它相关联的异步过程调用队列(asynchronous procedure call,APC)。当发出一个IO请求的时候，可以告诉设备驱动系统，<strong>当设备驱动程序完成IO操作，就在APC队列中添加回调函数</strong>。<br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/ioc3.PNG" alt=""><br>最后线程可用6个函数将自己睡去并设置为可唤醒状态。如果APC队列里有回调函数，系统会唤醒线程并在同线程内执行回调函数，清空队列后，该6个函数就返回。<br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/ioc3_1.PNG" alt=""><br>缺点：1.回调函数提供的上下文少。2.一个线程发出的多个IO请求只能在同一个线程内执行，负载不够均衡。<br>windows还提供QueueUserAPC函数，允许程序员向线程APC队列里添加回调函数。  </p>
<h5 id="4-IO完成端口"><a href="#4-IO完成端口" class="headerlink" title="4.IO完成端口"></a>4.IO完成端口</h5><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/ioc4.PNG" alt="">   </p>
<p>创建一个IO完成端口，可以将多个设备及各自的完成键(表明IO请求类型(读文件、写文件或者发送套接字等等))与一个完成端口联系起来，并指定几个线程来处理完成端口中完成队列里的IO请求完成的消息。  </p>
<p>线程调用GetQueuedCompletionStatus函数令自己进入睡眠状态，并把自己的线程ID放入等待线程队列，让完成端口内核对象知道有哪些线程在等待IO请求完成，线程等待设备驱动程序处理IO请求并把IO请求的完成键等记录放入IO完成队列后，线程被唤醒，根据IO完成队列里的记录处理IO请求完成后的业务。  </p>
<p>IO完成队列里的记录包括已传输的字节数、完成键、错误代码、OVERLAPPED结构地址，通过返回GetQueuedCompletionStatus函数的参数告知线程。<br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/ioc4_1.PNG" alt="">   </p>
<p>设备列表与等待线程列表<br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/iocp5.PNG" alt=""> </p>
<h2 id="linux-I-O"><a href="#linux-I-O" class="headerlink" title="linux I/O"></a>linux I/O</h2><h3 id="1-阻塞IO"><a href="#1-阻塞IO" class="headerlink" title="1.阻塞IO"></a>1.阻塞IO</h3><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/io1.png" alt=""> </p>
<h3 id="2-非阻塞IO"><a href="#2-非阻塞IO" class="headerlink" title="2.非阻塞IO"></a>2.非阻塞IO</h3><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/io2.png" alt=""> </p>
<h3 id="3-IO多路复用"><a href="#3-IO多路复用" class="headerlink" title="3.IO多路复用:"></a>3.IO多路复用:</h3><p>一个进程处理多个IO请求</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/io3.png" alt=""> </p>
<p>3.1. select/pselect</p>
<p>监视一系列sockets（文件描述符）并阻塞程序，直到至少有一个准备好时行I/O操作。</p>
<p>需要把fd集合从用户态拷贝到内核态返回时还要从内核态拷贝到用户态</p>
<p>内核会先轮询IO是否完成，如果没有再睡眠进程</p>
<p>select支持的文件描述符数量太小了，默认是1024</p>
<p>3.2. poll</p>
<p>和select类似，不同的是传入fd数组，没有个数限制</p>
<p>3.3. epoll</p>
<p>与select不同，不会轮询IO是否完成，而是IO完成后，通过回调函数将发生的事件写入就绪事件链表，写入用户空间。</p>
<p><a href="http://www.cnblogs.com/haippy/archive/2012/01/09/2317269.html" target="_blank" rel="noopener">example1</a></p>
<p><a href="http://www.cnblogs.com/Anker/p/3263780.html" target="_blank" rel="noopener">example2</a></p>
<p>epoll_create创建epoll句柄</p>
<h3 id="4-信号驱动的IO"><a href="#4-信号驱动的IO" class="headerlink" title="4.信号驱动的IO"></a>4.信号驱动的IO</h3><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/io4.PNG" alt=""> </p>
<h3 id="5-异步IO"><a href="#5-异步IO" class="headerlink" title="5.异步IO"></a>5.异步IO</h3><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/io5.PNG" alt=""> </p>
<p>5.1.信号回调函数机制</p>
<p>5.2.线程回调函数机制</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="http://blog.csdn.net/mikeszhang/article/details/8891089" target="_blank" rel="noopener">http://blog.csdn.net/mikeszhang/article/details/8891089</a></p>
<h2 id="知乎关于阻塞非阻塞同步非同步的讨论"><a href="#知乎关于阻塞非阻塞同步非同步的讨论" class="headerlink" title="知乎关于阻塞非阻塞同步非同步的讨论"></a>知乎关于阻塞非阻塞同步非同步的讨论</h2><p><a href="http://www.zhihu.com/question/19732473" target="_blank" rel="noopener">http://www.zhihu.com/question/19732473</a></p>
<p>因为中文语意的问题，很多时候确实会导致混用，而且语境不一样意义也可能不一样。如果只是从计算机编程这个角度说， 讨论最多的也是IO 模型 ，阻塞非阻塞 和 同步异步说的应该是不同的东西。</p>
<p>阻塞非阻塞：可以简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了，否则就可以理解为非阻塞。<br>同步异步： 你总是做完一件再去做另一件，不管是否需要时间等待，这就是同步；异步呢则反之，你可以同时做几件事，并非一定需要一件事做完再做另一件事。同步简单理解成一问一答同步进行，异步可以简单理解为不必等一个问题有答了再去问另一个问题，尽管问，有答了再通知你。</p>
<p>2015/2/4 还有人问，这里补充下，其他楼层也有很好的解释，包括从技术角度都有的详细解释。主要搞清楚本质就行了，他们的不同在于：</p>
<ol>
<li>阻塞非阻塞表示下面 买书过程中 可能出现的状态，是从 我 这个单角色角度来看待这个买书这个问题。</li>
<li>同步异步表示一种协作方式，是从全局更高的角度 “进程之间 合作的方式” 来看待买书这个业务。两个进程之间如果商量采用异步方式处理买书这一业务，就不存在阻塞这种状态。</li>
</ol>
<p>举个例子：<br>我去买一本书，立即买到了，这就是非阻塞；<br>如果恰好书店没有，我就等一直等到书店有了这本书买到了才走，这就是阻塞；<br>如果书店恰好没有，我就告诉书店老板，书来了告诉我一声让我来取或者直接送到我家，然后我就走了，这就是异步。<br>那同步呢？ 前面两种情况，非阻塞和阻塞都可以称为同步。<br>如果说书店有这书，我还让老板通知我以后来取就没这个必要了。</p>
<p>反映在编程方面就是 用户进程 调用 系统调用。(用户进程对应我，内核 对应 书店老板，书对应数据资源data ， 买书就是一个系统调用了)<br>这阻塞非阻塞与同步异步IO机制，都是伴随计算机系统发展，用来解决一些出现的问题。阻塞非阻塞、同步异步可以组合，但是没必要组合，应该说是不同的IO机制，没必要纠结怎么区分，如果定要组合心里才爽，可以 这样认为：阻塞非阻塞都是同步，异步就没什么阻塞不阻塞了，都异步了还阻塞啥，肯定是非阻塞了。(异步非阻塞听起来多别扭)</p>
<p>unix网络编程中说到：<br>将IO模型分为五类：阻塞IO，非阻塞IO，IO复用，信号驱动，异步IO<br>其中阻塞IO就是那种recv, read，一直等，等到有了拷贝了数据才返回；<br>非阻塞就是不用等，立即返回，设置描述符为非阻塞就行了，但是要进程自己一直检查是否可读；<br>IO复用其实也是阻塞的，不过可以用来等很多描述符；<br>信号驱动采用信号机制等待；<br>异步IO就不用等待了，当他告知你的时候，已经可以返回了，数据都拷贝好了。</p>
<p>posix.1严格定义的异步IO是要求没有任何一点阻塞，而上述的前面四个（阻塞IO，非阻塞IO，IO复用，信号驱动）都不同程度阻塞了，而且都有一个共同的阻塞： 内核拷贝数据到进程空间的这段时间需要等待。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/06/01/2013-6-1-IO/" data-id="ck521h17d006rlc7kbcxu4xrd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2013-5-29-sync_thread" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/05/29/2013-5-29-sync_thread/" class="article-date">
  <time datetime="2013-05-28T16:00:00.000Z" itemprop="datePublished">2013-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/05/29/2013-5-29-sync_thread/">window线程同步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="windows线程同步"><a href="#windows线程同步" class="headerlink" title="windows线程同步"></a>windows线程同步</h2><h3 id="volatile限定符"><a href="#volatile限定符" class="headerlink" title="volatile限定符"></a>volatile限定符</h3><p>volatile易变的、不可优化的，易变所以要直接从内存里拿变量</p>
<p>阻止编译器对变量的代码优化，确保当读取变量时是从内存中读取而不是寄存器。防止出现其他一个线程修改了全局变量，而线程中操作变量的代码优化后是操作该变量第一次搬到的寄存器里的值。  </p>
<p>所以多线程编程时，应该对那些共享变量加上volatile类型。    </p>
<h3 id="用户模式下的线程同步"><a href="#用户模式下的线程同步" class="headerlink" title="用户模式下的线程同步"></a>用户模式下的线程同步</h3><h4 id="原子访问"><a href="#原子访问" class="headerlink" title="原子访问"></a>原子访问</h4><p>保证对值的修改是以原子方式进行。    </p>
<p>InterlockedExchangeAdd等,涉及加减、与或。   </p>
<p>Interlocked函数调用一次占用50个以内的时钟周期。  </p>
<p>除了对整数或布尔值进行原子操作外，还能对Interlocked单向链表的栈进行原子操作。  </p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/interlock_stack.PNG" alt=""></p>
<h5 id="旋转锁spinlock"><a href="#旋转锁spinlock" class="headerlink" title="旋转锁spinlock"></a>旋转锁spinlock</h5><p>利用原子操作函数实现旋转锁  </p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/spinlock.PNG" alt=""></p>
<p>建议少用，因为长时间的while循环消耗cpu资源，应该采用在等待过程中，线程被挂起不浪费CPU资源，并由系统唤醒线程的机制。    </p>
<p>原子访问只能原子访问一个变量，不能控制访问一些共享资源，旋转锁轮询机制浪费CPU，因此引入：</p>
<h4 id="关键段critical-section"><a href="#关键段critical-section" class="headerlink" title="关键段critical section"></a>关键段critical section</h4><pre><code>VOID EnterCriticalSection(PCRITICAL_SECTION pcs)  </code></pre><p>EnterCriticalSection函数会检查pcs结构中的变量，这些变量表明是否有其他线程在访问资源。  </p>
<p>如果成员变量表示有其他线程在使用资源，则该函数会使用一个事件内核对象把调用线程切换到等待状态，不会浪费CPU时间。系统会记住该线程想要访问这个资源，当其他线程离开关键段，系统会更新该成员变量且唤醒该线程。</p>
<p>LeaveCriticalSection函数会检查是否关键段没有被任何线程访问，如果没有则唤醒那些等待着的线程。  </p>
<p><strong>enter和leave函数内部都是通过原子方式来检查测试成员变量。</strong>   </p>
<p>缺点：   </p>
<p>能且只能用在一个进程中的多线程同步。可能陷入死锁，因为我们无法为进入关键段的线程设置最大等待时间  </p>
<h4 id="关键段-旋转锁"><a href="#关键段-旋转锁" class="headerlink" title="关键段+旋转锁"></a>关键段+旋转锁</h4><p>使用关键段的线程在得不到资源访问权的时候，会被系统挂起，从用户态切换到内核态，消耗的CPU周期比较大(1000个cpu周期)，切换过程中，占用资源的线程可能已经释放控制。所以可以加入旋转锁，在得不到资源访问权，线程切换前，自循环一段时间。  </p>
<h4 id="slim读、写锁"><a href="#slim读、写锁" class="headerlink" title="slim读、写锁"></a>slim读、写锁</h4><p>同关键段原理，区别的地方在读资源线程可以允许其他读线程访问同一资源，而写线程不允许其他线程读写资源。  </p>
<p>写线程使用AcquireSRWLockExclusive,ReleaseSRWLockExclusive两个函数。  </p>
<p>读线程使用AcquireSRWLockShared，ReleaseSRWLockShared。 </p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>在共享区域外面有关键段的条件下，进入关键段后，根据条件变量决定是否释放关键段的锁，以原子方式把锁释放并将自己阻塞，直到某一个条件成立为止。可以用于读写队列同步线程，例如对于读线程，进入关键段后，当队列为空时，就释放锁并阻塞自己，直到其他线程写完队列后唤醒该线程。  </p>
<p>主要函数SleepConditionVariableCS、SleepConditionVariableSRW、WakeConditionVariable、WakeAllConditionVariable  </p>
<h3 id="用内核对象进行线程同步"><a href="#用内核对象进行线程同步" class="headerlink" title="用内核对象进行线程同步"></a>用内核对象进行线程同步</h3><p>较之用户模式下的线程同步该机制的缺点是调用内核模式下的线程同步函数，调用线程从用户态切换到内核态，切换耗时。  </p>
<p>几乎所有内核对象内部维护一个变量true、false表示该对象触发、或触发（进程、线程、作业、文件以及控制台的标准输入、输出、错误流、事件、可等待的计时器、信号量、互斥量）。</p>
<p>等待函数WaitForSingleObject、WaitForMultipleObjects等待内核对象触发。</p>
<p>可等待的计时器内核对象：指定某个时刻触发事件或每隔一段时间触发事件。  </p>
<p>信号量：信号量内核对象维护一个资源计数，当计数大于0，信号量对象处于触发状态。  </p>
<p>互斥量：与用户态下的关键段相似，不同于其他内核对象，互斥量对象维护了当前运行的线程ID。   </p>
<p>消费者生成者模型原理：</p>
<p>利用信号量和互斥量创建线程安全的队列。用互斥量锁住公共队列；生产者令信号量表示的资源数加1，使得信号量处于触发状态；消费者wait互斥量与信号量都处于触发状态，才能拿队列里的产品。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/mutex_cs.PNG" alt=""></p>
<h3 id="linux线程"><a href="#linux线程" class="headerlink" title="linux线程"></a>linux线程</h3><p><a href="http://garydai.github.io/2019/10/31/linux-thread.html" target="_blank" rel="noopener">http://garydai.github.io/2019/10/31/linux-thread.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/05/29/2013-5-29-sync_thread/" data-id="ck521h0zc000mlc7k194g0rpr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2013-5-29-dll" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/05/29/2013-5-29-dll/" class="article-date">
  <time datetime="2013-05-28T16:00:00.000Z" itemprop="datePublished">2013-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/05/29/2013-5-29-dll/">windows动态链接库DLL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="winodws动态链接库dll"><a href="#winodws动态链接库dll" class="headerlink" title="winodws动态链接库dll"></a>winodws动态链接库dll</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><h3 id="将DLL映射到进程地址空间"><a href="#将DLL映射到进程地址空间" class="headerlink" title="将DLL映射到进程地址空间"></a>将DLL映射到进程地址空间</h3><h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>应用程序的源代码里引用了DLL的符号，加载程序会自动将DLL加载到进程的地址空间中。所以应用程序需要包含模块的头文件。     </p>
<h4 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h4><p>应用程序主动调用LoadLibrary将DLL载入到进程的地址空间中。<br>GetProcAddress引用该dll导出的符号。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>程序开始运行首先加载DLL，然后执行主线程。<br>在程序运行到LoadLibrary函数的时候加载DLL。    </p>
<h3 id="创建dll"><a href="#创建dll" class="headerlink" title="创建dll"></a>创建dll</h3><pre><code>__declspec(dllexport)</code></pre><p>1.创建dll时会创建相应.lib文件，保存dll导出的变量和函数的符号。<br>2.dll文件也会有导入段、导出段，保存dll导入导出的变量和函数符号。<br>3.exe可执行文件里的导入段记录需要导入的dll文件和变量函数符号。    </p>
<h3 id="运行应用程序"><a href="#运行应用程序" class="headerlink" title="运行应用程序"></a>运行应用程序</h3><p>1.启动应用程序时，系统的加载程序会先为进程创建虚拟地址空间，接着把可执行模块映射到进程地址空间，之后检查可执行模块的导入段，把所需的dll定位并映射到进程的地址空间。同时会检查所需dll是否需要dll。<br>2.由于导入段里没有dll在硬盘中的路径，所以加载程序会按一定顺序搜索文件。<br>3.将所以dll模块载入到进程空间后，加载程序检查模块的导入段符号是否存在于相应dll的导出段中，存在则计算符号在进程空间中的地址，并把该地址写入到导入段中。      </p>
<h3 id="DLL入口点函数DllMain"><a href="#DLL入口点函数DllMain" class="headerlink" title="DLL入口点函数DllMain"></a>DLL入口点函数DllMain</h3><p>1.当系统第一次载入dll或LoadLibrary，映射到进程的地址空间，进程主线程会调用该入口点函数并传入DLL_PROCESS_ATTACH，执行相关操作例如创建一个进程堆，当映射完成调用C/C++运行时的启动代码，然后调用可执行模块的入口点函数_tmain。<br>2.当系统将dll的映射撤销出地址空间，例如ExitProcess或FreeLibrary，调用dllMain并传入DLL_PROCESS_DETACH参数。<br>3.创建线程时，线程执行进程中的所有DLL入口点函数，并传入DLL_THREAD_ATTACH参数。<br>4.ExitThread终止线程时，调用各个dll入口点函数。   </p>
<h3 id="延迟载入DLL"><a href="#延迟载入DLL" class="headerlink" title="延迟载入DLL"></a>延迟载入DLL</h3><p>对于隐式链接，只有当我们的代码引用DLL里的符号时，系统才会载入该DLL。        </p>
<h3 id="模块基地址"><a href="#模块基地址" class="headerlink" title="模块基地址"></a>模块基地址</h3><p>可执行文件和DLL模块都有一个在进程地址空间中的首选基地址，如果该地址已被其他模块占用，则加载程序需要修改模块代码，对该模块中任何地址操作进行重定位。应选择合适的dll基地址，防止重定位。         </p>
<h3 id="模块绑定"><a href="#模块绑定" class="headerlink" title="模块绑定"></a>模块绑定</h3><p>绑定一个模块即修改他导入表中的符号在进程空间中的实际地址。           </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/05/29/2013-5-29-dll/" data-id="ck521h0zb000llc7kf4z9cgaq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2013-5-21-interview_code" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/05/21/2013-5-21-interview_code/" class="article-date">
  <time datetime="2013-05-20T16:00:00.000Z" itemprop="datePublished">2013-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/05/21/2013-5-21-interview_code/">面试编程题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="面试编程题"><a href="#面试编程题" class="headerlink" title="面试编程题"></a>面试编程题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>括号匹配：给定字符串，输出括号是否匹配，例如，”()” yes；”)(“ no；”(abcd(e)” no；”(a)(b)” yes。要求必须用递归写，整个实现不可以出现一个循环语句。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>遇到’(‘,count++，遇到’)’，count–，递归过程中，如果count&lt;0，则括号不匹配</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><pre><code>#coding: utf-8
def dfs(string, count):
    if count &lt; 0:
        return False
    if len(string) == 1:
        if string == &apos;(&apos;:
            return False
        elif string == &apos;)&apos;:
            count = count - 1

        if count == 0:
            return True
        else:
            return False
    else:

        if string[0] == &apos;(&apos;:
            count = count + 1
        elif string[0] == &apos;)&apos;:
            count = count - 1
        string = string[1:len(string)]
        return dfs(string, count)

if __name__ == &apos;__main__&apos;:
    print dfs(&apos;(a)(b))11()(a)(b)1&apos;, 0)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/05/21/2013-5-21-interview_code/" data-id="ck521h0z9000jlc7ked6o4h25" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2013-5-21-python_source_code" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/05/21/2013-5-21-python_source_code/" class="article-date">
  <time datetime="2013-05-20T16:00:00.000Z" itemprop="datePublished">2013-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/05/21/2013-5-21-python_source_code/">python对象机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="python对象机制"><a href="#python对象机制" class="headerlink" title="python对象机制"></a>python对象机制</h2><h3 id="对象机制"><a href="#对象机制" class="headerlink" title="对象机制"></a>对象机制</h3><p>在python的世界里，一切都是对象<br>1.对象头结构  </p>
<pre><code>#define PyObject_HEAD           \

    _PyObject_HEAD_EXTRA        \

    int ob_refcnt;          \ //引用计数

    struct _typeobject *ob_type;//指向类型对象的指针</code></pre><p>类型也是一个对象<br>2.类型对象   </p>
<pre><code>typedef struct _typeobject {

    PyObject_VAR_HEAD 

    char *tp_name; /* 类型名For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */

    int tp_basicsize, tp_itemsize; /* 该类型的对象分配空间大小For allocation */



    /* Methods to implement standard operations */

    destructor tp_dealloc;//析构函数指针

    printfunc tp_print;//打印函数指针

     ……

    /* More standard operations (here for binary compatibility) */

    hashfunc tp_hash;

    ternaryfunc tp_call;

    ……

} PyTypeObject;</code></pre><p>3.继承与多态<br>因为各种对象的开始内存都是PyObject_HEAD,可以把这些对象视为继承PyObject的子类  </p>
<pre><code>typedef struct _object { 

    PyObject_HEAD 

} PyObject;  </code></pre><p>当python创建一个对象，比如PyIntObject对象时，分配内存，初始化，然后这个对象由PyObject*变量来维护，通过PyObject的对象类型指针来实现多态，例如打印函数  </p>
<pre><code>void Print(PyObject* object) 

{ 

    object-&gt;ob_type-&gt;tp_print(object); 

} </code></pre><p>4.引用计数，垃圾回收机制 </p>
<pre><code>#define _Py_NewReference(op) ((op)-&gt;ob_refcnt = 1) //引用计数初始化

#define _Py_Dealloc(op) ((*(op)-&gt;ob_type-&gt;tp_dealloc)((PyObject *)(op))) 

#define Py_INCREF(op) ((op)-&gt;ob_refcnt++) 

#define Py_DECREF(op)                   \ 

    if (--(op)-&gt;ob_refcnt != 0)         \ 

        ;            \ 

    else                        \ 

        _Py_Dealloc((PyObject *)(op)) </code></pre><p>当引用计数减为0，调用析构函数  </p>
<p>5.Python对象的分类<br><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/python_object.PNG" alt=""></p>
<h3 id="整数对象"><a href="#整数对象" class="headerlink" title="整数对象"></a>整数对象</h3><p>整数对象是不可变对象(mutable)，即对象内部的值不能被改变，i = i + 1，两个i不是同一个对象，会创建新的i对象。<br>Python维护一个整数对象池，当删除整数对象时，不会回收内存，而把该内存归还给对象池。<br>对于小整数([-5,100])，在解释器初始化的时候已经在对象池中创建了全部小整数对象。  </p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><pre><code>#define BLOCK_SIZE  1000    /* 1K less typical malloc overhead */
#define BHEAD_SIZE  8   /* Enough for a 64-bit pointer */
#define N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))

struct _intblock {
    struct _intblock *next;
    PyIntObject objects[N_INTOBJECTS];
};</code></pre><p>sizeof(PyIntObject) 4字节引用计数，4字节类型对象指针，4字节整数值.<br>所以一个block里有82个整数对象，block_list链表链接不同block，还有空闲链表链接空闲的整数对象。</p>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象也是一个不可变对象，所以连接两个字符串的加法操作都会创建一个新的对象，效率较低.<br>如果连接很多个字符，则需要创建N多次对象，但可以使用字符串对象的join操作来连接多个字符串，该函数首先计算多个字符串的总字节数，申请总字节数的内存，减少申请内存次数。<br>当然该多个字符串存放在list或其他容器里。  </p>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>变长且可变对象   </p>
<pre><code>typedef struct {

    PyObject_VAR_HEAD

    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */

    PyObject **ob_item;

    int allocated;

} PyListObject;</code></pre><p>PyObject_VAR_HEAD里的ob_size表示列表元素个数，allocated表示初始化对象申请的内存大小。与C++里的vector实现机制相似。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/05/21/2013-5-21-python_source_code/" data-id="ck521h0za000klc7kd0p7817m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="default-2013-5-19-knowledge" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/05/19/2013-5-19-knowledge/" class="article-date">
  <time datetime="2013-05-18T16:00:00.000Z" itemprop="datePublished">2013-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/05/19/2013-5-19-knowledge/">知识结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://goo.gl/gPDBI" target="_blank" rel="noopener">http://goo.gl/gPDBI</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/05/19/2013-5-19-knowledge/" data-id="ck521h0z6000hlc7khkbw96c8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/24/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><a class="page-number" href="/page/27/">27</a><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/26/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/05/2020-1-5-datax/">离线同步工具DataX</a>
          </li>
        
          <li>
            <a href="/2019/12/31/2019-12-31-replicate/">分布式系统数据同步</a>
          </li>
        
          <li>
            <a href="/2019/12/28/2019-12-28-LCH/">LCH</a>
          </li>
        
          <li>
            <a href="/2019/12/26/2019-12-26-lambda/">lambda</a>
          </li>
        
          <li>
            <a href="/2019/12/26/2019-12-26-listener/">观察者模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
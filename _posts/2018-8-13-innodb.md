---
layout: default

title: innodb

---

## innodb

### acid
#### atomicity 
事务
#### consistency
InnoDB doublewrite buffer.

InnoDB crash recovery.

#### isolation

### 锁

#### 共享锁
#### 排他锁
#### 意向共享锁
#### 意向排他锁

### redo

为什么要有redo日志？

数据库事务提交后，必须将更新后的数据刷到磁盘上，以保证ACID特性。磁盘随机写性能较低，如果每次都刷盘，会极大影响数据库的吞吐量。


优化方式是，将修改行为先写到redo日志里（此时变成了顺序写），再定期将数据刷到磁盘上，这样能极大提高性能。

随机写优化为顺序写

### undo

为什么要有undo日志？

数据库事务未提交时，会将事务修改数据的镜像（即修改前的旧版本）存放到undo日志里，当事务回滚时，或者数据库奔溃时，可以利用undo日志，即旧版本数据，撤销未提交事务对数据库产生的影响。

对于insert操作，undo日志记录新数据的PK(ROW_ID)，回滚时直接删除；

对于delete/update操作，undo日志记录旧数据row，回滚时直接恢复；

他们分别存放在不同的buffer里。

![image-20191015215734654](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191015215734654.png)

实际上，图  中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。



在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/innodb1.png)



```
公式版：
如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
如果落在黄色部分，那就包括两种情况
 a.  若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
 b.  若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。
 

口语版：
版本未提交，不可见；
版本已提交，但是是在视图创建后提交的，不可见；
版本已提交，而且是在视图创建前提交的，可见。
```



**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read），不是快照\一致性\可重复读。除了 update 语句外，select 语句如果加锁（select lock in share mode;select for update），也是当前读，所以更新数据也会加锁。**

### 回滚段

存储undo日志的地方，是回滚段。



### 索引

InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。


#### 为什么主建，推荐自增整形
建立聚蔟索引树的时候，插入新的顺序的主建，1.减少节点分裂，2.整形比字符型大小比较更快

### ppt
[ppt](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/innodb.pdf "innodb")



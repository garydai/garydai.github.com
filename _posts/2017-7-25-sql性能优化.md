---
layout: default

title: sql性能优化

---

## sql性能优化

### 海量数据分页优化

order by col limit M,OFFSET N , MySQL 执行此类sql时需要先扫描到N行，然后再去取 M行。对于此类大数据量的排序操作，取前面少数几行数据会很快，但是越靠后，sql的性能就会越差，因为N越大，MySQL 需要扫描不需要的数据然后在丢掉，这样耗费大量的时间。


从业务上实现，直接不让用户查询70页后面的数据

不使用 offset ，而是使用 where + limit 来实现，因为索引对排序是有帮助的

使用索引来实现，索引可速查找，先获取ID，然后再使用ID去查询数据，也叫做 延时关联

	例子
	
	select id,name from tableName inner join (select id from tableName limit 5000000,10) as tmp using(id);

	explain SELECT a.* FROM relation a, (select id from relation where biz_type ='0' AND end_time >='2014-05-29' ORDER BY id asc LIMIT 149420 ,20 ) b where a.id=b.id;
	
### count优化 
	find id>100
	 
	select (select count(*) from tableName ) - (select count(*) from tableName where id<100)

### in型子查询的陷阱

全表查询看结果是否属于in范围内

改进：用连接查询来代替子查询

	select goods_id,cat_id,goods_name from goods where cat_id in (select 
	cat_id from ecs_category where parent_id=6);

	explain select goods_id,g.cat_id,g.goods_name from  goods as g inner join (select cat_id from ecs_category where parent_id=6) as t using(cat_id) \G

### from子查询
内层from语句查到的临时表，是没有索引的。所以： from的返回内容要尽量少

### mysql查询优化器
跟踪优化
```
set optimizer_trace = 'enabled=on';
select * from loan_order;
select * from information_schema.OPTIMIZER_TRACE;
```

会对条件做优化（去掉多余的条件例如1=1）

会基于io成本、cpu成本做优化

```

            "rows_estimation": [
              {
                "table": "`loan_order`",
                "table_scan": { //全表扫描估算
                  "rows": 1,
                  "cost": 1
                }
              }
            ]
```
查询优化器会对inner join做优化，会找小表做为驱动表，所以最好用内链接

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/mysql.png)

### reference
[查询优化](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/查询优化.pdf "查询优化")
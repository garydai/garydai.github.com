---
layout: default

title: GC垃圾回收

---

## 垃圾回收

### 哪些垃圾可以回收

#### 引用计数

循环引用的垃圾无法回收。

#### 根搜索算法（可达性分析）
GC roots可以是虚拟机栈、方法区中静态属性引用的对象、方法区常量引用的对象、native方法引用的对象

### 垃圾收集
基于根搜索算法，有标记-删除、复制、标记-整理、分代收集算法来回收垃圾。

其中分代搜集算法利用前三种算法收集不同类型的垃圾。

分代收集：对于新生代采用复制算法，对于老年代采用标记-整理或标记-清除

python:采用引用计数和分代搜集算法

### java分代收集
主要是CMS收集器（concurrent mark sweep）

G1收集器（整体是标记整理，局部是复制）

java server模式下，默认使用Parallel Scavenge + Serial Old收集器组合进行回收


### java内存分配
对象优先在Eden和一个survivor0分配；

1. 再次分配时，如果内存不够，则垃圾收集，把eden和suvivor0存活的对象放到另一个survivor1，同时对象年纪+1；如果survivor1内存不够，且老年代内存足够，则放到老年代，如果对象年纪到达老年代也直接放到老年代；如果老年代内存也不够，则需要进行老年代内存回收即full gc

2. 然后清除eden和survivor0；
3. survivor0和survivor1互换，原survivor1区成为下次的survivor0区


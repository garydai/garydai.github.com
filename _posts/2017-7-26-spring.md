---
layout: default

title: spring

---

# spring



基于POJO的轻量级、最小侵入式开发；

通过依赖注入和面向接口编程实现松耦合；

通过面向切面编程和惯例实现声明式编程；

通过面向切面编程和模板消除样板式代码

### 依赖注入

@autowired 先根据属性类型找bean，再根据name找

@resource 先根据属性name找bean，再根据类型找

利用xml注入bean，类里要写setter才能注入相应属性

还可以根据构造函数注入bean

最后还可以根据一个后置处理器applicationContextAwaret获得applicationContext，得到bean，再给属性赋值

### 初始化

三种实例化之后的回调，如果同时写了三种，则按下面的顺序执行

1. Methods annotated with `@PostConstruct`
2. `afterPropertiesSet()` as defined by the `InitializingBean` callback interface
3. A custom configured `init()` method

Destroy methods are called in the same order:

1. Methods annotated with `@PreDestroy`
2. `destroy()` as defined by the `DisposableBean` callback interface
3. A custom configured `destroy()` method

### 切面编程

业务逻辑模块与系统服务模块分离

### 模板工具


### servlet、filter、listener、interceptor

1、servlet：servlet是一种运行服务器端的java应用程序，具有独立于平台和协议的特性，并且可以动态的生成web页面，它工作在客户端请求与服务器响应的中间层。

2、filter：filter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的

3、listener：监听器，从字面上可以看出listener主要用来监听只用。通过listener可以监听web服务器中某一个执行动作，并根据其要求作出相应的响应。通俗的语言说就是在application，session，request三个对象创建消亡或者往其中添加修改删除属性时自动执行代码的功能组

4、interceptor：是在面向切面编程的，就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法，比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。







Lightweight and minimally invasive development with POJOs

 Loose coupling through DI and interface orientation

 Declarative programming through aspects and common conventions  

Eliminating boilerplate code with aspects and templates


 It doesn’t matter to him what kind of quest he’s asked to embark on, as long as it implements the Quest interface. That’s the key benefit of DI—loose coupling

 One of the most common ways a dependency is swapped out is with a mock imple- mentation during testing. 

 依赖 不应该知道 依赖具体哪个实现，只用依赖接口





## BeanFactoryPostProcessor

修改beandefinition，为什么

## BeanPostProcessor

修改bean实例，为什么



ConfigurationClassPostProcessor

org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry

parse appconfig

```java
	public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {
		ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
				componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);

		Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
		boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
		scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
				BeanUtils.instantiateClass(generatorClass));

		ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
		if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
			scanner.setScopedProxyMode(scopedProxyMode);
		}
		else {
			Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
			scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
		}

		scanner.setResourcePattern(componentScan.getString("resourcePattern"));

		for (AnnotationAttributes filter : componentScan.getAnnotationArray("includeFilters")) {
			for (TypeFilter typeFilter : typeFiltersFor(filter)) {
				scanner.addIncludeFilter(typeFilter);
			}
		}
		for (AnnotationAttributes filter : componentScan.getAnnotationArray("excludeFilters")) {
			for (TypeFilter typeFilter : typeFiltersFor(filter)) {
				scanner.addExcludeFilter(typeFilter);
			}
		}

		boolean lazyInit = componentScan.getBoolean("lazyInit");
		if (lazyInit) {
			scanner.getBeanDefinitionDefaults().setLazyInit(true);
		}

		Set<String> basePackages = new LinkedHashSet<>();
		String[] basePackagesArray = componentScan.getStringArray("basePackages");
		for (String pkg : basePackagesArray) {
			String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
					ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
			Collections.addAll(basePackages, tokenized);
		}
		for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
			basePackages.add(ClassUtils.getPackageName(clazz));
		}
		if (basePackages.isEmpty()) {
			basePackages.add(ClassUtils.getPackageName(declaringClass));
		}

		scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
			@Override
			protected boolean matchClassName(String className) {
				return declaringClass.equals(className);
			}
		});
		return scanner.doScan(StringUtils.toStringArray(basePackages));
	}
```



## 程序启动入口

### spring 入口

#### 注解的方式

new AnnotationConfigApplicationContext
    this.beanFactory = new DefaultListableBeanFactory()
    this.reader = new AnnotatedBeanDefinitionReader(this);
        注册6个beanDefinition
        ConfigurationClassPostProcessor(最重要，解析@configuration这个注解)只有这个是beanFactoryPostProcessor，其他5个都是beanPostProcessor
        AutowiredAnnotationBeanPostProcessor
        RequiredAnnotationBeanPostProcessor
        CommonAnnotationBeanPostProcessor
        PersistenceAnnotationBeanPostProcessor
        EventListenerMethodProcessor
        DefaultEventListenerFactory
    this.scanner = new ClassPathBeanDefinitionScanner(this);
refresh
    prepareBeanFactory
        添加一个后置处理器ApplicationContextAwareProcessor
    invokeBeanFactoryPostProcessors
        org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
            org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
                invokeBeanDefinitionRegistryPostProcessors，执行beanFactoryPostProcessor（其实就是这个类ConfigurationClassPostProcessor）（BeanDefinitionRegistryPostProcessor继承beanFactoryPostProcessor，ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor）
                    ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry
                        org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions
                            取出@configuration、@component、@componentScan、@import、@importResource注解的bd
                            org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate
                                org.springframework.context.annotation.ConfigurationClassParser#parse
                                    org.springframework.context.annotation.ConfigurationClassParser#parse
                                        org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass
                                            org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass
                                                处理@componentScan注解
                                                org.springframework.context.annotation.ComponentScanAnnotationParser#parse
                                                    扫描包
                                                    org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan
                                                        org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
                                                            asm读取class文件，生成bd
                                                            org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents
                                                            org.springframework.context.annotation.ClassPathBeanDefinitionScanner#postProcessBeanDefinition
                                                            org.springframework.context.annotation.AnnotationConfigUtils#processCommonDefinitionAnnotations
                                                            加入到bd map
                                                            org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition
                                                处理@import注解（ImportSelector，普通类，ImportBeanDefinitionRegistrar）
                                                org.springframework.context.annotation.ConfigurationClassParser#processImports
                                                    ImportSelector.class
                                                    ImportBeanDefinitionRegistrar.class
                                                    normal class
                                                    org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass（回到上面步骤）
                                        importSelector的类信息放在configClass
                                        this.configurationClasses.put(configClass, configClass);

                                    configuratoinClass -> bd map                
                                    org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions                
                                        org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass
                                            被标注import的bean注册
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#registerBeanDefinitionForImportedConfigurationClass
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsFromImportedResources
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsFromRegistrars
        org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
            将@configuration的类做了cglib代理
            org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses
    bean实例化
    finishBeanFactoryInitialization
        org.springframework.beans.factory.ObjectFactory#getObject
            org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean
                org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean
                    org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance

ConfigurationClassPostProcessor过滤所有的bd，只解析有@configuration或者（@component、@componentScan、@import、@importResource）的bd



##### import类的几种方式
@Import

@Import（ImportSelector）
根据class反射成object
@ImportBeanDefinitionRegistrar

##### 新增一个bean几种方式
register 类

scan 类

importBeanDefinitionRegistrar 直接导入bd（可以导入一个接口，比如mabatis里的dao接口）

## 初始化bean流程

1：实例化一个ApplicationContext的对象；
2：调用bean工厂后置处理器完成扫描；
3：循环解析扫描出来的类信息；
4：实例化一个BeanDefinition对象来存储解析出来的信息；
5：把实例化好的beanDefinition对象put到beanDefinitionMap当中缓存起来，以便后面实例化bean；
6：再次调用bean工厂后置处理器，完成cglib代理；
7：当然spring还会干很多事情，比如国际化，比如注册BeanPostProcessor等等，如果我们只关心如何实例化一个bean的话那么这一步就是spring调用finishBeanFactoryInitialization方法来实例化单例的bean，实例化之前spring要做验证，需要遍历所有扫描出来的类，依次判断这个bean是否Lazy，是否prototype，是否abstract等等；
8：如果验证完成spring在实例化一个bean之前需要推断构造方法，因为spring实例化对象是通过构造方法反射，故而需要知道用哪个构造方法；
9：推断完构造方法之后spring调用构造方法反射实例化一个对象；注意我这里说的是对象、对象、对象；这个时候对象已经实例化出来了，但是并不是一个完整的bean，最简单的体现是这个时候实例化出来的对象属性是没有注入，所以不是一个完整的bean；
10：spring处理合并后的beanDefinition(合并？是spring当中非常重要的一块内容，后面的文章我会分析)；
11：判断是否支持循环依赖，如果支持则提前把一个工厂存入singletonFactories——map；
12：判断是否需要完成属性注入
13：如果需要完成属性注入，则开始注入属性
14：判断bean的类型回调Aware接口
15：调用生命周期回调方法
16：如果需要代理则完成代理
17：put到单例池——bean完成——存在spring容器当中

```java
AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext();
ac.register(Appconfig.class);
ac.refresh();

public AnnotationConfigApplicationContext(Class<?>... annotatedClasses) {
		//annotatedClasses  appconfig.class
		//这里由于他有父类，故而会先调用父类的构造方法，然后才会调用自己的构造方法
		//在自己构造方法中初始一个读取器和扫描器
		this();
		register(annotatedClasses);
		refresh();
	}
```

### 扫描

```java
org.springframework.context.support.AbstractApplicationContext#refresh

// beanFactory后置处理器
org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors

// 初始只有系统添加的beanFactory后置处理器ConfigurationClassPostProcessor
org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry
				org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions

// 找到已经注册的@Configuration的beanDefinition
org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set<org.springframework.beans.factory.config.BeanDefinitionHolder>)

// 解析bd
org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)

org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass

	// Process any @PropertySource annotations
	// Process any @ComponentScan annotations
	// Process any @Import annotations
	// Process any @ImportResource annotations
org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass

```

处理@ComponentScan时，会遇到@configuration，再重复上面过程

```java
ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
				componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);

org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan

org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents

org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents
```

```java
	private Set<BeanDefinition> scanCandidateComponents(String basePackage) {
		Set<BeanDefinition> candidates = new LinkedHashSet<>();
		try {
			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
					resolveBasePackage(basePackage) + '/' + this.resourcePattern;
      // 获取包下所有的class
			Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
			boolean traceEnabled = logger.isTraceEnabled();
			boolean debugEnabled = logger.isDebugEnabled();
			for (Resource resource : resources) {
				if (traceEnabled) {
					logger.trace("Scanning " + resource);
				}
				if (resource.isReadable()) {
					try {
						MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
						if (isCandidateComponent(metadataReader)) {
              // 找出注解是@Component的class
							ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
							sbd.setResource(resource);
							sbd.setSource(resource);
							if (isCandidateComponent(sbd)) {
								if (debugEnabled) {
									logger.debug("Identified candidate component class: " + resource);
								}
								candidates.add(sbd);
							}
							else {
								if (debugEnabled) {
									logger.debug("Ignored because not a concrete top-level class: " + resource);
								}
							}
						}
						else {
							if (traceEnabled) {
								logger.trace("Ignored because not matching any filter: " + resource);
							}
						}
					}
					catch (Throwable ex) {
						throw new BeanDefinitionStoreException(
								"Failed to read candidate component class: " + resource, ex);
					}
				}
				else {
					if (traceEnabled) {
						logger.trace("Ignored because not readable: " + resource);
					}
				}
			}
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
		}
		return candidates;
	}
```

```java
protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
   for (TypeFilter tf : this.excludeFilters) {
      if (tf.match(metadataReader, getMetadataReaderFactory())) {
         return false;
      }
   }
   // 缺省interface org.springframework.stereotype.Component，interface javax.annotation.ManagedBean
   for (TypeFilter tf : this.includeFilters) {
      if (tf.match(metadataReader, getMetadataReaderFactory())) {
         return isConditionMatch(metadataReader);
      }
   }
   return false;
}
```



##### bean的实例化

##### bean生命周期
 bean的生命周期：
       bean创建---初始化----销毁的过程
  容器管理bean的生命周期；
  我们可以自定义初始化和销毁方法；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法

  构造（对象创建）
       单实例：在容器启动的时候创建对象
       多实例：在每次获取的时候创建对象\

  BeanPostProcessor.postProcessBeforeInitialization
  初始化：
       对象创建完成，并赋值好，调用初始化方法。。。
  BeanPostProcessor.postProcessAfterInitialization
  销毁：
       单实例：容器关闭的时候
       多实例：容器不会管理这个bean；容器不会调用销毁方法；

  遍历得到容器中所有的BeanPostProcessor；挨个执行beforeInitialization，
  一但返回null，跳出for循环，不会执行后面的BeanPostProcessor.postProcessorsBeforeInitialization

  BeanPostProcessor原理
  populateBean(beanName, mbd, instanceWrapper);给bean进行属性赋值
  initializeBean
  {
  applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
  invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化
  applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
 }


 BeanFactoryPostProcessor
 beanFactory初始化之后，bean定义已加载到beanFacotory，还未创建实例

 ##### beanPostProcessor
 5中类型beanPostProcessor，9次调用

第一次 执行InstantiationAwareBeanPostProcessor 的postProcessBeforeInstantiation

在bean没有开始实例化之前执行，记录不需要增强的类。

第二次determineConstructorsFromBeanPostProcessors---SmartInstantiationAwareBeanPostProcessor--determineCandidateConstructors

	推断构造方法

第三次applyMergedBeanDefinitionPostProcessors---MergedBeanDefinitionPostProcessor---postProcessMergedBeanDefinition  

	缓存注解信息

第四次addSingletonFactory ---SmartInstantiationAwareBeanPostProcessor---getEarlyBeanReference

	得到一个体现暴露的对象----对象不是bean（在spring容器当中，并且由sping自己产生的）

第五次populateBean-----InstantiationAwareBeanPostProcessor--postProcessAfterInstantiation

	判断你的bean需不需要完成属性填充


第六次populateBean-------- InstantiationAwareBeanPostProcessor---postProcessPropertyValues
	
    属性填充---自动注入

第七次----BeanPostProcessor----postProcessBeforeInitialization

    postProcessAfterInitialization

9-----------destory


##### 循环注入
B注入到A，B注入到B

1. 实例化A，将A对象放入singletonFactories容器，注入B的时候，实例化B（同实例化A过程），B中注入A，从singletonFactories中拿出A，完成B的注入，返回B，最后注入到A中





```
for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
					BeanDefinitionRegistryPostProcessor registryProcessor =
							(BeanDefinitionRegistryPostProcessor) postProcessor;
					registryProcessor.postProcessBeanDefinitionRegistry(registry);
					registryProcessors.add(registryProcessor);
				}
				else {//BeanDefinitionRegistryPostProcessor  BeanfactoryPostProcessor
					regularPostProcessors.add(postProcessor);
				}
			}
```



#### getbean

org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveBean

org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String, java.lang.Class<T>, java.lang.Object...)




## springboot
零xml

内嵌tomcat

自动配置

##### 自动配置
##### 启动流程

如何内嵌tomcat

如何整合springmvc

如何实现零配置

## factorybean

beanFactory能getbean("name")

factoryBean是什么
返回两个对象，TestFactoryBean对象和getObject里面的对象

```

@Component
public class TestFactoryBean implements FactoryBean {

    @Override
    public boolean isSingleton() {
        return true;
    }

    @Override
    public Object getObject() throws Exception {
        return new RealSubject();
    }

    @Override
    public Class<?> getObjectType() {
        return RealSubject.class;
    }
}

相当于一个工厂类，生产getObject里的产品
AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(TestConfig.class);
Object object1 = annotationConfigApplicationContext.getBean("testFactoryBean"); RealSubject
Object object2 = annotationConfigApplicationContext.getBean("&testFactoryBean"); TestFactory
        

```
```
	final String beanName = transformedBeanName(name);

      name可能会已&开头，这段代码是把&字符去掉，所以上面例子里会有两个beanName，testFactoryBean

```


## event
#### applicationContextEvent事件
ContextClosedEvent

ContextRefreshedEvent

ContextStartedEvent

ContextStoppedEvent





## reference

https://blog.csdn.net/java_lyvee/article/details/101793774





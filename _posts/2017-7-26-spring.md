---
layout: default

title: spring

---

## spring

基于POJO的轻量级、最小侵入式开发；

通过依赖注入和面向接口编程实现松耦合；

通过面向切面编程和惯例实现声明式编程；

通过面向切面编程和模板消除样板式代码

### 依赖注入

@autowired 先根据属性类型找bean，再根据name找

@resource 先根据属性name找bean，再根据类型找

利用xml注入bean，类里要写setter才能注入相应属性

还可以根据构造函数注入bean

最后还可以根据一个后置处理器applicationContextAwaret获得applicationContext，得到bean，再给属性赋值

### 初始化

三种实例化之后的回调，如果同时写了三种，则按下面的顺序执行

1. Methods annotated with `@PostConstruct`
2. `afterPropertiesSet()` as defined by the `InitializingBean` callback interface
3. A custom configured `init()` method

Destroy methods are called in the same order:

1. Methods annotated with `@PreDestroy`
2. `destroy()` as defined by the `DisposableBean` callback interface
3. A custom configured `destroy()` method

### 切面编程

业务逻辑模块与系统服务模块分离

### 模板工具


### servlet、filter、listener、interceptor

1、servlet：servlet是一种运行服务器端的java应用程序，具有独立于平台和协议的特性，并且可以动态的生成web页面，它工作在客户端请求与服务器响应的中间层。

2、filter：filter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的

3、listener：监听器，从字面上可以看出listener主要用来监听只用。通过listener可以监听web服务器中某一个执行动作，并根据其要求作出相应的响应。通俗的语言说就是在application，session，request三个对象创建消亡或者往其中添加修改删除属性时自动执行代码的功能组

4、interceptor：是在面向切面编程的，就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法，比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。







Lightweight and minimally invasive development with POJOs

 Loose coupling through DI and interface orientation

 Declarative programming through aspects and common conventions  

Eliminating boilerplate code with aspects and templates


 It doesn’t matter to him what kind of quest he’s asked to embark on, as long as it implements the Quest interface. That’s the key benefit of DI—loose coupling

 One of the most common ways a dependency is swapped out is with a mock imple- mentation during testing. 

 依赖 不应该知道 依赖具体哪个实现，只用依赖接口







### 程序启动入口

#### spring 入口

##### 注解的方式

new AnnotationConfigApplicationContext
    this.beanFactory = new DefaultListableBeanFactory()
    this.reader = new AnnotatedBeanDefinitionReader(this);
        注册6个beanDefinition
        ConfigurationClassPostProcessor(最重要，解析@configuration这个注解)只有这个是beanFactoryPostProcessor，其他5个都是beanPostProcessor
        AutowiredAnnotationBeanPostProcessor
        RequiredAnnotationBeanPostProcessor
        CommonAnnotationBeanPostProcessor
        PersistenceAnnotationBeanPostProcessor
        EventListenerMethodProcessor
        DefaultEventListenerFactory
    this.scanner = new ClassPathBeanDefinitionScanner(this);
refresh
    prepareBeanFactory
        添加一个后置处理器ApplicationContextAwareProcessor
    invokeBeanFactoryPostProcessors
        org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
            org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
                invokeBeanDefinitionRegistryPostProcessors，执行beanFactoryPostProcessor（其实就是这个类ConfigurationClassPostProcessor）（BeanDefinitionRegistryPostProcessor继承beanFactoryPostProcessor，ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor）
                    ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry
                        org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions
                            取出@configuration、@component、@componentScan、@import、@importResource注解的bd
                            org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate
                                org.springframework.context.annotation.ConfigurationClassParser#parse
                                    org.springframework.context.annotation.ConfigurationClassParser#parse
                                        org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass
                                            org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass
                                                处理@componentScan注解
                                                org.springframework.context.annotation.ComponentScanAnnotationParser#parse
                                                    扫描包
                                                    org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan
                                                        org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
                                                            asm读取class文件，生成bd
                                                            org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents
                                                            org.springframework.context.annotation.ClassPathBeanDefinitionScanner#postProcessBeanDefinition
                                                            org.springframework.context.annotation.AnnotationConfigUtils#processCommonDefinitionAnnotations
                                                            加入到bd map
                                                            org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition
                                                处理@import注解（ImportSelector，普通类，ImportBeanDefinitionRegistrar）
                                                org.springframework.context.annotation.ConfigurationClassParser#processImports
                                                    ImportSelector.class
                                                    ImportBeanDefinitionRegistrar.class
                                                    normal class
                                                    org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass（回到上面步骤）
                                        importSelector的类信息放在configClass
                                        this.configurationClasses.put(configClass, configClass);

                                    configuratoinClass -> bd map                
                                    org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions                
                                        org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass
                                            被标注import的bean注册
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#registerBeanDefinitionForImportedConfigurationClass
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsFromImportedResources
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsFromRegistrars
        org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
            将@configuration的类做了cglib代理
            org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses
    bean实例化
    finishBeanFactoryInitialization
        org.springframework.beans.factory.ObjectFactory#getObject
            org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean
                org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean
                    org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance

ConfigurationClassPostProcessor过滤所有的bd，只解析有@configuration或者（@component、@componentScan、@import、@importResource）的bd



##### import类的几种方式
@Import

@Import（ImportSelector）
根据class反射成object
@ImportBeanDefinitionRegistrar

##### 新增一个bean几种方式
register 类

scan 类

importBeanDefinitionRegistrar 直接导入bd（可以导入一个接口，比如mabatis里的dao接口）

##### 扫描
doScan

findCandidateComponents
##### bean的实例化

##### bean生命周期
 bean的生命周期：
       bean创建---初始化----销毁的过程
  容器管理bean的生命周期；
  我们可以自定义初始化和销毁方法；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法

  构造（对象创建）
       单实例：在容器启动的时候创建对象
       多实例：在每次获取的时候创建对象\

  BeanPostProcessor.postProcessBeforeInitialization
  初始化：
       对象创建完成，并赋值好，调用初始化方法。。。
  BeanPostProcessor.postProcessAfterInitialization
  销毁：
       单实例：容器关闭的时候
       多实例：容器不会管理这个bean；容器不会调用销毁方法；


  遍历得到容器中所有的BeanPostProcessor；挨个执行beforeInitialization，
  一但返回null，跳出for循环，不会执行后面的BeanPostProcessor.postProcessorsBeforeInitialization

  BeanPostProcessor原理
  populateBean(beanName, mbd, instanceWrapper);给bean进行属性赋值
  initializeBean
  {
  applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
  invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化
  applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
 }


 BeanFactoryPostProcessor
 beanFactory初始化之后，bean定义已加载到beanFacotory，还未创建实例

 ##### beanPostProcessor
 5中类型beanPostProcessor，9次调用

第一次 执行InstantiationAwareBeanPostProcessor 的postProcessBeforeInstantiation

在bean没有开始实例化之前执行，记录不需要增强的类。

第二次determineConstructorsFromBeanPostProcessors---SmartInstantiationAwareBeanPostProcessor--determineCandidateConstructors

	推断构造方法

第三次applyMergedBeanDefinitionPostProcessors---MergedBeanDefinitionPostProcessor---postProcessMergedBeanDefinition  

	缓存注解信息

第四次addSingletonFactory ---SmartInstantiationAwareBeanPostProcessor---getEarlyBeanReference

	得到一个体现暴露的对象----对象不是bean（在spring容器当中，并且由sping自己产生的）

第五次populateBean-----InstantiationAwareBeanPostProcessor--postProcessAfterInstantiation

	判断你的bean需不需要完成属性填充


第六次populateBean-------- InstantiationAwareBeanPostProcessor---postProcessPropertyValues
	
    属性填充---自动注入

第七次----BeanPostProcessor----postProcessBeforeInitialization

    postProcessAfterInitialization

9-----------destory


##### 循环注入
B注入到A，B注入到B

1. 实例化A，将A对象放入singletonFactories容器，注入B的时候，实例化B（同实例化A过程），B中注入A，从singletonFactories中拿出A，完成B的注入，返回B，最后注入到A中





```
for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
					BeanDefinitionRegistryPostProcessor registryProcessor =
							(BeanDefinitionRegistryPostProcessor) postProcessor;
					registryProcessor.postProcessBeanDefinitionRegistry(registry);
					registryProcessors.add(registryProcessor);
				}
				else {//BeanDefinitionRegistryPostProcessor  BeanfactoryPostProcessor
					regularPostProcessors.add(postProcessor);
				}
			}
```



#### springmvc

tomcat启动，如果设置loadOnStartUp为1，则开始初始化servlet，否则要等到第一次请求才初始化servlet，org.apache.catalina.core.StandardWrapper#initServlet

调用dispatcherServlet（org.springframework.web.servlet.HttpServletBean#init->org.springframework.web.servlet.FrameworkServlet#initServletBean）方法，初始化handler和映射

使用spring实现mvc设计模式

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/springmvc11.png)

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/springmvc.png)

url进入HandlerMapping，找到具体的controller实现类

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/springmvc2.png)

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/springmvc3.png)

核心组件

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/springmvc4.png)


#### springboot入口
零xml

内嵌tomcat

自动配置

##### 自动配置
##### 启动流程

如何内嵌tomcat

如何整合springmvc

如何实现零配置



#### factorybean

beanFactory能getbean("name")

factoryBean是什么
返回两个对象，TestFactoryBean对象和getObject里面的对象
```

@Component
public class TestFactoryBean implements FactoryBean {

    @Override
    public boolean isSingleton() {
        return true;
    }

    @Override
    public Object getObject() throws Exception {
        return new RealSubject();
    }

    @Override
    public Class<?> getObjectType() {
        return RealSubject.class;
    }
}

相当于一个工厂类，生产getObject里的产品
AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(TestConfig.class);
Object object1 = annotationConfigApplicationContext.getBean("testFactoryBean"); RealSubject
Object object2 = annotationConfigApplicationContext.getBean("&testFactoryBean"); TestFactory
        

```
```
	final String beanName = transformedBeanName(name);

      name可能会已&开头，这段代码是把&字符去掉，所以上面例子里会有两个beanName，testFactoryBean

```


### event
#### applicationContextEvent事件
ContextClosedEvent

ContextRefreshedEvent

ContextStartedEvent

ContextStoppedEvent











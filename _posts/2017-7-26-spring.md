---
layout: default

title: spring

---

## spring

基于POJO的轻量级、最小侵入式开发；

通过依赖注入和面向接口编程实现松耦合；

通过面向切面编程和惯例实现声明式编程；

通过面向切面编程和模板消除样板式代码

### 依赖注入

### 切面编程

业务逻辑模块与系统服务模块分离

### 模板工具


### servlet、filter、listener、interceptor

1、servlet：servlet是一种运行服务器端的java应用程序，具有独立于平台和协议的特性，并且可以动态的生成web页面，它工作在客户端请求与服务器响应的中间层。

2、filter：filter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的

3、listener：监听器，从字面上可以看出listener主要用来监听只用。通过listener可以监听web服务器中某一个执行动作，并根据其要求作出相应的响应。通俗的语言说就是在application，session，request三个对象创建消亡或者往其中添加修改删除属性时自动执行代码的功能组

4、interceptor：是在面向切面编程的，就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法，比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。







Lightweight and minimally invasive development with POJOs

 Loose coupling through DI and interface orientation

 Declarative programming through aspects and common conventions  

Eliminating boilerplate code with aspects and templates


 It doesn’t matter to him what kind of quest he’s asked to embark on, as long as it implements the Quest interface. That’s the key benefit of DI—loose coupling

 One of the most common ways a dependency is swapped out is with a mock imple- mentation during testing. 

 依赖 不应该知道 依赖具体哪个实现，只用依赖接口







### 程序启动入口

#### spring 入口

##### 注解的方式

new AnnotationConfigApplicationContext
    this.beanFactory = new DefaultListableBeanFactory()
    this.reader = new AnnotatedBeanDefinitionReader(this);
        注册6个beanDefinition
        ConfigurationClassPostProcessor(最重要，解析@configuration这个注解)只有这个是beanFactoryPostProcessor，其他5个都是beanPostProcessor
        AutowiredAnnotationBeanPostProcessor
        RequiredAnnotationBeanPostProcessor
        CommonAnnotationBeanPostProcessor
        PersistenceAnnotationBeanPostProcessor
        EventListenerMethodProcessor
        DefaultEventListenerFactory
    this.scanner = new ClassPathBeanDefinitionScanner(this);
refresh
    prepareBeanFactory
        添加一个后置处理器ApplicationContextAwareProcessor
    invokeBeanFactoryPostProcessors
        org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
            org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
                invokeBeanDefinitionRegistryPostProcessors，执行beanFactoryPostProcessor（其实就是这个类ConfigurationClassPostProcessor）（BeanDefinitionRegistryPostProcessor继承beanFactoryPostProcessor，ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor）
                    ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry
                        org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions
                            取出@configuration、@component、@componentScan、@import、@importResource注解的bd
                            org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate
                                org.springframework.context.annotation.ConfigurationClassParser#parse
                                    org.springframework.context.annotation.ConfigurationClassParser#parse
                                        org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass
                                            org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass
                                                处理@componentScan注解
                                                org.springframework.context.annotation.ComponentScanAnnotationParser#parse
                                                    扫描包
                                                    org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan
                                                        org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
                                                            asm读取class文件，生成bd
                                                            org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents
                                                            org.springframework.context.annotation.ClassPathBeanDefinitionScanner#postProcessBeanDefinition
                                                            org.springframework.context.annotation.AnnotationConfigUtils#processCommonDefinitionAnnotations
                                                            加入到bd map
                                                            org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition
                                                处理@import注解（ImportSelector，普通类，ImportBeanDefinitionRegistrar）
                                                org.springframework.context.annotation.ConfigurationClassParser#processImports
                                                    ImportSelector.class
                                                    ImportBeanDefinitionRegistrar.class
                                                    normal class
                                                    org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass（回到上面步骤）
                                        importSelector的类信息放在configClass
                                        this.configurationClasses.put(configClass, configClass);

                                    configuratoinClass -> bd map                
                                    org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions                
                                        org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass
                                            被标注import的bean注册
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#registerBeanDefinitionForImportedConfigurationClass
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsFromImportedResources
                                            org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsFromRegistrars
        org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors
            将@configuration的类做了cglib代理
            org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses

ConfigurationClassPostProcessor过滤所有的bd，只解析有@configuration或者（@component、@componentScan、@import、@importResource）的bd


##### import类的几种方式
@Import

@Import（ImportSelector）
根据class反射成object
@ImportBeanDefinitionRegistrar

##### 新增一个bean几种方式
register 类

scan 类

importBeanDefinitionRegistrar 直接导入bd（可以导入一个接口，比如mabatis里的dao接口）

##### 扫描
doScan

findCandidateComponents
##### bean的实例化

##### bean生命周期
 bean的生命周期：
       bean创建---初始化----销毁的过程
  容器管理bean的生命周期；
  我们可以自定义初始化和销毁方法；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法
  
  构造（对象创建）
       单实例：在容器启动的时候创建对象
       多实例：在每次获取的时候创建对象\
  
  BeanPostProcessor.postProcessBeforeInitialization
  初始化：
       对象创建完成，并赋值好，调用初始化方法。。。
  BeanPostProcessor.postProcessAfterInitialization
  销毁：
       单实例：容器关闭的时候
       多实例：容器不会管理这个bean；容器不会调用销毁方法；
  
  
  遍历得到容器中所有的BeanPostProcessor；挨个执行beforeInitialization，
  一但返回null，跳出for循环，不会执行后面的BeanPostProcessor.postProcessorsBeforeInitialization
  
  BeanPostProcessor原理
  populateBean(beanName, mbd, instanceWrapper);给bean进行属性赋值
  initializeBean
  {
  applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
  invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化
  applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
 }


 BeanFactoryPostProcessor
 beanFactory初始化之后，bean定义已加载到beanFacotory，还未创建实例
#### springmvc 入口

#### springboot入口

如何内嵌tomcat

如何整合springmvc

如何实现零配置







#### factorybean

beanFactory能getbean("name")

factoryBean是什么
返回两个对象，TestFactoryBean对象和getObject里面的对象
```

@Component
public class TestFactoryBean implements FactoryBean {

    @Override
    public boolean isSingleton() {
        return true;
    }

    @Override
    public Object getObject() throws Exception {
        return new RealSubject();
    }

    @Override
    public Class<?> getObjectType() {
        return RealSubject.class;
    }
}

相当于一个工厂类，生产getObject里的产品
AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(TestConfig.class);
Object object1 = annotationConfigApplicationContext.getBean("testFactoryBean"); RealSubject
Object object2 = annotationConfigApplicationContext.getBean("&testFactoryBean"); TestFactory
        

```
```
	final String beanName = transformedBeanName(name);

      name可能会已&开头，这段代码是把&字符去掉，所以上面例子里会有两个beanName，testFactoryBean

```










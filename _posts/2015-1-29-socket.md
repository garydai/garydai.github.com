---
layout: default
title: socket

---
## socket

#### 接收网络数据

网卡收到网线传来的数据，通过硬件电路的传输，将数据写入到内存中的某个地址上

当网卡把数据写入到内存后，网卡向 CPU 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。

从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select 和 epoll 都是阻塞方法

#### 阻塞的原理

操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得 CPU 使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到 recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。



![image-20191113091525419](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191113091525419.png)

![image-20191113091722640](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191113091722640.png)

#####操作系统如何知道网络数据对应于哪个 socket？

因为一个 socket 对应着一个端口号，而网络数据包中包含了 ip 和端口的信息，内核可以通过端口号找到对应的 socket

##### 如何同时监视多个 socket 的数据？

select、epoll

![image-20191113093959871](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191113093959871.png)



当 socket 收到数据后，中断程序会给 eventpoll 的“就绪列表”添加 socket 引用。如下图展示的是 sock2 和 sock3 收到数据后，中断程序让 rdlist 引用这两个 socket。

![image-20191113095241992](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191113095241992.png)

![image-20191113095838347](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191113095838347.png)

eventpoll 对象相当于 socket 和进程之间的中介，socket 的数据接收并不直接影响进程，而是通过改变 eventpoll 的就绪列表来改变进程状态。

当程序执行到 epoll_wait 时，如果 rdlist 已经引用了 socket，那么 epoll_wait 直接返回，如果 rdlist 为空，阻塞进程。

#### socket

socket套接字是一种有相应描述符的打开文件（open—write/read—close）

socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态

socket 在 Linux 中就是以文件的形式存在的，即对应一个文件描述符

每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标

socket结构里，主要的是两个队列，一个是发送队列，一个是接收队列。在这两个队列里面保存的是一个缓存 sk_buff。这个缓存里面能够看到完整的包的结构

socket上定义了几个IO事件：状态改变事件、有数据可读事件、有发送缓存可写事件、有IO错误事件。对于这些事件，socket中分别定义了相应的事件处理函数，也称回调函数。

Socket I/O事件的处理过程中，要使用到sock上的两个队列：等待队列和异步通知队列，这两个队列中都保存着等待该Socket I/O事件的进程。

![image-20191112151603487](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191112151603487.png)

##### 流程：

进程 A 运行到了 epoll_wait 语句，内核会将进程 A 放入 eventpoll 的等待队列wq中，阻塞进程，eventpoll红黑树rbr维护监听的socket，当 socket 接收到数据（ip：port），中断程序快速查找socket，并放入eventpoll就绪队列rdlist，唤醒 eventpoll 等待队列中的进程



#### tcp连接：

### server端

1.1.创建套接字，协议、类型

	socket()

1.2.绑定地址、端口

	bind()

1.3.声明该套接字用于监听

mark a connection-mode socket, specified by the socket argument, as accepting connections.

默认的socket是主动性套接字，用于客户端，listen函数告诉内核该socket是用于监听。

	listen()

1.4.监听套接字直到连接到来，每次接受连接请求会生成已连接描述符，用于客户端通信

	accept()

Accept a connection with the accept() system call. This call typically blocks until a client connects with the server.

如果已经建立了连接的队列有新连接，则accept返回新连接的socket，否则一直阻塞


### client端:


	2.1.socket()
	
	2.2.connect()



https://my.oschina.net/editorial-story/blog/3052308


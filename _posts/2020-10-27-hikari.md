---
date: 2020-10-27
layout: default
title: hirari

---

# hirari

## idleTimeout

这个参数控制了一个**空闲连接**能够在hikari中能够存活的最长时间，只有当`minimumIdle`比`maxiumnPoolSize`小时，才会生效。最小值10秒，默认值10分钟。

- **只有 `idleTimeout > 0` 才会进行空闲连接回收**
- **只有 `minimumIdle < maximumPoolSize`才会进行空闲连接回收**

```java
private final class HouseKeeper implements Runnable
{
   private volatile long previous = plusMillis(currentTime(), -housekeepingPeriodMs);

   @Override
   public void run()
   {
      try {
         // refresh values in case they changed via MBean
         connectionTimeout = config.getConnectionTimeout();
         validationTimeout = config.getValidationTimeout();
         leakTaskFactory.updateLeakDetectionThreshold(config.getLeakDetectionThreshold());
         catalog = (config.getCatalog() != null && !config.getCatalog().equals(catalog)) ? config.getCatalog() : catalog;

         final long idleTimeout = config.getIdleTimeout();
         final long now = currentTime();

         // Detect retrograde time, allowing +128ms as per NTP spec.
         if (plusMillis(now, 128) < plusMillis(previous, housekeepingPeriodMs)) {
            logger.warn("{} - Retrograde clock change detected (housekeeper delta={}), soft-evicting connections from pool.",
                        poolName, elapsedDisplayString(previous, now));
            previous = now;
            softEvictConnections();
            return;
         }
         else if (now > plusMillis(previous, (3 * housekeepingPeriodMs) / 2)) {
            // No point evicting for forward clock motion, this merely accelerates connection retirement anyway
            logger.warn("{} - Thread starvation or clock leap detected (housekeeper delta={}).", poolName, elapsedDisplayString(previous, now));
         }

         previous = now;

         String afterPrefix = "Pool ";
         if (idleTimeout > 0L && config.getMinimumIdle() < config.getMaximumPoolSize()) {
            logPoolState("Before cleanup ");
            afterPrefix = "After cleanup  ";

            final List<PoolEntry> notInUse = connectionBag.values(STATE_NOT_IN_USE);
            int toRemove = notInUse.size() - config.getMinimumIdle();
            for (PoolEntry entry : notInUse) {
                // 如果连接的上次使用时间距今是否已经过去了idleTimeout
               if (toRemove > 0 && elapsedMillis(entry.lastAccessed, now) > idleTimeout && connectionBag.reserve(entry)) {
                  closeConnection(entry, "(connection has passed idleTimeout)");
                  toRemove--;
               }
            }
         }

         logPoolState(afterPrefix);

         fillPool(); // Try to maintain minimum connections
      }
      catch (Exception e) {
         logger.error("Unexpected exception in housekeeping task", e);
      }
   }
}
```

## maxLifetime

这个参数控制了连接在hikari中的最长存活时间（**这句话存疑，本例case就是一个活生生的反例**）。hikari强烈建议设置该值，该值需要比数据库或者**基础设施**的（空闲）连接时间限制要短一点。默认值30分钟。

如果maxLifetime的时候，如果连接正在被使用，则不会被剔除，可以通过idleTimeout剔除空闲连接。

```java
private PoolEntry createPoolEntry()
{
   try {
      final PoolEntry poolEntry = newPoolEntry();

      final long maxLifetime = config.getMaxLifetime();
      if (maxLifetime > 0) {
         // variance up to 2.5% of the maxlifetime
         final long variance = maxLifetime > 10_000 ? ThreadLocalRandom.current().nextLong( maxLifetime / 40 ) : 0;
         final long lifetime = maxLifetime - variance;
         // 一个只运行一次的定时任务，在maxlifetime的时候执行一次
         poolEntry.setFutureEol(houseKeepingExecutorService.schedule(
            () -> {
               // 先软剔除连接，1.标记剔除 2.如果正在使用，不剔除，下次获取连接的时候，看到剔除标记再剔除，或者HouseKeeper的周期性任务做兜底，保证连接空闲时间达到idleTimeout后被回收
               if (softEvictConnection(poolEntry, "(connection has passed maxLifetime)", false /* not owner */)) {
                 	// 提交创建连接的任务
                  addBagItem(connectionBag.getWaitingThreadCount());
               }
            },
            lifetime, MILLISECONDS));
      }

      return poolEntry;
   }
   ...
}
```

poolEntry只有4个状态：

- **NOT_IN_USE**: 未使用
- **IN_USE**: 使用中
- **RESERVED**: 待回收，该标记意味着该连接不可用，不能从连接池中进行获取
- **REMOVED**: 已回收

## 保活机制

1. 连接的生命周期到达`maxLifetime`
2. 连接的空闲时间到达`idleTimeout`



## 参考

https://ayonel.github.io/2020/08/18/hikari-keeplive/
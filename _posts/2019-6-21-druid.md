---
layout: default

title: druid

---

## 数据库连接池druid

### 连接池概念

http://garydai.github.io/2018/01/17/db_pool.html

### init

```

    // init connections，创建连接，使得连接数达到initialSize大小
    while (poolingCount < initialSize) {
        try {
            PhysicalConnectionInfo pyConnectInfo = createPhysicalConnection();
            DruidConnectionHolder holder = new DruidConnectionHolder(this, pyConnectInfo);
            connections[poolingCount++] = holder;
        } catch (SQLException ex) {
            LOG.error("init datasource error, url: " + this.getUrl(), ex);
            if (initExceptionThrow) {
                connectError = ex;
                break;
            } else {
                Thread.sleep(3000);
            }
        }
    }
    
    createAndLogThread();
    // 创建线程用于创建连接
    createAndStartCreatorThread();
    createAndStartDestroyThread();


```

```
    protected void createAndStartCreatorThread() {
        if (createScheduler == null) {
            不用线程池
            String threadName = "Druid-ConnectionPool-Create-" + System.identityHashCode(this);
            createConnectionThread = new CreateConnectionThread(threadName);
            createConnectionThread.start();
            return;
        }
        用线程池
        initedLatch.countDown();
    }
```
```
CreateConnectionThread

        // 线程在等待唤起，连接池的数量为0的时候会唤起
        empty.wait();

        connection = createPhysicalConnection();
        
        // 通知生产者可以消费
        notEmpty.signal()
    }

```


### getConnect
```

    poolableConnection = getConnectionInternal(maxWaitMillis);

    if(testOnBorrow) {
        // 检测连接是否正常
        testConnectionInternal
    } else if(testWhileIdle) {
        if(currentTimeMillis - lastActiveTimeMillis >= timeBetweenEvictionRunsMillis) {
            // 这个连接上次活跃距离现在的时间超过规定的空闲时间
            testConnectionInternal
        }
    }

```
```
getConnectionInternal

    if (maxWait > 0) {
        holder = pollLast(nanos);
    } else {
        holder = takeLast();
    }

```
```
pollLast

    if(poolingCount == 0) {
        // 如果连接池为空，通知生产者生成连接
        emptySignal();
        // 等待生产连接成功
        notEmpty.awaitNanos(estimate);
    }

takeLast

    if(poolingCount == 0) {
        // 如果连接池为空，通知生产者生成连接
        emptySignal();
        // 等待生产连接成功
        notEmpty.await();
    }
    
```


### testConnectionInternal

```
DruidAbstractDataSource

    if (validConnectionChecker != null) {
        validConnectionChecker.isValidConnection(conn, validationQuery, validationQueryTimeout)

        if (valid && isMySql) { // unexcepted branch
            long lastPacketReceivedTimeMs = MySqlUtils.getLastPacketReceivedTimeMs(conn);
            if (lastPacketReceivedTimeMs > 0) {
                long mysqlIdleMillis = currentTimeMillis - lastPacketReceivedTimeMs;
                if (lastPacketReceivedTimeMs > 0 //
                        && mysqlIdleMillis >= timeBetweenEvictionRunsMillis) {
                            // 如果连接长时间未使用，则抛弃连接
                    discardConnection(conn);
                    String errorMsg = "discard long time none received connection. "
                            + ", jdbcUrl : " + jdbcUrl
                            + ", jdbcUrl : " + jdbcUrl
                            + ", lastPacketReceivedIdleMillis : " + mysqlIdleMillis;
                    LOG.error(errorMsg);
                    return false;
                }
            }
        }
    }
    如果没有设置checker
    Statement stmt = null;
    ResultSet rset = null;
    try {
        stmt = conn.createStatement();
        if (getValidationQueryTimeout() > 0) {
            stmt.setQueryTimeout(validationQueryTimeout);
        }
        rset = stmt.executeQuery(validationQuery);
        if (!rset.next()) {
            return false;
        }
    } finally {
        JdbcUtils.close(rset);
        JdbcUtils.close(stmt);
    }


    /**
     * 抛弃连接，不进行回收，而是抛弃
     * 
     * @param realConnection
     */
    public void discardConnection(Connection realConnection) {
        JdbcUtils.close(realConnection);

        lock.lock();
        try {
            activeCount--;
            discardCount++;

            if (activeCount <= minIdle) {
                emptySignal();
            }
        } finally {
            lock.unlock();
        }
    }

mysql连接检查器
public class MSSQLValidConnectionChecker extends ValidConnectionCheckerAdapter implements ValidConnectionChecker, Serializable {

    public boolean isValidConnection(final Connection c, String validateQuery, int validationQueryTimeout) throws Exception {
            if (c.isClosed()) {
                return false;
            }

            Statement stmt = null;

            try {
                stmt = c.createStatement();
                if (validationQueryTimeout > 0) {
                    stmt.setQueryTimeout(validationQueryTimeout);
                }
                stmt.execute(validateQuery);
                return true;
            } catch (SQLException e) {
                throw e;
            } finally {
                JdbcUtils.close(stmt);
            }
        }

}

```











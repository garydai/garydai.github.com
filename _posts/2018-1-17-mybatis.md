---
layout: default

title: mybatis

---

## mybatis

封装了jdbc

### 单独使用

```java
使用xml初始化SqlSessionFactory
String resource = "mybatis.xml";
InputStream inputStream  = Resources.getResourceAsStream(resource);
//解析mybatis配置文件，主要解析mapperElement(root.evalNode("mappers"));
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

（不使用xml初始化SqlSessionFactory
DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();
TransactionFactory transactionFactory = new JdbcTransactionFactory();
Environment environment = new Environment("development", transactionFactory, dataSource);
Configuration configuration = new Configuration(environment);
configuration.addMapper(BlogMapper.class);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
）

SqlSession sqlSession = sqlSessionFactory.openSession();

动态代理xxxMapper，执行xxxMapper函数的时候发送sql命令
xxxMapper mapper = session.getMapper(xxxMapper.class);
mapper.select();
```

配置

```
properties（属性）
settings（设置）
typeAliases（类型别名）
typeHandlers（类型处理器）
objectFactory（对象工厂）
plugins（插件）
environments（环境配置）
environment（环境变量）
transactionManager（事务管理器）
dataSource（数据源）
databaseIdProvider（数据库厂商标识）
mappers（映射器）
```



#### 执行流程

```java
1. 根据xml或者无xml初始化SqlSessionFaction
	SqlSessionFactoryBuilder().build
2. 打开SqlSession对象 
	sqlSessionFactory.openSession()
3. 动态代理mapper
  SqlSession.getMapper()
4. 执行代理后的对象mapperProxy的invoke
  SqlSession.select/update
5. BaseExecutor/CachingExecutor(BaseExecutor的代理)
  Executor执行query/queryFromDatabase
6. 初始化prepareStatement并给#{}赋值 
  SimpleExecutor.doQuery
7. 执行sql语句 
  StatementHandler.query
8. 封装结果集 
  ResultHandler handleResultSets	
  
  
 
```

#### 一级缓存

***PerpetualCache***：作为最基础的缓存类，底层实现比较简单，直接使用了HashMap。

#### 二级缓存

装饰器

**SynchronizedCache：同步Cache，实现比较简单，直接使用synchronized修饰方法。**
**LoggingCache：日志功能，用于记录缓存的命中率，如果开启了DEBUG模式，则会输出命中率日志。**

**SerializedCache：序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全。**
**LruCache：采用了Lru算法的Cache实现，移除最近最少使用的Key/Value。**

​	LRU（最近最少使用的）：移除最长时间不被使用的对象，这是默认值
​	FIFO（先进先出）： 按对象进入缓存的顺序来移除它们

​	SOFT（软引用）：移除基于垃圾回收器状态和软引用规则的对象 

​	WEAK（弱引用）：更积极地移除基于垃圾收集器状态和弱引用规则的对象

**PerpetualCache： 作为为最基础的缓存类，底层实现比较简单，直接使用了HashMap**

#### 四大对象

executor

StatementHandler

parameterHandler

resultHandler

#### 插件

实现Interceptor接口，可以通过动态代理对四大对象进行拦截

```
分页插件
//args : 你需要mybatis传入什么参数给你 type :你需要拦截的对象  method=要拦截的方法
@Intercepts(@Signature(type = StatementHandler.class,method ="prepare",args = {Connection.class,Integer.class}))
public class MyPagePlugin implements Interceptor {

    String databaseType = "";

    String pageSqlId = "";

    public String getDatabaseType() {
        return databaseType;
    }

    public void setDatabaseType(String databaseType) {
        this.databaseType = databaseType;
    }

    public String getPageSqlId() {
        return pageSqlId;
    }

    public void setPageSqlId(String pageSqlId) {
        this.pageSqlId = pageSqlId;
    }

    //我们自己拦截器里面的逻辑
    @Override
    public Object intercept(Invocation invocation) throws Throwable {

        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();

//        statementHandler.getDelegate().getmappedStatement().getId();
//        Field delegate = StatementHandler.class.getDeclaredField("delegate");
//        delegate.setAccessible(true);
//        Object o = delegate.get(statementHandler);
//        o.getClass().getDeclaredField("mappedStatement").

        MetaObject metaObject = MetaObject.forObject(
                statementHandler, SystemMetaObject.DEFAULT_OBJECT_FACTORY,SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,new DefaultReflectorFactory());
        String sqlId = (String)metaObject.getValue("delegate.mappedStatement.id");
        //判断一下是否是分页
//        <!--第一步 执行一条couunt语句-->
        //1.1拿到连接
        //1.2 预编译SQL语句 拿到绑定的sql语句
        //1.3 执行 count语句   怎么返回你执行count的结果

//    <!--第二部 重写sql  select * from luban_product  limit start,limit -->
        //2.1 ？ 怎么知道 start 和limit
        //2.2拼接start 和limit
        //2.3 替换原来绑定sql
        //拿到原来应该执行的sql
        if (sqlId.matches(pageSqlId)){
            ParameterHandler parameterHandler = statementHandler.getParameterHandler();
            //原来应该执行的sql
            String sql = statementHandler.getBoundSql().getSql();
            //sql= select * from  product    select count(0) from (select * from  product) as a
            //select * from luban_product where name = #{name}
            //执行一条count语句
            //拿到数据库连接对象
            Connection connection = (Connection) invocation.getArgs()[0];
            String countSql = "select count(0) from ("+sql+") a";
            System.out.println(countSql);
            //渲染参数
            PreparedStatement preparedStatement = connection.prepareStatement(countSql);
            //条件交给mybatis
            parameterHandler.setParameters(preparedStatement);
            ResultSet resultSet = preparedStatement.executeQuery();
            int count =0;
            if (resultSet.next()) {
                count = resultSet.getInt(1);
            }
            resultSet.close();
            preparedStatement.close();
            //获得你传进来的参数对象
            Map<String, Object> parameterObject = (Map<String, Object>) parameterHandler.getParameterObject();
            //limit  page
            PageUtil pageUtil = (PageUtil) parameterObject.get("page");
            //limit 1 ,10  十条数据   总共可能有100   count 要的是 后面的100
            pageUtil.setCount(count);

            //拼接分页语句(limit) 并且修改mysql本该执行的语句
            String pageSql = getPageSql(sql, pageUtil);
            metaObject.setValue("delegate.boundSql.sql",pageSql);
            System.out.println(pageSql);
        }
        //推进拦截器调用链
        return invocation.proceed();
    }

    public String getPageSql(String sql,PageUtil pageUtil){
        if(databaseType.equals("mysql")){
            return sql+" limit "+pageUtil.getStart()+","+pageUtil.getLimit();
        }else if(databaseType.equals("oracle")){
            //拼接oracle的分语句
        }

        return sql+" limit "+pageUtil.getStart()+","+pageUtil.getLimit();
    }


    //需要你返回一个动态代理后的对象  target :StatementHandler
    @Override
    public Object plugin(Object target) {
        return Plugin.wrap(target,this);
    }

    //会传入配置文件内容 用户可根据配置文件自定义
    @Override
    public void setProperties(Properties properties) {

    }
}

```



#### 日志



### spring+mybatis

init SqlSessionFactoryBean

mappper.xml


#### 扫描mapper（需要了解spring的factoryBean的概念）
第一步解析@MapperScan -> @Import(MapperScannerRegistrar.class) -> ClassPathMapperScanner.doScan扫描mapper，得到mapper的所有db -> processBeanDefinitions处理所有mapper（ setBeanClass(this.mapperFactoryBean.getClass())改变了db的BeanClass，为mapperFactoryBean；definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);自动装配有setXXX函数的属性，不需要@autoWire注解，主要是为了注入DefaultSqlSessionFactory这个SqlSessionFactory， SqlSessionDaoSupport里有setSqlSessionFactory函数，函数里this.sqlSession = new SqlSessionTemplate(sqlSessionFactory)，完成SqlSessionTemplate实例，其中this.sqlSessionProxy = (SqlSession) newProxyInstance(
SqlSessionFactory.class.getClassLoader(),new Class[] { SqlSession.class },new SqlSessionInterceptor());又生成一个代理，InvocationHandler是SqlSessionInterceptor，执行完sql之后closeSqlSession）

#### 实例化MapperFactoryBean
getBean -> MapperFactoryBean.getObject -> getSqlSession().getMapper(this.mapperInterface)（mapperInterface即mapper接口）-> SqlSessionTemplate.getMapper -> MapperRegistry.getMapper（mapperProxyFactory.newInstance(sqlSession)创建mapper接口的代理对象）-> 反射出代理对象Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy)，InvocationHandler为mapperProxy

@Bean sqlSessionFactoryBean

#### 导入sql语句
实例化的时候，将sql放入mappedStatement，MapperFactoryBean extends SqlSessionDaoSupport extentds DaoSupport implements InitializingBean（实现InitializingBean接口，能在bean实例化之后，进入afterPropertiesSet函数，然后调用父类的初始化过程，将sql语句放入sqlMapperedStatements字典）

#### 执行语句
mapper.method -> MapperProxy.invoke -> sqlSession.select -> SqlSessionTemplate.select -> sqlSessionFactory.select -> sqlSessionProxy.select -> DefaultSqlSession.select ->  MappedStatement ms = configuration.getMappedStatement(statement); prepareStatement

sqlSessionTemplate增强defaultSqlSession，执行语句之后，会关闭session，一级缓存会失效


### 接口层

### 数据处理层
#### 参数映射
#### SQL解析
#### SQL执行
#### 结果处理和映射

### 框架支撑层
### 引导层
![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/mybatis.png)

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/mybatis2.png)
---
layout: default
title: nginx&apeche

---

request->nginx->index模块->配置文件->response


1.框架

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/nginx.PNG) 

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/nginx1.jpg) 

	
	struct ngx_cycle_s {
	    void                  ****conf_ctx;
	    ngx_pool_t               *pool;
	
	    ngx_log_t                *log;
	    ngx_log_t                 new_log;
	
	    ngx_connection_t        **files;
	    ngx_connection_t         *free_connections;
	    ngx_uint_t                free_connection_n;
	
	    ngx_array_t               listening;
	    ngx_array_t               pathes;
	    ngx_list_t                open_files;
	    ngx_list_t                shared_memory;
	
	    ngx_uint_t                connection_n;
	    ngx_uint_t                files_n;
	
	    ngx_connection_t         *connections;
	    ngx_event_t              *read_events;
	    ngx_event_t              *write_events;
	
	    ngx_cycle_t              *old_cycle;
	
	    ngx_str_t                 conf_file;
	    ngx_str_t                 conf_param;
	    ngx_str_t                 conf_prefix;
	    ngx_str_t                 prefix;
	    ngx_str_t                 lock_file;
	    ngx_str_t                 hostname;
	};

	cycle = ngx_init_cycle(&init_cycle);
1.1.main函数里调用ngx\_init_cycle初始化一个主进程实例,并创建监听套接字



	ngx_master_process_cycle(cycle);
1.2.创建worker进程

1.3.worker进程竞争accept锁

1.4.accept

1.5.取空闲的连接

	struct ngx_connection_s {
	    void               *data;
	    ngx_event_t        *read;
	    ngx_event_t        *write;
	
	    ngx_socket_t        fd;
	
	    ngx_recv_pt         recv;
	    ngx_send_pt         send;
	    ngx_recv_chain_pt   recv_chain;
	    ngx_send_chain_pt   send_chain;
	
	    ngx_listening_t    *listening;
	
	    off_t               sent;
	
	    ngx_log_t          *log;
	
	    ngx_pool_t         *pool;
	
	    struct sockaddr    *sockaddr;
	    socklen_t           socklen;
	    ngx_str_t           addr_text;
	
	#if (NGX_SSL)
	    ngx_ssl_connection_t  *ssl;
	#endif
	
	    struct sockaddr    *local_sockaddr;
	    socklen_t           local_socklen;
	
	    ngx_buf_t          *buffer;
	
	    ngx_atomic_uint_t   number;
	
	    ngx_uint_t          requests;
	
	    unsigned            buffered:8;
	
	    unsigned            log_error:3;     /* ngx_connection_log_error_e */
	
	    unsigned            single_connection:1;
	    unsigned            unexpected_eof:1;
	    unsigned            timedout:1;
	    unsigned            error:1;
	    unsigned            destroyed:1;
	
	    unsigned            idle:1;
	    unsigned            close:1;
	
	    unsigned            sendfile:1;
	    unsigned            sndlowat:1;
	    unsigned            tcp_nodelay:2;   /* ngx_connection_tcp_nodelay_e */
	    unsigned            tcp_nopush:2;    /* ngx_connection_tcp_nopush_e */
	
	#if (NGX_HAVE_IOCP)
	    unsigned            accept_context_updated:1;
	#endif
	
	#if (NGX_THREADS)
	    ngx_atomic_t        lock;
	#endif
	};


connection

nginx每个socket被封装成connection结构ngx_connection_t，ngx_connection_t里还包含socket的读写事件ngx_event_t，及事件发生时调用的回调函数。

event

ngx_event_t

2.nginx内存管理

2.1.ngx的内存池

3.模块


3.1.1.handlers : 处理客户端请求并产生响应内容,比如ngx_http_static_moudle模块，负责客户端的静态页面请求，并将对应的静态磁盘文件作为响应内容输出.

3.1.2.filters : 对handlers产生的响应内容做各种过滤处理(即增，删，改),比如 ngx_http_not_modify_filter_moudle,如果通过时间判断前后2次请求的响应内容没有发生任何改变,那么可以直接响应"304 Not Modified"状态标识,让客户端使用缓存即可,而原本发送的响应内容将被清除掉.

3.1.3.upstream : 如果存在后端真实的服务器,nginx 可以利用upstream模块充当反向代理的角色，对客户端的请求只负责转发到后端的真实服务器，如ngx_http_proxy_moudle模块.

3.1.4.load-balance : 在nginx充当中间代理时，由于后端真实服务器往往多于一个，对于某一次客户端的请求，如何选择对应的后端真实服务器来进行处理，这就有类似于ngx_http_upstream_ip_hash_module这样的模块来实现不同的负载均衡算法（Load Balance）。


3.1.处理连接事件模块

3.1.ngx_events_module事件模块

nginx只有ngx\_event\_core\_module和ngx\_epoll\_module和其他IO实现类型模块

3.2.一个事件一个事件模块实例ngx_event_module_t

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/nginx1.png) 

4.进程之间的通信

采用socketpair()函数创造一对未命名的unix域套接字来进行主从进程或子进程之间的双向通信

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, ngx_processes[s].channel) == -1)


就目前nginx代码来看，子进程并没有往父进程发送任何消息，子进程之间也没有相互通信的逻辑，也许是因为nginx有其它一些更好的进程通信方式，比如共享内存等，所以这种channel通信目前仅做为父进程往子进程发送消息使用，但由于有这个基础在这，如果未来要使用channel做这样的事情，的确是可以的。

4.1.共享内存

slab访问机制


5.解析配置文件

Reference

[http://www.cnblogs.com/fll369/archive/2012/11/26/2788780.html](http://www.cnblogs.com/fll369/archive/2012/11/26/2788780.html)
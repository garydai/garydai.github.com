---
layout: default
title: KMP

---

##小问题
字符串abcabd  
a的后缀[a, ab, abc, abca, abcab, abcabd]
b的前缀[b,ab]  
求各个字符的前缀与第一个字符a的后缀完全相同的最大长度，例如第二个b的前缀ab与a的后缀ab相同

t[] = abcabd  
p[] = [-1, -1, -1, 0, 1, -1]表示t[i]字符与a的后缀匹配下标  

###递推公式  
如果t[p[i-1] + 1] == p[i]则p[i] = p[i-1] + 1  
如果t[p[i-1] + 1] != p[i]则比较t[p[p[i-1]] + 1] 和 p[i]，不断嵌套直到两者相等，因为p[i-1]能保证得到t[i-1]最长后缀

##正题
字符串s:abcabcabd  
匹配串t:abcabd  
当t[5]'d'匹配到s[5]'c'，匹配失败，  
效率低的方法：  
t向右移一位，然后重新从a开始和s匹配，s,t的下标从0开始  
KMP:  
可以略过t[5-1]的前缀和t[0]后缀相同部分ab，让t向右移动两位,且从c开始匹配，而s的小标也无需改变继续匹配

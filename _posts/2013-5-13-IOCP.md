---
layout: default
title: IOCP

---

##IOCP I/O完成端口

使用线程池处理异步I/O请求的机制

###I/O模型-同步/异步,阻塞/非阻塞
阻塞会挂起线程  
同步表示A完成后才能执行B,两者有依赖关系;异步表示A/B可以同时进行,两者没有联系  
####同步I/O
I/O操作一般有两个不同的阶段：  
1.等待数据数据到达网络，并拷贝到内核的缓冲区(等待数据准备好)。   
2.把内核缓冲区的数据拷贝到应用程序缓冲区。  
**线程只要阻塞在以上任意一个阶段都称为同步I/O**  
阻塞I/O  
![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/blockiomodel.JPG)  
非阻塞I/0  
![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/nonblockingiomodel.JPG)  
I/O复用(select、poll)  
![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/iomultiplexingmodel.JPG)  
信号驱动I/O  
![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/singledriveniomodel.JPG)  
####异步I/O
线程不会阻塞在I/O两个阶段
异步i/O  
![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/AsynchronousIOModel.JPG)  
(boost::asio实现的应该是异步I/0，数据拷贝到应用程序缓冲区的时候才用回调函数通知应用程序)  
###windows 重叠I/O
事件方式：每一个socket操作关联一个重叠结构，一个重叠结构关联一个事件，所以有多少个socket操作就应该有多少个WSAOVERLAPPED结构，有多少个WSAOVERLAPPED结构就应该有多少个WSAEVENT事件  
完成例程：
###IOCP 
###IOCP实现
创建IOCP  
socket关联到IOCP，并说明消息类型和buf  



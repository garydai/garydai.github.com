---
layout: default

title: java thread

---

## java 并发

### c语言thread
#### 创建线程
```
int pthread_create(pthread_t * tid, const pthread_attr_t * attr, void * ( * func) (void * ), void * arg);
其返回值是一个整数，若创建进程成功返回0，否则，返回其他错误代码，也是正整数。
```
#### 结束线程
```
void pthread_exit (void *status);
参数是指针类型，用于存储线程结束后返回状态。
```
#### 线程等待
```
int pthread_join (pthread_t tid, void ** status);

第一个参数表示要等待的进程的id；
第二参数表示要等待的进程的返回状态，是个二级指针。
```
#### 返回当前线程ID
```
pthread_t pthread_self (void);
用于返回当前进程的ID
```
#### 制定线程变成分裂状态
```
int pthread_detach (pthread_t tid);
参数是指定线程的ID，指定的ID的线程变成分离状态；若指定线程是分离状态，则 如果线程退出，那么它所有的资源都将释放，如果线程不是分离状态，线程必须保留它的线程ID、退出状态，直到其他线程对他调用的pthread_join()函数

```
### c语言锁
```
互斥锁
pthread_mutex_t mutex 锁对象
pthread_mutex_init(&mutex,NULL) 在主线程中初始化锁为解锁状态
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER 编译时初始化锁位解锁状态
pthread_mutex_lock(&mutex): 访问临界区加锁操作
pthread_mutex_unlock(&mutex): 访问临界区解锁操作

条件变量
pthread_cond_init
pthread_cond_destroy
pthread_cond_wait
pthread_cond_timedwait
pthread_cond_signal
pthread_cond_broadcast

信号量
int sem_init(sem_t * sem, int pshared, unsigned int value);初始化信号量
int sem_wait(sem_t *sem); 信号量减一操作，有线程申请资源
int sem_post(sem_t *sem);信号量加一操作，有线程释放资源
int sem_destroy(sem_t *sem); 销毁信号量。
```

### thread
#### 中断线程

```
public void run() {
    while (!Thread.currentThread().isInterrupted()&& more work to do) {
        try {
            ...
            sleep(delay);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();//重新设置中断标示
        }
    }
}

抛出InterruptedException异常后，中断标示位会自动清除,所以要重新设置中断表示

```

https://www.cnblogs.com/onlywujun/p/3565082.html

#### 指令重排
```
public class ThreadExample {
    static Thread thread = null;
    int i;
    public volatile static boolean runing = true;

    public static void main(String[] args) throws InterruptedException {
        traditional();
        Thread.sleep(100);
        runing = false;


    }


    public static void traditional() {
        thread = new Thread() {
            @Override
            public void run() {
               while (runing){           
                 //i++;
               }
            }
        };
        thread.start();
    }

public static void aa(){
        Integer i=1;
        i.toString();

    }
}




traditional被重排，running变成函数变量
public static void traditional() {
        bool temp = running;
        thread = new Thread() {
            @Override
            public void run() {
               while (temp){           
                 //i++;
               }
            }
        };
        thread.start();
    }


所以线程不会被中断，一直再运行
```

### lock

#### synchronized（1.6之前都是重量级锁） (monitorenter jvm指令)

java虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现，无论是显式同步(有明确的monitorenter和monitorexit指令,即同步代码块)还是隐式同步都是如此。在Java语言中，同步用的最多的地方可能是被synchronized修饰的同步方法。同步方法并不是由monitorenter和monitorexit指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的ACC_SYNCHRONIZED标志来隐式实现的

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/jvm-mark.png)

当对象状态为偏向锁（biasable）时，mark word存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象（ObjectMonitor）的指针。

当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。

如果一个线程在同步块中调用了Object#wait方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。

设置对象头锁状态，通过cas_set_mark（atomic_cmpxchg_at）解决并发问题

```
atomic_cmpxchg_at(x, p, (ptrdiff_t)offset, e)
if x == *(p+offset) then *(p+offset) = e

同数据库的乐观锁操作，1.get old time value 2.update set new value where now value =old time value
```

```
每个对象都存在着一个monitor与之关联，用于重量级锁

    ObjectMonitor() {
        _header       = NULL;
        _count        = 0; //记录个数
        _waiters      = 0,
        _recursions   = 0;
        _object       = NULL;
        _owner        = NULL; //指向持有锁的线程
        _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
        _WaitSetLock  = 0 ;
        _Responsible  = NULL ;
        _succ         = NULL ;
        _cxq          = NULL ;
        FreeNext      = NULL ;
        _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
        _SpinFreq     = 0 ;
        _SpinClock    = 0 ;
        OwnerIsThread = 0 ;
    }

    线程运行到synchronized时候，会在栈上创建一个BasicObjectLock对象，即对象头里的Lock Record指针指向的地方

    class BasicObjectLock {
        friend class VMStructs;
        private:
        BasicLock _lock;                                    // the lock, must be double word aligned
        oop       _obj;                                     // object holds the lock;

        public:
        // Manipulation
        oop      obj() const                                { return _obj;  }
        void set_obj(oop obj)                               { _obj = obj; }
        BasicLock* lock()                                   { return &_lock; }

        // Note: Use frame::interpreter_frame_monitor_size() for the size of BasicObjectLocks
        //       in interpreter activation frames since it includes machine-specific padding.
        static int size()                                   { return sizeof(BasicObjectLock)/wordSize; }

        // GC support
        void oops_do(OopClosure* f) { f->do_oop(&_obj); }

        static int obj_offset_in_bytes()                    { return offset_of(BasicObjectLock, _obj);  }
        static int lock_offset_in_bytes()                   { return offset_of(BasicObjectLock, _lock); }
    };

    class BasicLock {
        friend class VMStructs;
        friend class JVMCIVMStructs;
        private:
        volatile markOop _displaced_header;
        public:
        markOop      displaced_header() const               { return _displaced_header; }
        void         set_displaced_header(markOop header)   { _displaced_header = header; }

        void print_on(outputStream* st) const;

        // move a basic lock (used during deoptimization
        void move_to(oop obj, BasicLock* dest);

        static int displaced_header_offset_in_bytes()       { return offset_of(BasicLock, _displaced_header); }
    };


    CASE(_monitorenter): {
        oop lockee = STACK_OBJECT(-1); //锁对象
        // derefing's lockee ought to provoke implicit null check
        CHECK_NULL(lockee);
        // find a free monitor or one already allocated for this object
        // if we find a matching object then we need a new monitor
        // since this is recursive enter
        BasicObjectLock* limit = istate->monitor_base();
        BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();
        BasicObjectLock* entry = NULL;
        //找到一个空闲的Lock Record
        while (most_recent != limit ) {
          if (most_recent->obj() == NULL) entry = most_recent;
          else if (most_recent->obj() == lockee) break;
          most_recent++;
        }
        if (entry != NULL) {
          //设置持有该lock record的对象
          entry->set_obj(lockee);
          int success = false;
          uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;

          markOop mark = lockee->mark();
          intptr_t hash = (intptr_t) markOopDesc::no_hash;
          // implies UseBiasedLocking
          if (mark->has_bias_pattern()) {
            uintptr_t thread_ident;
            uintptr_t anticipated_bias_locking_value;
            thread_ident = (uintptr_t)istate->thread();
            anticipated_bias_locking_value =
              (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &
              ~((uintptr_t) markOopDesc::age_mask_in_place);

            if  (anticipated_bias_locking_value == 0) {
              // already biased towards this thread, nothing to do
              if (PrintBiasedLockingStatistics) {
                (* BiasedLocking::biased_lock_entry_count_addr())++;
              }
              success = true;
            }
            else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {
              // try revoke bias
              markOop header = lockee->klass()->prototype_header();
              if (hash != markOopDesc::no_hash) {
                header = header->copy_set_hash(hash);
              }
              if (lockee->cas_set_mark(header, mark) == mark) {
                if (PrintBiasedLockingStatistics)
                  (*BiasedLocking::revoked_lock_entry_count_addr())++;
              }
            }
            else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {
              // try rebias
              markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);
              if (hash != markOopDesc::no_hash) {
                new_header = new_header->copy_set_hash(hash);
              }
              if (lockee->cas_set_mark(new_header, mark) == mark) {
                if (PrintBiasedLockingStatistics)
                  (* BiasedLocking::rebiased_lock_entry_count_addr())++;
              }
              else {
                CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
              }
              success = true;
            }
            else {
              // try to bias towards thread in case object is anonymously biased
              markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place |
                                                              (uintptr_t)markOopDesc::age_mask_in_place |
                                                              epoch_mask_in_place));
              if (hash != markOopDesc::no_hash) {
                header = header->copy_set_hash(hash);
              }
              markOop new_header = (markOop) ((uintptr_t) header | thread_ident);
              // debugging hint
              DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)
              if (lockee->cas_set_mark(new_header, header) == header) {
                if (PrintBiasedLockingStatistics)
                  (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;
              }
              else {
                CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
              }
              success = true;
            }
          }

          // traditional lightweight locking
          if (!success) {
            markOop displaced = lockee->mark()->set_unlocked();
            entry->lock()->set_displaced_header(displaced);
            bool call_vm = UseHeavyMonitors;
            if (call_vm || lockee->cas_set_mark((markOop)entry, displaced) != displaced) {
              // Is it simple recursive case?
              if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {
                entry->lock()->set_displaced_header(NULL);
              } else {
                CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);
              }
            }
          }
          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
        } else {
            // lock recoder不够，则开始栈扩张，stack_base往下移，重新开始执行
          istate->set_msg(more_monitors);
          UPDATE_PC_AND_RETURN(0); // Re-execute
        }
    }

```

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/synchronized.png)


设置偏向锁
![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/synchronized-00.png)
###### 参考
https://blog.51cto.com/14440216/2426781

##### 偏向锁
我们的方法一定要保证线程安全，但是实际情况不一定有互斥， 所以偏向锁是synchronized锁的对象如果没有资源竞争的情况下存在的
 
 偏向锁不会调用os函数实现---第一次会调用

    os函数pthread_mutex_lock()//上锁
    pthread_mutex_lock(){
         fprintf(stderr,"msg"+pthred_self());
    }

##### 轻量级锁
在多线程交替执行同步块的情况下

##### 重量级锁
os函数使用的锁 pthread_mutex_lock


synchronized关键字基于上述两个指令实现了锁的获取和释放过程，解释器执行monitorenter时会进入到InterpreterRuntime.cpp的InterpreterRuntime::monitorenter

偏向锁的入口位于synchronizer.cpp文件的ObjectSynchronizer::fast_enter

#### AQS

### 锁的是对象
 
## os实现mutex
```
lock: 
	if(mutex > 0){ 
		mutex = 0; 
		return 0; 
	} else 
		挂起等待; 
	goto lock;
		
unlock: 
	mutex = 1; 
	唤醒等待Mutex的线程; 
	return 0


判断锁过程不是原子


lock: 
	movb $0, %al 
	xchgb %al, mutex  寄存器和内存单元的数据相交换
	if(al寄存器的内容 > 0){ 
		return 0; 
	} else 
		挂起等待; 
	goto lock;
		
unlock: 
	movb $1, mutex 
	唤醒等待Mutex的线程; 
	return 0;

    一条指令保证原子性



“挂起等待”和“唤醒等待线程”的操作如何实现？每个Mutex有一个等待队列，一个线程要在Mutex上挂起等待，首先把自己加入等待队列中，然后置线程状态为睡眠，接着调用调度器函数切换到别的线程。一个线程要唤醒等待队列中的其它线程，只需从等待队列中取出一项，把它的状态从睡眠改为就绪，加入就绪队列，那么下次调度器函数执行时就有可能切换到被唤醒的线程。


```
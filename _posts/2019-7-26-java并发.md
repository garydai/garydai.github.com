---
layout: default

title: java thread

---

## java 并发

### thread
#### 中断线程

```
public void run() {
    while (!Thread.currentThread().isInterrupted()&& more work to do) {
        try {
            ...
            sleep(delay);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();//重新设置中断标示
        }
    }
}

抛出InterruptedException异常后，中断标示位会自动清除,所以要重新设置中断表示

```

https://www.cnblogs.com/onlywujun/p/3565082.html

#### 指令重排
```
public class ThreadExample {
    static Thread thread = null;
    int i;
    public volatile static boolean runing = true;

    public static void main(String[] args) throws InterruptedException {
        traditional();
        Thread.sleep(100);
        runing = false;


    }


    public static void traditional() {
        thread = new Thread() {
            @Override
            public void run() {
               while (runing){           
                 //i++;
               }
            }
        };
        thread.start();
    }

public static void aa(){
        Integer i=1;
        i.toString();

    }
}




traditional被重排，running变成函数变量
public static void traditional() {
        bool temp = running;
        thread = new Thread() {
            @Override
            public void run() {
               while (temp){           
                 //i++;
               }
            }
        };
        thread.start();
    }


所以线程不会被中断，一直再运行
```

### lock

synchronized（1.6之前都是重量级锁） (monitorenter jvm指令)

 偏向锁：我们的方法一定要保证线程安全，但是实际情况不一定有互斥， 所以偏向锁是synchronized锁的对象如果没有资源竞争的情况下存在的
 
 偏向锁不会调用os函数实现---第一次会调用

    os函数   pthread_mutex_lock()//上锁
    pthread_mutex_lock(){
         fprintf(stderr,"msg"+pthred_self());
    }

 轻量级锁 

 重量级锁 os函数使用的锁 pthread_mutex_lock

 ### 锁的是对象
 
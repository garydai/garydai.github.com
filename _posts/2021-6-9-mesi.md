---
date: 2021-6-9
layout: default
title: mesi

---

# mesi与内存屏障

通过MESI协议，在强制串行化的总线事务帮助下能够始终保持一个全局高速缓存一致的稳定状态。

　　MESI协议依赖总线侦听机制，在某个核心发生本地写事件时，为了保证全局只能有一份缓存数据，要求其它核对应的缓存行统统设置为Invalid无效状态。为了确保总线写事务的强一致性，发生本地写的高速缓存需要等到远端的所有核心都处理完对应的失效缓存行，返回Ack确认消息后才能继续执行下面的内存寻址指令(阻塞)。

**原始MESI协议实现时的性能问题：**

　　1.对于进行本地写事件的核心，远端核心处理失效并进行响应确认相对处理器自身的指令执行速度来说是相当耗时的，在等待所有核心响应的过程中令处理器空转效率并不高。

　　2.对于响应远程写事件的核心，在其高速缓存压力很大时，要求实时的处理失效事件也存在一定的困难，会有一定的延迟。

　　**不进行优化的MESI协议在实际工作中效率会非常的低下，因此CPU的设计者在实现时对MESI协议进行了一定的改良。**

## 存储缓存(Store Bufferes)

　　针对上述本地写事件需要等待远端核心ACK确认，阻塞本地处理器的问题，引入了存储缓存机制。

　　存储缓存是属于每个CPU核心的。当使用了存储缓存后，每当发生本地写事件时，本地核心不再阻塞的等待远程核的确认响应，而是将写入的新值放入存储缓存中，继续执行后面的指令。存储缓存会替处理器接受远端核心的ACK确认，当对应本地写事件广播得到了全部远程核心的确认后，再提交事务，将其新值写入本地高速缓存中。存储缓存的大小是十分有限的，当堆积的事务满了之后，依然会阻塞CPU，直到有事务提交释放出新的空间。

　　**存储缓存的引入将本地写事件--->等待远程写通知确认消息并提交这一事务，从同步、强一致性变成了异步、最终一致性，提高了本地写事件的处理效率。**

　　本地处理器在进行本地读事件时，由于可能存储缓存中新修改的数据还未提交到本地缓存中，这就会造成一个核心内，对于同一缓存行其后续指令的读操作无法读取到之前写操作的最新值。为此，在进行本地读操作时，处理器会先在存储缓存中查询对应记录是否存在，如果存在则会从存储缓存中直接获取，这一机制被称为**Store Fowarding**。

## 失效队列(Invalid Queue)

　　针对上述远端核心响应远程写事件，实时的将对应缓存行设置为Invalid无效状态延迟高的问题，引入了失效队列机制。

　　失效队列同样是属于每个CPU核心的。当使用了失效队列后，每当监听到远程写事件时，对应的高速缓存不再同步的处理失效缓存行后返回ACK确认信息，而是将失效通知存入失效队列，立即返回ACK确认消息。对于失效队列中的写失效通知，会在空闲时逐步的进行处理，将对应的高速缓存中的缓存行设置为无效。失效队列的引入在很大程度上缓解了存储缓存空间有限，容易阻塞的问题。

　　**失效队列的引入将监听到远程写事件处理失效缓存行--->返回ACK确认消息这一事务，从同步、强一致性变成了异步、最终一致性，提高了远程写事件的处理效率。**

## 内存屏障(Memory B**arrier**)

　　存储缓存和失效队列的引入在提升MESI协议实现的性能同时，也带来了一些问题。由于**MESI的高速缓存一致性是建立在强一致性的总线串行事务上的，而存储缓存和失效队列将事务的强一致性弱化为了最终一致性，使得在一些临界点上全局的高速缓存中的数据并不是完全一致的。**

　　对于一般的缓存数据，基于异步最终一致的缓存间数据同步不是大问题。但对于并发程序，多核高速缓存间短暂的不一致将会影响共享数据的可见性，使得并发程序的正确性无法得到可靠保证，这是十分致命的。但CPU在执行指令时，缺失了太多的上下文信息，无法识别出缓存中的内存数据是否是并发程序的共享变量，是否需要舍弃性能进行强一致性的同步。

　　CPU的设计者提供了**内存屏障**机制将对共享变量读写的高速缓存的强一致性控制权交给了程序的编写者或者编译器。

　　内存屏障分为**读屏障**和**写屏障**两种，内存屏障以机器指令的形式进行工作。



### **写屏障**

　　**写屏障用于保证高速缓存间写事务的强一致性。**当CPU执行写屏障指令时，必须强制等待存储缓存中的写事务全部处理完再继续执行后面的指令。相当于将存储缓存中异步处理的本地写事务做了强一致的同步。

　　**写屏障指令执行完后，当前核心位于写屏障执行前的本地写事务全部处理完毕，其它的核心都已经接收到了当前所有的远程写事件的写无效通知。**

### 读屏障

　　**读屏障用于保证高速缓存间读事务的强一致性。**当CPU执行读屏障指令时，必须先将当前处于失效队列中的写无效事务全部处理完，再继续的执行读屏障后面的指令。相当于将异步队列中异步处理的远程写事务做了强一致的同步。　

　　**读屏障指令执行完后，当前核心位于读屏障执行前的远程写无效事务全部处理完毕，对于读屏障之后的共享数据读取会得到最新的值。**　

　　在进行并发程序的开发时，针对关键的任务间共享变量的读写需要使用内存屏障保证其在多核间高速缓存的一致性。在对共享变量的写入指令后，加入写屏障，令新的数据立即对其它核心可见；在对共享变量的读取指令前，加入读屏障，令其能获取最新的共享变量值。

　　通过在指令中的适当位置加入读/写内存屏障，虽然一定程度上降低了效率，但保证了并发程序在多核高速缓存条件下对于共享变量的可见性，是一个很好的折中解决方案。

## 参考

https://www.cnblogs.com/xiaoxiongcanguan/p/13184801.html
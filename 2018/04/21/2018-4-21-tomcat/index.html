<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="tomcat原理Tomcat 的本质其实就是一个 WEB 服务器 + 一个 Servlet 容器，那么它必然需要处理网络的连接与 Servlet 的管理，因此，Tomcat 设计了两个核心组件来实现这两个功能，分别是连接器和容器，连接器用来处理外部网络连接，容器用来处理内部 Servlet。  12345678910111213public class Connector extends Life">
<meta property="og:type" content="article">
<meta property="og:title" content="tomcat">
<meta property="og:url" content="http://yoursite.com/2018/04/21/2018-4-21-tomcat/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="tomcat原理Tomcat 的本质其实就是一个 WEB 服务器 + 一个 Servlet 容器，那么它必然需要处理网络的连接与 Servlet 的管理，因此，Tomcat 设计了两个核心组件来实现这两个功能，分别是连接器和容器，连接器用来处理外部网络连接，容器用来处理内部 Servlet。  12345678910111213public class Connector extends Life">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116091507766.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116093302140.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116103029764.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat1.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116110643376.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116113706003.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116145926938.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191128162252013.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191117103831162.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191118165432478.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191126095336752.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat3.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/connector.jpeg">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat-engine.jpeg">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat-context.jpeg">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat2.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcatnio.png">
<meta property="article:published_time" content="2018-04-20T16:00:00.000Z">
<meta property="article:modified_time" content="2020-01-06T07:17:32.606Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116091507766.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/21/2018-4-21-tomcat/"/>





  <title>tomcat | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/21/2018-4-21-tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">tomcat</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-21T00:00:00+08:00">
                2018-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="tomcat原理"><a href="#tomcat原理" class="headerlink" title="tomcat原理"></a>tomcat原理</h2><p>Tomcat 的本质其实就是一个 WEB 服务器 + 一个 Servlet 容器，那么它必然需要处理网络的连接与 Servlet 的管理，因此，Tomcat 设计了两个核心组件来实现这两个功能，分别是<strong><em>连接器</em></strong>和<strong><em>容器</em></strong>，连接器用来处理外部网络连接，容器用来处理内部 Servlet。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116091507766.png" alt="image-20191116091507766"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span>  </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Coyote protocol handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 协议的handler</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ProtocolHandler protocolHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Coyote adapter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Adapter adapter = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>根据protocol=”HTTP/1.1”，生成ProtocolHandler的子类Http11NioProtocol</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt;</span><br><span class="line">               </span><br><span class="line">http/<span class="number">1.1</span> -&gt; protocolHandlerClassName = <span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Http11NioProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractHttp11JsseProtocol</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Http11NioProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// nioEndpoint 利用nio和reactor模式实现io操作</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> NioEndpoint());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketProcessor</span> <span class="keyword">extends</span> <span class="title">SocketProcessorBase</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">SocketProcessor</span><span class="params">(SocketWrapperBase&lt;NioChannel&gt; socketWrapper, SocketEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(socketWrapper, event);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">          getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 处理连接的handler</span></span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">AbstractEndpoint</span>.<span class="title">Handler</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">     </span><br><span class="line">       	Http11Processor processor = <span class="keyword">new</span> Http11Processor(<span class="keyword">this</span>, adapter);</span><br><span class="line">        processor.process(wrapper, status);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Endpoint 是用来实现 TCP/IP 协议的，Processor 用来实现 HTTP 协议</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116093302140.png" alt="image-20191116093302140"></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116103029764.png" alt="image-20191116103029764"></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat1.png" alt=""></p>
<h2 id="连接池处理任务流程"><a href="#连接池处理任务流程" class="headerlink" title="连接池处理任务流程"></a>连接池处理任务流程</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">org.apache.tomcat.util.net.NioEndpoint.SocketProcessor#doRun-&gt;org.apache.coyote.AbstractProtocol.ConnectionHandler#process-&gt;org.apache.coyote.AbstractProcessorLight#process-&gt;org.apache.coyote.AbstractProcessorLight#process-&gt;org.apache.coyote.http11.Http11Processor#service-&gt;</span><br><span class="line">  </span><br><span class="line">org.apache.catalina.connector.CoyoteAdapter#service（设置request的属于哪个host实例）-&gt;</span><br><span class="line">  </span><br><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke.invoke-&gt;</span><br><span class="line">org.apache.catalina.core.StandardEngineValve#invoke-&gt;</span><br><span class="line">org.apache.catalina.valves.AbstractAccessLogValve#invoke-&gt;</span><br><span class="line">org.apache.catalina.valves.ErrorReportValve#invoke-&gt;</span><br><span class="line">org.apache.catalina.core.StandardHostValve#invoke-&gt;</span><br><span class="line">org.apache.catalina.authenticator.AuthenticatorBase#invoke-&gt;</span><br><span class="line">org.apache.catalina.core.StandardContextValve#invoke-&gt;</span><br><span class="line">org.apache.catalina.core.StandardWrapperValve#invoke-&gt;</span><br><span class="line">org.apache.catalina.core.StandardWrapper#allocate-&gt;</span><br><span class="line">org.apache.catalina.core.StandardWrapper#loadServlet-&gt;</span><br></pre></td></tr></table></figure>

<p>StandardEngineValve</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Select the Host to be used for this Request</span></span><br><span class="line">  			<span class="comment">// 从requets里知道改请求属于哪个host</span></span><br><span class="line">        Host host = request.getHost();</span><br><span class="line">        <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// HTTP 0.9 or HTTP 1.0 request without a host when no default host</span></span><br><span class="line">            <span class="comment">// is defined. This is handled by the CoyoteAdapter.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">            request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ask this Host to process this request</span></span><br><span class="line">        host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>org.apache.catalina.connector.CoyoteAdapter#postParseRequest</p>
<p>从service的host集合中找到匹配当前hostname的<strong>host实例</strong>并找到<strong>uri与wrapper的映射</strong>，并复制到request的MappingData中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connector.getService().getMapper().map(serverName, decodedURI,</span><br><span class="line">                    version, request.getMappingData());</span><br></pre></td></tr></table></figure>



<h4 id="定位servlet"><a href="#定位servlet" class="headerlink" title="定位servlet"></a>定位servlet</h4><p>Mapper 组件里保存了 Web 应用的配置信息，其实就是容器组件与访问路径的映射关系，比如 Host 容器里配置的域名、Context 容器里的 Web 应用路径，以及 Wrapper 容器里 Servlet 映射的路径，你可以想象这些配置信息就是一个多层次的 Map</p>
<p>首先，根据协议和端口号选定 Service 和 Engine。我们知道 Tomcat 的每个连接器都监听不同的端口</p>
<p>然后，根据域名选定 Host。Service 和 Engine 确定后，Mapper 组件通过 URL 中的域名去查找相应的 Host 容器</p>
<p>之后，根据 URL 路径找到 Context 组件。Host 确定以后，Mapper 根据 URL 的路径来匹配相应的 Web 应用的路径</p>
<p>最后，根据 URL 路径找到 Wrapper（Servlet）。Context 确定后，Mapper 再根据web.xml中配置的 Servlet 映射路径来找到具体的 Wrapper 和 Servlet。</p>
<p>Pipeline-Valve 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理</p>
<p>Valve 表示一个处理点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Valve</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface Pipeline extends Contained </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addValve</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getBasic</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBasic</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116110643376.png" alt="image-20191116110643376"></p>
<p>整个调用过程由连接器中的 Adapter 触发的，它会调用 Engine 的第一个 Valve</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Calling the container</span></span><br><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</span><br></pre></td></tr></table></figure>

<h5 id="请求流转过程"><a href="#请求流转过程" class="headerlink" title="请求流转过程"></a>请求流转过程</h5><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116113706003.png" alt="image-20191116113706003"></p>
<h4 id="启动流程图"><a href="#启动流程图" class="headerlink" title="启动流程图"></a>启动流程图</h4><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191116145926938.png" alt="image-20191116145926938"></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191128162252013.png" alt="image-20191128162252013"></p>
<p>Acceptor</p>
<p>Selector</p>
<p>Processor</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191117103831162.png" alt="image-20191117103831162"></p>
<p>ServerSocketChannel 通过 accept() 接受新的连接，accept() 方法返回获得 SocketChannel 对象，然后将 SocketChannel 对象封装在一个 PollerEvent 对象中，并将 PollerEvent 对象压入 Poller 的 Queue 里，这是个典型的“生产者 - 消费者”模式，Acceptor 与 Poller 线程之间通过 Queue 通信。</p>
<h5 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h5><p>Poller 本质是一个 Selector，它内部维护一个 Queue，这个 Queue 定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final SynchronizedQueue&lt;PollerEvent&gt; events &#x3D; new SynchronizedQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>将这些事件注册到select里，进行nio</p>
<h4 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h4><p>Socket acceptor thread<br>Socket poller thread<br>Worker threads pool</p>
<p>Endpoint 组件的主要工作就是处理 I/O，而 NioEndpoint 利用 Java NIO API 实现了多路复用 I/O 模型</p>
<p>tomcat处理请求用的线程池使用无界队列，但重写队列，使得达到核心线程数，也能可以新增线程，主要利用记录当然任务数大于当前线程，就能新建线程</p>
<p>当没有空闲线程，则新建线程，不会添加到队列。（加队列的条件，线程池大小达到最大容量，或有空闲线程）</p>
<p>jdk线程池，没有空闲线程概念，（加队列的条件，线程池大小达到最大容量）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">//线程池调用任务队列的方法时，当前线程数肯定已经大于核心线程数了</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果线程数已经到了最大值，不能创建新线程了，只能把任务添加到任务队列。</span></span><br><span class="line">      <span class="keyword">if</span> (parent.getPoolSize() == parent.getMaximumPoolSize()) </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">          </span><br><span class="line">      <span class="comment">//执行到这里，表明当前线程数大于核心线程数，并且小于最大线程数。</span></span><br><span class="line">      <span class="comment">//表明是可以创建新线程的，那到底要不要创建呢？分两种情况：</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//1. 如果已提交的任务数小于当前线程数，表示还有空闲线程，无需创建新线程</span></span><br><span class="line">      <span class="keyword">if</span> (parent.getSubmittedCount()&lt;=(parent.getPoolSize())) </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">          </span><br><span class="line">      <span class="comment">//2. 如果已提交的任务数大于当前线程数，线程不够用了，返回false去创建新线程</span></span><br><span class="line">      <span class="keyword">if</span> (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          </span><br><span class="line">      <span class="comment">//默认情况下总是把任务添加到任务队列</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部维护一个对象数组,用数组实现栈的功能</span></span><br><span class="line">    <span class="keyword">private</span> Object[] stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法用来归还对象，用synchronized进行线程同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (limit == -<span class="number">1</span> || size &lt; limit) &#123;</span><br><span class="line">                expand();<span class="comment">//对象不够用了，扩展对象数组</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[index] = obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个方法用来获取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T result = (T) stack[index];</span><br><span class="line">        stack[index--] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//扩展对象数组长度，以2倍大小扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> newSize = size * <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (limit != -<span class="number">1</span> &amp;&amp; newSize &gt; limit) &#123;</span><br><span class="line">          newSize = limit;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//扩展策略是创建一个数组长度为原来两倍的新数组</span></span><br><span class="line">      Object[] newStack = <span class="keyword">new</span> Object[newSize];</span><br><span class="line">      <span class="comment">//将老数组对象引用复制到新数组</span></span><br><span class="line">      System.arraycopy(stack, <span class="number">0</span>, newStack, <span class="number">0</span>, size);</span><br><span class="line">      <span class="comment">//将stack指向新数组，老数组可以被GC掉了</span></span><br><span class="line">      stack = newStack;</span><br><span class="line">      size = newSize;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个类加载器都有个父加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//查找一下这个类是不是已经加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有加载过</span></span><br><span class="line">        <span class="keyword">if</span>( c == <span class="keyword">null</span> )&#123;</span><br><span class="line">          <span class="comment">//先委托给父加载器去加载，注意这是个递归调用</span></span><br><span class="line">          <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">              c = parent.loadClass(name);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果父加载器为空，查找Bootstrap加载器是不是加载过了</span></span><br><span class="line">              c = findBootstrapClassOrNull(name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父加载器没加载成功，调用自己的findClass去加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> c；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name)&#123;</span><br><span class="line">       <span class="comment">//1. 根据传入的类名name，到在特定目录下去寻找类文件，把.class文件读入内存</span></span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">       <span class="comment">//2. 调用defineClass将字节数组转成Class对象</span></span><br><span class="line">       <span class="keyword">return</span> defineClass(buf, off, len)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将字节码数组解析成一个Class对象，用native方法实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tomcat 的自定义类加载器 <strong>WebAppClassLoader的WebappClassLoaderBase属性</strong> 打破了双亲委托机制，它首先自己尝试去加载某个类，如果找不到再代理给父类加载器，其目的是优先加载 Web 应用自己定义的类。具体实现就是重写 ClassLoader 的两个方法：findClass 和 loadClass。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 先在Web应用目录下查找类 </span></span><br><span class="line">            clazz = findClassInternal(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2. 如果在本地目录没有找到，交给父加载器去查找</span></span><br><span class="line">            clazz = <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 如果父类也没找到，抛出ClassNotFoundException</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先在 Web 应用本地目录下查找要加载的类。如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器 AppClassLoader。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"> </span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先在本地cache查找该类是否已经加载过</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 从系统类加载器的cache中查找是否加载过</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 尝试用ExtClassLoader类加载器类加载</span></span><br><span class="line">        ClassLoader javaseLoader = getJavaseClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = javaseLoader.loadClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 尝试在本地目录搜索class并加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 尝试用系统类加载器(也就是AppClassLoader)来加载</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6. 上述过程都加载失败，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先在本地目录下加载，为了避免本地目录下的类覆盖 JRE 的核心类，先尝试用 JVM 扩展类加载器 ExtClassLoader 去加载</p>
<p>在stardardContext的startinternal中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getLoader() == <span class="keyword">null</span>) &#123;</span><br><span class="line">  WebappLoader webappLoader = <span class="keyword">new</span> WebappLoader(getParentClassLoader());</span><br><span class="line">  webappLoader.setDelegate(getDelegate());</span><br><span class="line">  setLoader(webappLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在org.apache.catalina.startup.HostConfig#start-&gt;org.apache.catalina.startup.HostConfig#deployDirectory部署webapps下所有文件夹，一个文件夹一个standardContext，并加入standardHost，每个standardContext都会新建WebApploader，达到隔离app的目的</p>
<h6 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h6><p>ExtClassLoader - 本地目录下加载 - 父加载器加载（sharedclassloader）</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191118165432478.png" alt="image-20191118165432478"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CommonClassLoader对应&lt;Tomcat&gt;/common<span class="comment">/*</span></span><br><span class="line"><span class="comment">CatalinaClassLoader对应 &lt;Tomcat &gt;/server/*</span></span><br><span class="line"><span class="comment">SharedClassLoader对应 &lt;Tomcat &gt;/shared/*</span></span><br><span class="line"><span class="comment">WebAppClassloader对应 &lt;Tomcat &gt;/webapps/&lt;app&gt;/WEB-INF/*目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">catalina.properties</span></span><br><span class="line"><span class="comment">common.loader="$&#123;catalina.base&#125;/lib","$&#123;catalina.base&#125;/lib/*.jar","$&#123;catalina.home&#125;/lib","$&#123;catalina.home&#125;/lib/*.jar"</span></span><br><span class="line"><span class="comment">server.loader=</span></span><br><span class="line"><span class="comment">shared.loader=</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClassLoaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">// parent为null，默认设置 getSystemClassLoader()方法返回的ClassLoader 作为其父类，getSystemClassLoader()返回的 ClassLoader 通常就是 AppClassLoader</span></span><br><span class="line">            commonLoader = createClassLoader(<span class="string">"common"</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (commonLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// no config file, default to this loader - we might be in a 'single' env.</span></span><br><span class="line">                commonLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">            catalinaLoader = createClassLoader(<span class="string">"server"</span>, commonLoader);</span><br><span class="line">            sharedLoader = createClassLoader(<span class="string">"shared"</span>, commonLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            log.error(<span class="string">"Class loader creation threw exception"</span>, t);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>Common类加载器，负责加载Tomcat和Web应用都复用的类</p>
<p>Catalina类加载器，负责加载Tomcat专用的类，而这些被加载的类在Web应用中将不可见</p>
<p>Shared类加载器，负责加载Tomcat下所有的Web应用程序都复用的类，而这些被加载的类在Tomcat中将不可见</p>
<p>WebApp类加载器，负责加载具体的某个Web应用程序所使用到的类，而这些被加载的类在Tomcat和其他的Web应用程序都将不可见</p>
<p>Jsp类加载器，每个jsp页面一个类加载器，不同的jsp页面有不同的类加载器，方便实现jsp页面的热插拔</p>
<h4 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h4><p>Wrap组件封装了servlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public synchronized Servlet loadServlet() throws ServletException &#123;</span><br><span class="line">    Servlet servlet;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;1. 创建一个Servlet实例</span><br><span class="line">    servlet &#x3D; (Servlet) instanceManager.newInstance(servletClass);    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;2.调用了Servlet的init方法，这是Servlet规范要求的</span><br><span class="line">    initServlet(servlet);</span><br><span class="line">    </span><br><span class="line">    return servlet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当请求到来时，Context 容器的 BasicValve 会调用 Wrapper 容器中 Pipeline 中的第一个 Valve，然后会调用到 StandardWrapperValve</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.实例化Servlet</span></span><br><span class="line">    servlet = wrapper.allocate();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//2.给当前请求创建一个Filter链</span></span><br><span class="line">    ApplicationFilterChain filterChain =</span><br><span class="line">        ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 调用这个Filter链，Filter链中的最后一个Filter会调用Servlet</span></span><br><span class="line">   filterChain.doFilter(request.getRequest(), response.getResponse());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>连接器是调用 CoyoteAdapter 的 service 方法来处理请求的，而 CoyoteAdapter 会调用容器的 service 方法</p>
<p>当容器的 service 方法返回时，CoyoteAdapter 判断当前的请求是不是异步 Servlet 请求，如果是，就不会销毁 Request 和 Response 对象，也不会把响应信息发到浏览器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//调用容器的service方法处理请求</span></span><br><span class="line">    connector.getService().getContainer().getPipeline().</span><br><span class="line">           getFirst().invoke(request, response);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//如果是异步Servlet请求，仅仅设置一个标志，</span></span><br><span class="line">   <span class="comment">//否则说明是同步Servlet请求，就将响应数据刷到浏览器</span></span><br><span class="line">    <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">        async = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request.finishRequest();</span><br><span class="line">        response.finishResponse();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//如果不是异步Servlet请求，就销毁Request对象和Response对象</span></span><br><span class="line">    <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">        request.recycle();</span><br><span class="line">        response.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过ServiceLoader尝试加载Log的实现类</span></span><br><span class="line">    ServiceLoader&lt;Log&gt; logLoader = ServiceLoader.load(Log<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Constructor&lt;? extends Log&gt; m=<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Log log: logLoader) &#123;</span><br><span class="line">        Class&lt;? extends Log&gt; c=log.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m=c.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException | SecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如何没有定义Log的实现类，discoveredLogConstructor为null</span></span><br><span class="line">    discoveredLogConstructor = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Log <span class="title">getInstance</span><span class="params">(String name)</span> <span class="keyword">throws</span> LogConfigurationException </span>&#123;</span><br><span class="line">    <span class="comment">//如果discoveredLogConstructor为null，也就没有定义Log类，默认用DirectJDKLog（封装了jul）</span></span><br><span class="line">    <span class="keyword">if</span> (discoveredLogConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> DirectJDKLog.getInstance(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> discoveredLogConstructor.newInstance(name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ReflectiveOperationException | IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LogConfigurationException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程池大小选择"><a href="#线程池大小选择" class="headerlink" title="线程池大小选择"></a>线程池大小选择</h5><p>利特尔法则：系统中的请求数 = 请求的到达速率 × 每个请求处理时间</p>
<p>线程池大小 = 每秒请求数 × 平均请求处理时间</p>
<p>线程池大小 = （线程 I/O 阻塞时间 + 线程 CPU 时间 ）/ 线程 CPU 时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//we can't do any checks</span></span><br><span class="line">    <span class="keyword">if</span> (parent==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">    <span class="comment">//we are maxed out on threads, simply queue the object</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getPoolSize() == parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">    <span class="comment">//we have idle threads, just add it to the queue</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getSubmittedCount()&lt;=(parent.getPoolSize())) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">    <span class="comment">//if we have less threads than maximum force creation of a new thread</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//if we reached here, we need to add it to the queue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tomcat工作线程池，如果线程池大小小于最大线程池大小，则不会添加到队列（LinkedBlockingQueue）（和默认的线程池处理不一样，默认的是如果线程池大小等于核心线程池大小的时候，先插入队列，队列满了才添加线程）</p>
<p>如果有空闲线程（parent.getSubmittedCount()&lt;=(parent.getPoolSize())），插入队列，</p>
<p>如果没空闲添加线程</p>
<h4 id="hostconfig"><a href="#hostconfig" class="headerlink" title="hostconfig"></a>hostconfig</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostConfig</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (event.getType().equals(Lifecycle.START_EVENT)) &#123;</span><br><span class="line">            start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;		</span><br><span class="line">		  <span class="keyword">if</span> (host.getDeployOnStartup())</span><br><span class="line">            deployApps();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>standardhost通过事件通知hostconfig加载webapps</p>
<h4 id="contexConfig"><a href="#contexConfig" class="headerlink" title="contexConfig"></a>contexConfig</h4><p>加载解析/WEB-INF/web.xml</p>
<h4 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h4><p>engine，host，context，wrapper；<br>四个容器中每个容器都包含自己的管道对象，管道对象用来存放若干阀门对象，但tomcat会为他们制定一个默认的基础阀门【StandardEngineValve,StandardHostValve,StandardContextValve ,StandardWrapperValve】。四个基础阀门放在各自容器管道的最后一位，用于查找下一级容器的管道.</p>
<h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><p>一个pipeline包含多个Valve，这些阀共分为两类，一类叫基础阀（通过getBasic、setBasic方法调用），一类是普通阀（通过addValve、removeValve调用）。<br>一个管道一般有一个基础阀（通过setBasic添加），可以有0到多个普通阀（通过addValve添加）。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/image-20191126095336752.png" alt="image-20191126095336752"></p>
<p>自定的valve类文件需要发布到CATALINA_HOME/lib目录下而不是应用的发布目录WEB-INF/classes</p>
<h4 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h4><p>初始化阶段standardContext已经保存所有StandardWrapper信息（path和servlet等信息，servlet默认还未实例化）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> Servlet instance = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<p>启动阶段，start service时mapper监听器启动，mapperListener.start();遍历所有Wrapper把path和对应Wrapper信息放入<strong>StandardService的Mapper</strong>中<strong>hostname-&gt;contextList</strong>(WebResourceRoot，context的描述)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addContextVersion</span><span class="params">(String hostName, Host host, String path,</span></span></span><br><span class="line"><span class="function"><span class="params">            String version, Context context, String[] welcomeResources,</span></span></span><br><span class="line"><span class="function"><span class="params">            WebResourceRoot resources, Collection&lt;WrapperMappingInfo&gt; wrappers)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>在mapperLister中注册host，registerHost(host)-&gt;registerContext-&gt;org.apache.catalina.mapper.MapperListener#prepareWrapperMappingInfo</p>
<p>保存path和对应wrapper在WrapperMappingInfo中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerHost</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] aliases = host.findAliases();</span><br><span class="line">        mapper.addHost(host.getName(), aliases, host);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Container container : host.findChildren()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (container.getState().isAvailable()) &#123;</span><br><span class="line">                registerContext((Context) container);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Default host may have changed</span></span><br><span class="line">        findDefaultHost();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">"mapperListener.registerHost"</span>,</span><br><span class="line">                    host.getName(), domain, service));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareWrapperMappingInfo</span><span class="params">(Context context, Wrapper wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;WrapperMappingInfo&gt; wrappers)</span> </span>&#123;</span><br><span class="line">        String wrapperName = wrapper.getName();</span><br><span class="line">        <span class="keyword">boolean</span> resourceOnly = context.isResourceOnlyServlet(wrapperName);</span><br><span class="line">        String[] mappings = wrapper.findMappings();</span><br><span class="line">        <span class="keyword">for</span> (String mapping : mappings) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> jspWildCard = (wrapperName.equals(<span class="string">"jsp"</span>)</span><br><span class="line">                                   &amp;&amp; mapping.endsWith(<span class="string">"/*"</span>));</span><br><span class="line">            wrappers.add(<span class="keyword">new</span> WrapperMappingInfo(mapping, wrapper, jspWildCard,</span><br><span class="line">                    resourceOnly));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperMappingInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mapping;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Wrapper wrapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jspWildCard;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> resourceOnly;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrapperMappingInfo</span><span class="params">(String mapping, Wrapper wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> jspWildCard, <span class="keyword">boolean</span> resourceOnly)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mapping = mapping;</span><br><span class="line">        <span class="keyword">this</span>.wrapper = wrapper;</span><br><span class="line">        <span class="keyword">this</span>.jspWildCard = jspWildCard;</span><br><span class="line">        <span class="keyword">this</span>.resourceOnly = resourceOnly;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h4><p>org.apache.coyote.AbstractProcessorLight#process-&gt;org.apache.coyote.http11.Http11Processor#service-&gt;org.apache.catalina.connector.CoyoteAdapter#service-&gt;engine.getPipeline().getFirst().invoke</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                       request, response);</span><br></pre></td></tr></table></figure>



<p>org.apache.catalina.core.StandardEngineValve#invoke-&gt;org.apache.catalina.valves.AbstractAccessLogValve#invoke-&gt;org.apache.catalina.valves.ErrorReportValve#invoke-&gt;org.apache.catalina.core.StandardHostValve#invoke-&gt;org.apache.catalina.authenticator.AuthenticatorBase#invoke-&gt;org.apache.catalina.core.StandardContextValve#invoke-&gt;org.apache.catalina.core.StandardWrapperValve#invoke-&gt;org.apache.catalina.core.StandardWrapper#allocate-&gt;org.apache.catalina.core.StandardWrapper#loadServlet</p>
<h6 id="路径映射"><a href="#路径映射" class="headerlink" title="路径映射"></a>路径映射</h6><p>org.apache.catalina.connector.CoyoteAdapter#service-&gt;org.apache.catalina.connector.CoyoteAdapter#postParseRequest处理host+uri到wrapper的映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connector.getService().getMapper().map(serverName, decodedURI,</span><br><span class="line">                   version, request.getMappingData());</span><br></pre></td></tr></table></figure>



<h5 id="response"><a href="#response" class="headerlink" title="response"></a>response</h5><p>请求响应时在另一个block-poller线程执行</p>
<p>NioEndpoint对象中维护了一个NioSelecPool对象，这个NioSelectorPool中又维护了一个BlockPoller线程，这个线程就是基于辅Selector进行NIO的逻辑。以执行servlet后，得到response，往socket中写数据为例，最终写的过程调用NioBlockingSelector的write方法</p>
<p>先使用socket的原selector，检测可写事件，如果遇到网络问题，写失败，再丢到上面的BlockPoller线程，使用新的selector写数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer buf, NioChannel socket, <span class="keyword">long</span> writeTimeout,MutableInteger lastWrite)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());  </span><br><span class="line">        <span class="keyword">if</span> ( key == <span class="keyword">null</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Key no longer registered"</span>);  </span><br><span class="line">        KeyAttachment att = (KeyAttachment) key.attachment();  </span><br><span class="line">        <span class="keyword">int</span> written = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">int</span> keycount = <span class="number">1</span>; <span class="comment">//assume we can write  </span></span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis(); <span class="comment">//start the timeout timer  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span> ( (!timedout) &amp;&amp; buf.hasRemaining()) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (keycount &gt; <span class="number">0</span>) &#123; <span class="comment">//only write if we were registered for a write  </span></span><br><span class="line">                    <span class="comment">//直接往socket中写数据  </span></span><br><span class="line">                    <span class="keyword">int</span> cnt = socket.write(buf); <span class="comment">//write the data  </span></span><br><span class="line">                    lastWrite.set(cnt);  </span><br><span class="line">                    <span class="keyword">if</span> (cnt == -<span class="number">1</span>)  </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();  </span><br><span class="line">                    written += cnt;  </span><br><span class="line">                    <span class="comment">//写数据成功，直接进入下一次循环，继续写  </span></span><br><span class="line">                    <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                        time = System.currentTimeMillis(); <span class="comment">//reset our timeout timer  </span></span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">//we successfully wrote, try again without a selector  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//如果写数据返回值cnt等于0，通常是网络不稳定造成的写数据失败  </span></span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    <span class="comment">//开始一个倒数计数器   </span></span><br><span class="line">                    <span class="keyword">if</span> ( att.getWriteLatch()==<span class="keyword">null</span> || att.getWriteLatch().getCount()==<span class="number">0</span>) att.startWriteLatch(<span class="number">1</span>);  </span><br><span class="line">                    <span class="comment">//将socket注册到辅Selector，这里poller就是BlockSelector线程  </span></span><br><span class="line">                    poller.add(att,SelectionKey.OP_WRITE);  </span><br><span class="line">                    <span class="comment">//阻塞，直至超时时间唤醒，或者在还没有达到超时时间，在BlockSelector中唤醒  </span></span><br><span class="line">                    att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS);  </span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException ignore) &#123;  </span><br><span class="line">                    Thread.interrupted();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> ( att.getWriteLatch()!=<span class="keyword">null</span> &amp;&amp; att.getWriteLatch().getCount()&gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    keycount = <span class="number">0</span>;  </span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="comment">//还没超时就唤醒，说明网络状态恢复，继续下一次循环，完成写socket  </span></span><br><span class="line">                    keycount = <span class="number">1</span>;  </span><br><span class="line">                    att.resetWriteLatch();  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> (writeTimeout &gt; <span class="number">0</span> &amp;&amp; (keycount == <span class="number">0</span>))  </span><br><span class="line">                    timedout = (System.currentTimeMillis() - time) &gt;= writeTimeout;  </span><br><span class="line">            &#125; <span class="comment">//while  </span></span><br><span class="line">            <span class="keyword">if</span> (timedout)   </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SocketTimeoutException();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            poller.remove(att,SelectionKey.OP_WRITE);  </span><br><span class="line">            <span class="keyword">if</span> (timedout &amp;&amp; key != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                poller.cancelKey(socket, key);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> written;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="协议解析"><a href="#协议解析" class="headerlink" title="协议解析"></a>协议解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!inputBuffer.parseHeaders()) &#123;</span><br><span class="line">  <span class="comment">// We've read part of the request, don't recycle it</span></span><br><span class="line">  <span class="comment">// instead associate it with the socket</span></span><br><span class="line">  openSocket = <span class="keyword">true</span>;</span><br><span class="line">  readComplete = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (openSocket) &#123;</span><br><span class="line">   <span class="keyword">if</span> (readComplete) &#123;</span><br><span class="line">     <span class="keyword">return</span> SocketState.OPEN;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> SocketState.LONG;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (state == SocketState.OPEN) &#123;</span><br><span class="line">   <span class="comment">// In keep-alive but between requests. OK to recycle</span></span><br><span class="line">   <span class="comment">// processor. Continue to poll for the next request.</span></span><br><span class="line">   connections.remove(socket);</span><br><span class="line">   release(processor);</span><br><span class="line">   wrapper.registerReadInterest();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>数据不完整，等待下个读事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (swallowInput &amp;&amp; (lastActiveFilter != -<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">int</span> extraBytes = (<span class="keyword">int</span>) activeFilters[lastActiveFilter].end();</span><br><span class="line">    byteBuffer.position(byteBuffer.position() - extraBytes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没被消费的body，被吞掉，byteBuffer的位置往前移动，继续等待下次读事件触发</p>
<p>一个 Tomcat 代表一个 Server 服务器，一个 Server 服务器可以包含多个 Service 服务，Tomcat 默认的 Service 服务是 Catalina，而一个 Service 服务可以包含多个连接器，因为 Tomcat 支持多种网络协议，包括 HTTP/1.1、HTTP/2、AJP 等等，一个 Service 服务还会包括一个容器，容器外部会有一层 Engine 引擎所包裹，负责与处理连接器的请求与响应，连接器与容器之间通过 ServletRequest 和 ServletResponse 对象进行交流。</p>
<p>也可以从 server.xml 的配置结构可以看出 tomcat 整体的内部结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Server port&#x3D;&quot;8005&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Service name&#x3D;&quot;Catalina&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Connector connectionTimeout&#x3D;&quot;20000&quot; port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; redirectPort&#x3D;&quot;8443&quot; URIEncoding&#x3D;&quot;UTF-8&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Connector port&#x3D;&quot;8009&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Engine defaultHost&#x3D;&quot;localhost&quot; name&#x3D;&quot;Catalina&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Host appBase&#x3D;&quot;webapps&quot; autoDeploy&#x3D;&quot;true&quot; name&#x3D;&quot;localhost&quot; unpackWARs&#x3D;&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Context docBase&#x3D;&quot;handler-api&quot; path&#x3D;&quot;&#x2F;handler&quot; reloadable&#x3D;&quot;true&quot; source&#x3D;&quot;org.eclipse.jst.jee.server:handler-api&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Host&gt;</span><br><span class="line">    &lt;&#x2F;Engine&gt;</span><br><span class="line">  &lt;&#x2F;Service&gt;</span><br><span class="line">&lt;&#x2F;Server&gt;</span><br></pre></td></tr></table></figure>



<p>Engine：表示一个虚拟主机的引擎，一个 Tomcat Server 只有一个 引擎，连接器所有的请求都交给引擎处理，而引擎则会交给相应的虚拟主机去处理请求；</p>
<p>Host：表示虚拟主机，一个容器可以有多个虚拟主机，每个主机都有对应的域名，在 Tomcat 中，一个 webapps 就代表一个虚拟主机，当然 webapps 可以配置多个；</p>
<p>Context：表示一个应用容器，一个虚拟主机可以拥有多个应用，webapps 中每个目录都代表一个 Context，每个应用可以配置多个 Servlet。</p>
<p>Engine -&gt; Host -&gt; Context -&gt; Wrapper -&gt; Servlet</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat3.png" alt=""></p>
<h3 id="解析webapps所有war包"><a href="#解析webapps所有war包" class="headerlink" title="解析webapps所有war包"></a>解析webapps所有war包</h3><p>解压war包，导入class</p>
<p>读取WEB-INF文件夹里xml配置（或注解（springboot））</p>
<p>类加载servert class</p>
<h3 id="socket网络编程"><a href="#socket网络编程" class="headerlink" title="socket网络编程"></a>socket网络编程</h3><p>一个线程监听连接，另外一个线程处理请求</p>
<h3 id="connector组件"><a href="#connector组件" class="headerlink" title="connector组件"></a>connector组件</h3><p><strong><em>所有请求的入口和出口</em></strong></p>
<p>连接器，监听接口</p>
<p>接受连接请求，分配线程让container来处理这个请求。</p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/connector.jpeg" alt=""></p>
<p>protocol 监听的协议，默认是http/1.1</p>
<p>port 指定服务器端要创建的端口号</p>
<p>minThread服务器启动时创建的处理请求的线程数</p>
<p>maxThread最大可以创建的处理请求的线程数</p>
<p>enableLookups如果为true，则可以通过调用request.getRemoteHost()进行DNS查询来得到远程客户端的实际主机名，若为false则不进行DNS查询，而是返回其ip地址</p>
<p>redirectPort指定服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号</p>
<p>acceptCount指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理</p>
<p>connectionTimeout指定超时的时间数(以毫秒为单位)</p>
<p>SSLEnabled 是否开启 sll 验证，在Https 访问时需要开启。</p>
<h4 id="endpoint-1"><a href="#endpoint-1" class="headerlink" title="endpoint"></a>endpoint</h4><p>默认NioEndpoint，监听端口</p>
<p>生产者，消费者模式</p>
<p>Socket acceptor thread</p>
<p>Socket poller thread</p>
<p>Woker threads pool</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="service组件"><a href="#service组件" class="headerlink" title="service组件"></a>service组件</h3><p>service收集connector</p>
<h3 id="container组件"><a href="#container组件" class="headerlink" title="container组件"></a>container组件</h3><p>通用容器，包括以下容器</p>
<h4 id="engine"><a href="#engine" class="headerlink" title="engine"></a>engine</h4><p>servlet引擎（责任链模式）</p>
<p>An Engine represents the entry point (within Catalina) that processes every request.  The Engine implementation for Tomcat stand alone analyzes the HTTP headers included with the request, and passes them on to the appropriate Host (virtual host).</p>
<p>处理请求，把请求分配到对应的host</p>
<h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><p>主机</p>
<h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>webapp</p>
<h4 id="wrapper"><a href="#wrapper" class="headerlink" title="wrapper"></a>wrapper</h4><p>Servlet</p>
<h3 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h3><p>线程池</p>
<h4 id="processor"><a href="#processor" class="headerlink" title="processor"></a>processor</h4><h4 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h4><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><h4 id="lifecycle生命周期"><a href="#lifecycle生命周期" class="headerlink" title="lifecycle生命周期"></a>lifecycle生命周期</h4><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><p>catalina -&gt; server -&gt; (service1 service2 …)</p>
<p>service -&gt; (engine connector1 connector2 …)</p>
<p>engine -&gt; host -&gt; context -&gt; wrapper</p>
<h3 id="三个类加载器"><a href="#三个类加载器" class="headerlink" title="三个类加载器"></a>三个类加载器</h3><p>Common ClassLoader</p>
<p>Catalina ClassLoader</p>
<p>Shared ClassLoader</p>
<h3 id="io模型"><a href="#io模型" class="headerlink" title="io模型"></a>io模型</h3><h4 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h4><p>一个acceptor线程</p>
<p>两个Poller多路复用线程，调用selector.select(timeout)函数</p>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><ol>
<li>http-nio-8080-BlockPoller — NioBlockingSelector</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">org.apache.tomcat.util.net.NioBlockingSelector.BlockPoller</span><br><span class="line">  </span><br><span class="line">												if (sk.isReadable()) &#123;</span><br><span class="line">                              countDown(socketWrapper.getReadLatch());</span><br><span class="line">                          &#125;</span><br><span class="line">                          if (sk.isWritable()) &#123;</span><br><span class="line">                              countDown(socketWrapper.getWriteLatch());</span><br><span class="line">                          &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Ajp-nio-8009-BlockPoller 处理request</p>
</li>
<li><p>Http-nio-8080-Acceptor一个监听线程</p>
</li>
<li><p>Http-nio-8080-ClientPoller poller线程</p>
</li>
<li><p>http-nio-8080-exec-n处理request的线程池中的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一次连接countUpOrAwaitConnection（latch.countUpOrAwait），一共10000个latch</span><br><span class="line">使用aqs同步10000个AtomicLong count</span><br><span class="line"></span><br><span class="line">LimitLatch&#123;</span><br><span class="line">	private class Sync extends AbstractQueuedSynchronizer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   pollerEvent事件</p>
<p>   poller线程</p>
<ol>
<li>poller线程不断从events队列里取pollerEvent事件，并执行事件（hasEvents = events()，pollerEvent.run()，run里执行逻辑是：如果pollerEvent是OP_REGISTER，则把read socket注册到Selector）</li>
<li>keyCount = selector.selectNow();selector.select(selectorTimeout)等待read事件</li>
<li></li>
</ol>
<p>   监听到一个请求之后，把socket发送给poller</p>
<p>   poller从events工作队列里拿pollerEvent，把socket赋值给event，然后添加到events工作队列，</p>
<p>线程池角度：pollerevent是任务放在线程池子里，poller是消费者，不断取event</p>
<h3 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line">  contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line">  this work for additional information regarding copyright ownership.</span><br><span class="line">  The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line">  (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line">  the License.  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">      http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0</span><br><span class="line"></span><br><span class="line">  Unless required by applicable law or agreed to in writing, software</span><br><span class="line">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">  See the License for the specific language governing permissions and</span><br><span class="line">  limitations under the License.</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!-- Note:  A &quot;Server&quot; is not itself a &quot;Container&quot;, so you may not</span><br><span class="line">     define subcomponents such as &quot;Valves&quot; at this level.</span><br><span class="line">     Documentation at &#x2F;docs&#x2F;config&#x2F;server.html</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;Server port&#x3D;&quot;8005&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt;</span><br><span class="line">  &lt;Listener className&#x3D;&quot;org.apache.catalina.startup.VersionLoggerListener&quot; &#x2F;&gt;</span><br><span class="line">  &lt;!-- Security listener. Documentation at &#x2F;docs&#x2F;config&#x2F;listeners.html</span><br><span class="line">  &lt;Listener className&#x3D;&quot;org.apache.catalina.security.SecurityListener&quot; &#x2F;&gt;</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;!--APR library loader. Documentation at &#x2F;docs&#x2F;apr.html --&gt;</span><br><span class="line">  &lt;Listener className&#x3D;&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine&#x3D;&quot;on&quot; &#x2F;&gt;</span><br><span class="line">  &lt;!-- Prevent memory leaks due to use of particular java&#x2F;javax APIs--&gt;</span><br><span class="line">  &lt;Listener className&#x3D;&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; &#x2F;&gt;</span><br><span class="line">  &lt;Listener className&#x3D;&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; &#x2F;&gt;</span><br><span class="line">  &lt;Listener className&#x3D;&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Global JNDI resources</span><br><span class="line">       Documentation at &#x2F;docs&#x2F;jndi-resources-howto.html</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;GlobalNamingResources&gt;</span><br><span class="line">    &lt;!-- Editable user database that can also be used by</span><br><span class="line">         UserDatabaseRealm to authenticate users</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;Resource name&#x3D;&quot;UserDatabase&quot; auth&#x3D;&quot;Container&quot;</span><br><span class="line">              type&#x3D;&quot;org.apache.catalina.UserDatabase&quot;</span><br><span class="line">              description&#x3D;&quot;User database that can be updated and saved&quot;</span><br><span class="line">              factory&#x3D;&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span><br><span class="line">              pathname&#x3D;&quot;conf&#x2F;tomcat-users.xml&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;GlobalNamingResources&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- A &quot;Service&quot; is a collection of one or more &quot;Connectors&quot; that share</span><br><span class="line">       a single &quot;Container&quot; Note:  A &quot;Service&quot; is not itself a &quot;Container&quot;,</span><br><span class="line">       so you may not define subcomponents such as &quot;Valves&quot; at this level.</span><br><span class="line">       Documentation at &#x2F;docs&#x2F;config&#x2F;service.html</span><br><span class="line">   --&gt;</span><br><span class="line">  &lt;Service name&#x3D;&quot;Catalina&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Executor name&#x3D;&quot;tomcatThreadPool&quot; namePrefix&#x3D;&quot;catalina-exec-&quot;</span><br><span class="line">        maxThreads&#x3D;&quot;150&quot; minSpareThreads&#x3D;&quot;4&quot;&#x2F;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- A &quot;Connector&quot; represents an endpoint by which requests are received</span><br><span class="line">         and responses are returned. Documentation at :</span><br><span class="line">         Java HTTP Connector: &#x2F;docs&#x2F;config&#x2F;http.html</span><br><span class="line">         Java AJP  Connector: &#x2F;docs&#x2F;config&#x2F;ajp.html</span><br><span class="line">         APR (HTTP&#x2F;AJP) Connector: &#x2F;docs&#x2F;apr.html</span><br><span class="line">         Define a non-SSL&#x2F;TLS HTTP&#x2F;1.1 Connector on port 8080</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Connector executor&#x3D;&quot;tomcatThreadPool&quot;</span><br><span class="line">               port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- Define a SSL&#x2F;TLS HTTP&#x2F;1.1 Connector on port 8443</span><br><span class="line">         This connector uses the NIO implementation. The default</span><br><span class="line">         SSLImplementation will depend on the presence of the APR&#x2F;native</span><br><span class="line">         library and the useOpenSSL attribute of the</span><br><span class="line">         AprLifecycleListener.</span><br><span class="line">         Either JSSE or OpenSSL style configuration may be used regardless of</span><br><span class="line">         the SSLImplementation selected. JSSE style configuration is used below.</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span><br><span class="line">               maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot;&gt;</span><br><span class="line">        &lt;SSLHostConfig&gt;</span><br><span class="line">            &lt;Certificate certificateKeystoreFile&#x3D;&quot;conf&#x2F;localhost-rsa.jks&quot;</span><br><span class="line">                         type&#x3D;&quot;RSA&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;SSLHostConfig&gt;</span><br><span class="line">    &lt;&#x2F;Connector&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- Define a SSL&#x2F;TLS HTTP&#x2F;1.1 Connector on port 8443 with HTTP&#x2F;2</span><br><span class="line">         This connector uses the APR&#x2F;native implementation which always uses</span><br><span class="line">         OpenSSL for TLS.</span><br><span class="line">         Either JSSE or OpenSSL style configuration may be used. OpenSSL style</span><br><span class="line">         configuration is used below.</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br><span class="line">               maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; &gt;</span><br><span class="line">        &lt;UpgradeProtocol className&#x3D;&quot;org.apache.coyote.http2.Http2Protocol&quot; &#x2F;&gt;</span><br><span class="line">        &lt;SSLHostConfig&gt;</span><br><span class="line">            &lt;Certificate certificateKeyFile&#x3D;&quot;conf&#x2F;localhost-rsa-key.pem&quot;</span><br><span class="line">                         certificateFile&#x3D;&quot;conf&#x2F;localhost-rsa-cert.pem&quot;</span><br><span class="line">                         certificateChainFile&#x3D;&quot;conf&#x2F;localhost-rsa-chain.pem&quot;</span><br><span class="line">                         type&#x3D;&quot;RSA&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;SSLHostConfig&gt;</span><br><span class="line">    &lt;&#x2F;Connector&gt;</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8009&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- An Engine represents the entry point (within Catalina) that processes</span><br><span class="line">         every request.  The Engine implementation for Tomcat stand alone</span><br><span class="line">         analyzes the HTTP headers included with the request, and passes them</span><br><span class="line">         on to the appropriate Host (virtual host).</span><br><span class="line">         Documentation at &#x2F;docs&#x2F;config&#x2F;engine.html --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- You should set jvmRoute to support load-balancing via AJP ie :</span><br><span class="line">    &lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot; jvmRoute&#x3D;&quot;jvm1&quot;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--For clustering, please take a look at documentation at:</span><br><span class="line">          &#x2F;docs&#x2F;cluster-howto.html  (simple how to)</span><br><span class="line">          &#x2F;docs&#x2F;config&#x2F;cluster.html (reference documentation) --&gt;</span><br><span class="line">      &lt;!--</span><br><span class="line">      &lt;Cluster className&#x3D;&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;&#x2F;&gt;</span><br><span class="line">      --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords</span><br><span class="line">           via a brute-force attack --&gt;</span><br><span class="line">      &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</span><br><span class="line">        &lt;!-- This Realm uses the UserDatabase configured in the global JNDI</span><br><span class="line">             resources under the key &quot;UserDatabase&quot;.  Any edits</span><br><span class="line">             that are performed against this UserDatabase are immediately</span><br><span class="line">             available for use by the Realm.  --&gt;</span><br><span class="line">        &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span><br><span class="line">               resourceName&#x3D;&quot;UserDatabase&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Realm&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Host name&#x3D;&quot;localhost&quot;  appBase&#x3D;&quot;webapps&quot;</span><br><span class="line">            unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- SingleSignOn valve, share authentication between web applications</span><br><span class="line">             Documentation at: &#x2F;docs&#x2F;config&#x2F;valve.html --&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        &lt;Valve className&#x3D;&quot;org.apache.catalina.authenticator.SingleSignOn&quot; &#x2F;&gt;</span><br><span class="line">        --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Access log processes all example.</span><br><span class="line">             Documentation at: &#x2F;docs&#x2F;config&#x2F;valve.html</span><br><span class="line">             Note: The pattern used is equivalent to using pattern&#x3D;&quot;common&quot; --&gt;</span><br><span class="line">        &lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;</span><br><span class="line">               prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;</span><br><span class="line">               pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;&#x2F;Host&gt;</span><br><span class="line">    &lt;&#x2F;Engine&gt;</span><br><span class="line">  &lt;&#x2F;Service&gt;</span><br><span class="line">&lt;&#x2F;Server&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server</span><br><span class="line">    service</span><br><span class="line">        Connector</span><br><span class="line">        engine</span><br><span class="line">            host</span><br><span class="line">            		context</span><br><span class="line">                Valve</span><br><span class="line">            Realm</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat-engine.jpeg" alt=""></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat-context.jpeg" alt=""></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat.png" alt=""></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcat2.png" alt=""></p>
<p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/tomcatnio.png" alt=""></p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://www.processon.com/view/link/5d75f8a7e4b04a19501b07d5" target="_blank" rel="noopener">https://www.processon.com/view/link/5d75f8a7e4b04a19501b07d5</a></p>
<p><a href="https://www.jianshu.com/p/76ff17bc6dea" target="_blank" rel="noopener">https://www.jianshu.com/p/76ff17bc6dea</a></p>
<p><a href="http://objcoding.com/2019/05/30/tomcat-architecture/" target="_blank" rel="noopener">http://objcoding.com/2019/05/30/tomcat-architecture/</a></p>
<p><a href="https://time.geekbang.org/column/article/96764" target="_blank" rel="noopener">https://time.geekbang.org/column/article/96764</a></p>
<p><a href="https://www.cnblogs.com/haimishasha/p/10740606.html" target="_blank" rel="noopener">https://www.cnblogs.com/haimishasha/p/10740606.html</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/21/2018-3-21-select-poll-epoll/" rel="next" title="select / poll / epoll">
                <i class="fa fa-chevron-left"></i> select / poll / epoll
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/30/2018-4-30-web-program/" rel="prev" title="网络编程">
                网络编程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">271</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#tomcat原理"><span class="nav-number">1.</span> <span class="nav-text">tomcat原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接池处理任务流程"><span class="nav-number">2.</span> <span class="nav-text">连接池处理任务流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定位servlet"><span class="nav-number">2.0.1.</span> <span class="nav-text">定位servlet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#请求流转过程"><span class="nav-number">2.0.1.1.</span> <span class="nav-text">请求流转过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动流程图"><span class="nav-number">2.0.2.</span> <span class="nav-text">启动流程图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Poller"><span class="nav-number">2.0.2.1.</span> <span class="nav-text">Poller</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#endpoint"><span class="nav-number">2.0.3.</span> <span class="nav-text">endpoint</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象池"><span class="nav-number">2.0.3.1.</span> <span class="nav-text">对象池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派"><span class="nav-number">2.0.4.</span> <span class="nav-text">双亲委派</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#加载顺序"><span class="nav-number">2.0.4.0.1.</span> <span class="nav-text">加载顺序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#servlet"><span class="nav-number">2.0.5.</span> <span class="nav-text">servlet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logger"><span class="nav-number">2.0.6.</span> <span class="nav-text">logger</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#线程池大小选择"><span class="nav-number">2.0.6.1.</span> <span class="nav-text">线程池大小选择</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hostconfig"><span class="nav-number">2.0.7.</span> <span class="nav-text">hostconfig</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#contexConfig"><span class="nav-number">2.0.8.</span> <span class="nav-text">contexConfig</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pipeline"><span class="nav-number">2.0.9.</span> <span class="nav-text">pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#分类"><span class="nav-number">2.0.9.0.1.</span> <span class="nav-text">分类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mapper"><span class="nav-number">2.0.10.</span> <span class="nav-text">mapper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求处理"><span class="nav-number">2.0.11.</span> <span class="nav-text">请求处理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#路径映射"><span class="nav-number">2.0.11.0.1.</span> <span class="nav-text">路径映射</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#response"><span class="nav-number">2.0.11.1.</span> <span class="nav-text">response</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协议解析"><span class="nav-number">2.0.12.</span> <span class="nav-text">协议解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析webapps所有war包"><span class="nav-number">2.1.</span> <span class="nav-text">解析webapps所有war包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket网络编程"><span class="nav-number">2.2.</span> <span class="nav-text">socket网络编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#connector组件"><span class="nav-number">2.3.</span> <span class="nav-text">connector组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#endpoint-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">endpoint</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">2.3.2.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#service组件"><span class="nav-number">2.4.</span> <span class="nav-text">service组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#container组件"><span class="nav-number">2.5.</span> <span class="nav-text">container组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#engine"><span class="nav-number">2.5.1.</span> <span class="nav-text">engine</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#host"><span class="nav-number">2.5.2.</span> <span class="nav-text">host</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#context"><span class="nav-number">2.5.3.</span> <span class="nav-text">context</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wrapper"><span class="nav-number">2.5.4.</span> <span class="nav-text">wrapper</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#executor"><span class="nav-number">2.6.</span> <span class="nav-text">executor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#processor"><span class="nav-number">2.6.1.</span> <span class="nav-text">processor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#protocol"><span class="nav-number">2.6.2.</span> <span class="nav-text">protocol</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动"><span class="nav-number">2.7.</span> <span class="nav-text">启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lifecycle生命周期"><span class="nav-number">2.7.1.</span> <span class="nav-text">lifecycle生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">2.7.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动-1"><span class="nav-number">2.7.3.</span> <span class="nav-text">启动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三个类加载器"><span class="nav-number">2.8.</span> <span class="nav-text">三个类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io模型"><span class="nav-number">2.9.</span> <span class="nav-text">io模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nio"><span class="nav-number">2.9.1.</span> <span class="nav-text">nio</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程创建"><span class="nav-number">2.10.</span> <span class="nav-text">线程创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#层级"><span class="nav-number">2.11.</span> <span class="nav-text">层级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reference"><span class="nav-number">2.12.</span> <span class="nav-text">reference</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Twisted | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="##Twisted reactor+deferred 没使用reactor的异步客户端  # This is the asynchronous Get Poetry Now! client.  import datetime, errno, optparse, select, socket   def parse_args():     usage &#x3D; &quot;&quot;&quot;usag">
<meta property="og:type" content="article">
<meta property="og:title" content="Twisted">
<meta property="og:url" content="http://yoursite.com/2015/02/15/2015-2-15-Twisted/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="##Twisted reactor+deferred 没使用reactor的异步客户端  # This is the asynchronous Get Poetry Now! client.  import datetime, errno, optparse, select, socket   def parse_args():     usage &#x3D; &quot;&quot;&quot;usag">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted.PNG">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted.PNG">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted2.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted3.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted4.png">
<meta property="article:published_time" content="2015-02-14T16:00:00.000Z">
<meta property="article:modified_time" content="2020-01-06T07:17:32.494Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted.PNG">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="default-2015-2-15-Twisted" class="article article-type-default" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/15/2015-2-15-Twisted/" class="article-date">
  <time datetime="2015-02-14T16:00:00.000Z" itemprop="datePublished">2015-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Twisted
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##Twisted</p>
<p>reactor+deferred</p>
<pre><code>没使用reactor的异步客户端

# This is the asynchronous Get Poetry Now! client.

import datetime, errno, optparse, select, socket


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, asynchronous edition.
Run it like this:
  python get-poetry.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python async-client/get-poetry.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


def get_poetry(sockets):
    &quot;&quot;&quot;Download poety from all the given sockets.&quot;&quot;&quot;

    poems = dict.fromkeys(sockets, &apos;&apos;) # socket -&gt; accumulated poem

    # socket -&gt; task numbers
    sock2task = dict([(s, i + 1) for i, s in enumerate(sockets)])

    sockets = list(sockets) # make a copy

    # we go around this loop until we&apos;ve gotten all the poetry
    # from all the sockets. This is the &apos;reactor loop&apos;.

    while sockets:
        # this select call blocks until one or more of the
        # sockets is ready for read I/O
        rlist, _, _ = select.select(sockets, [], [])

        # rlist is the list of sockets with data ready to read

        for sock in rlist:
            data = &apos;&apos;

            while True:
                try:
                    new_data = sock.recv(1024)
                except socket.error, e:
                    if e.args[0] == errno.EWOULDBLOCK:
                        # this error code means we would have
                        # blocked if the socket was blocking.
                        # instead we skip to the next socket
                        break
                    raise
                else:
                    if not new_data:
                        break
                    else:
                        data += new_data

            # Each execution of this inner loop corresponds to
            # working on one asynchronous task in Figure 3 here:
            # http://krondo.com/?p=1209#figure3

            task_num = sock2task[sock]

            if not data:
                sockets.remove(sock)
                sock.close()
                print &apos;Task %d finished&apos; % task_num
            else:
                addr_fmt = format_address(sock.getpeername())
                msg = &apos;Task %d: got %d bytes of poetry from %s&apos;
                print  msg % (task_num, len(data), addr_fmt)

            poems[sock] += data

    return poems


def connect(address):
    &quot;&quot;&quot;Connect to the given server and return a non-blocking socket.&quot;&quot;&quot;

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(address)
    sock.setblocking(0)
    return sock


def format_address(address):
    host, port = address
    return &apos;%s:%s&apos; % (host or &apos;127.0.0.1&apos;, port)


def main():
    addresses = parse_args()

    start = datetime.datetime.now()

    sockets = map(connect, addresses)

    poems = get_poetry(sockets)

    elapsed = datetime.datetime.now() - start

    for i, sock in enumerate(sockets):
        print &apos;Task %d: %d bytes of poetry&apos; % (i + 1, len(poems[sock]))

    print &apos;Got %d poems in %s&apos; % (len(addresses), elapsed)


if __name__ == &apos;__main__&apos;:
    main()


twisted异步客户端
    # This is the Twisted Get Poetry Now! client, version 1.0.

# NOTE: This should not be used as the basis for production code.
# It uses low-level Twisted APIs as a learning exercise.

import datetime, errno, optparse, socket

from twisted.internet import main


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, Twisted version 1.0.
Run it like this:
  python get-poetry.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python twisted-client-1/get-poetry.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


class PoetrySocket(object):

    poem = &apos;&apos;

    def __init__(self, task_num, address):
        self.task_num = task_num
        self.address = address
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect(address)
        self.sock.setblocking(0)

        # tell the Twisted reactor to monitor this socket for reading
        from twisted.internet import reactor
        reactor.addReader(self)

    def fileno(self):
        try:
            return self.sock.fileno()
        except socket.error:
            return -1

    def connectionLost(self, reason):
        self.sock.close()

        # stop monitoring this socket
        from twisted.internet import reactor
        reactor.removeReader(self)

        # see if there are any poetry sockets left
        for reader in reactor.getReaders():
            if isinstance(reader, PoetrySocket):
                return

        reactor.stop() # no more poetry

    def doRead(self):
        bytes = &apos;&apos;

        while True:
            try:
                bytesread = self.sock.recv(1024)
                if not bytesread:
                    break
                else:
                    bytes += bytesread
            except socket.error, e:
                if e.args[0] == errno.EWOULDBLOCK:
                    break
                return main.CONNECTION_LOST

        if not bytes:
            print &apos;Task %d finished&apos; % self.task_num
            return main.CONNECTION_DONE
        else:
            msg = &apos;Task %d: got %d bytes of poetry from %s&apos;
            print  msg % (self.task_num, len(bytes), self.format_addr())

        self.poem += bytes

    def logPrefix(self):
        return &apos;poetry&apos;

    def format_addr(self):
        host, port = self.address
        return &apos;%s:%s&apos; % (host or &apos;127.0.0.1&apos;, port)


def poetry_main():
    addresses = parse_args()

    start = datetime.datetime.now()

    sockets = [PoetrySocket(i + 1, addr) for i, addr in enumerate(addresses)]

    from twisted.internet import reactor
    reactor.run()

    elapsed = datetime.datetime.now() - start

    for i, sock in enumerate(sockets):
        print &apos;Task %d: %d bytes of poetry&apos; % (i + 1, len(sock.poem))

    print &apos;Got %d poems in %s&apos; % (len(addresses), elapsed)


if __name__ == &apos;__main__&apos;:
    poetry_main()</code></pre><p>IReactorFDSet是一个Twisted的reactor实现的接口</p>
<p>epollreactor</p>
<pre><code>def doPoll(self, timeout):
     &quot;&quot;&quot;
     Poll the poller for new events.
     &quot;&quot;&quot;
     if timeout is None:
         timeout = -1  # Wait indefinitely.

     try:
         # Limit the number of events to the number of io objects we&apos;re
         # currently tracking (because that&apos;s maybe a good heuristic) and
         # the amount of time we block to the value specified by our
         # caller.
         l = self._poller.poll(timeout, len(self._selectables))
     except IOError as err:
         if err.errno == errno.EINTR:
             return
         # See epoll_wait(2) for documentation on the other conditions
         # under which this can fail.  They can only be due to a serious
         # programming error on our part, so let&apos;s just announce them
         # loudly.
         raise

     _drdw = self._doReadOrWrite
     for fd, event in l:
         try:
             selectable = self._selectables[fd]
         except KeyError:
             pass
         else:
             log.callWithLogger(selectable, _drdw, selectable, fd, event)</code></pre><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted.PNG" alt=""></p>
<p>run</p>
<p>回调函数的实现，通过传入类，重写基类的函数</p>
<p>有很多抽象类</p>
<p>有关socket的操作由Protocol类完成，抽象了底层，提供操作数据流的接口，即实现数据协议</p>
<pre><code># This is the Twisted Get Poetry Now! client, version 2.0.

# NOTE: This should not be used as the basis for production code.

import datetime, optparse

from twisted.internet.protocol import Protocol, ClientFactory


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, Twisted version 2.0.
Run it like this:
  python get-poetry.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python twisted-client-2/get-poetry.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


class PoetryProtocol(Protocol):

    poem = &apos;&apos;
    task_num = 0

    def dataReceived(self, data):
        self.poem += data
        msg = &apos;Task %d: got %d bytes of poetry from %s&apos;
        print  msg % (self.task_num, len(data), self.transport.getPeer())

    def connectionLost(self, reason):
        self.poemReceived(self.poem)

    def poemReceived(self, poem):
        self.factory.poem_finished(self.task_num, poem)


class PoetryClientFactory(ClientFactory):

    task_num = 1

    protocol = PoetryProtocol # tell base class what proto to build

    def __init__(self, poetry_count):
        self.poetry_count = poetry_count
        self.poems = {} # task num -&gt; poem

    def buildProtocol(self, address):
        proto = ClientFactory.buildProtocol(self, address)
        proto.task_num = self.task_num
        self.task_num += 1
        return proto

    def poem_finished(self, task_num=None, poem=None):
        if task_num is not None:
            self.poems[task_num] = poem

        self.poetry_count -= 1

        if self.poetry_count == 0:
            self.report()
            from twisted.internet import reactor
            reactor.stop()

    def report(self):
        for i in self.poems:
            print &apos;Task %d: %d bytes of poetry&apos; % (i, len(self.poems[i]))

    def clientConnectionFailed(self, connector, reason):
        print &apos;Failed to connect to:&apos;, connector.getDestination()
        self.poem_finished()


def poetry_main():
    addresses = parse_args()

    start = datetime.datetime.now()

    factory = PoetryClientFactory(len(addresses))

    from twisted.internet import reactor

    for address in addresses:
        host, port = address
        reactor.connectTCP(host, port, factory)

    reactor.run()

    elapsed = datetime.datetime.now() - start

    print &apos;Got %d poems in %s&apos; % (len(addresses), elapsed)


if __name__ == &apos;__main__&apos;:
    poetry_main()


 reactor.connectTCP(host, port, factory)-&gt; buildProtocol(self, address):</code></pre><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted.PNG" alt=""></p>
<p>加入Transports，Protocols</p>
<pre><code># This is the Twisted Get Poetry Now! client, version 2.0.

# NOTE: This should not be used as the basis for production code.

import datetime, optparse

from twisted.internet.protocol import Protocol, ClientFactory


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, Twisted version 2.0.
Run it like this:
  python get-poetry.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python twisted-client-2/get-poetry.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


class PoetryProtocol(Protocol):处理接收的数据

    poem = &apos;&apos;
    task_num = 0

    def dataReceived(self, data):
        self.poem += data
        msg = &apos;Task %d: got %d bytes of poetry from %s&apos;
        print  msg % (self.task_num, len(data), self.transport.getPeer())

    def connectionLost(self, reason):
        self.poemReceived(self.poem)

    def poemReceived(self, poem):
        self.factory.poem_finished(self.task_num, poem)


class PoetryClientFactory(ClientFactory):

    task_num = 1

    protocol = PoetryProtocol # tell base class what proto to build

    def __init__(self, poetry_count):
        self.poetry_count = poetry_count
        self.poems = {} # task num -&gt; poem

    def buildProtocol(self, address):
        proto = ClientFactory.buildProtocol(self, address)
        proto.task_num = self.task_num
        self.task_num += 1
        return proto

    def poem_finished(self, task_num=None, poem=None):
        if task_num is not None:
            self.poems[task_num] = poem

        self.poetry_count -= 1

        if self.poetry_count == 0:
            self.report()
            from twisted.internet import reactor
            reactor.stop()

    def report(self):
        for i in self.poems:
            print &apos;Task %d: %d bytes of poetry&apos; % (i, len(self.poems[i]))

    def clientConnectionFailed(self, connector, reason):
        print &apos;Failed to connect to:&apos;, connector.getDestination()
        self.poem_finished()


def poetry_main():
    addresses = parse_args()

    start = datetime.datetime.now()

    factory = PoetryClientFactory(len(addresses)) 创建factory

    from twisted.internet import reactor

    for address in addresses:
        host, port = address
        reactor.connectTCP(host, port, factory) 创建协议

    reactor.run()

    elapsed = datetime.datetime.now() - start

    print &apos;Got %d poems in %s&apos; % (len(addresses), elapsed)


if __name__ == &apos;__main__&apos;:
    poetry_main()</code></pre><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted2.png" alt=""></p>
<pre><code># This is the Twisted Get Poetry Now! client, version 3.0.

# NOTE: This should not be used as the basis for production code.

import optparse

from twisted.internet.protocol import Protocol, ClientFactory


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, Twisted version 3.0
Run it like this:
  python get-poetry-1.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python twisted-client-3/get-poetry-1.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


class PoetryProtocol(Protocol):

    poem = &apos;&apos;

    def dataReceived(self, data):
        self.poem += data

    def connectionLost(self, reason):
        self.poemReceived(self.poem)

    def poemReceived(self, poem):
        self.factory.poem_finished(poem)


class PoetryClientFactory(ClientFactory):

    protocol = PoetryProtocol

    def __init__(self, callback):
        self.callback = callback

    def poem_finished(self, poem):
        self.callback(poem)


def get_poetry(host, port, callback):
    &quot;&quot;&quot;
    Download a poem from the given host and port and invoke
      callback(poem)
    when the poem is complete.
    &quot;&quot;&quot;
    from twisted.internet import reactor
    factory = PoetryClientFactory(callback)
    reactor.connectTCP(host, port, factory)


def poetry_main():
    addresses = parse_args()

    from twisted.internet import reactor

    poems = []

    def got_poem(poem):
        poems.append(poem)
        if len(poems) == len(addresses):
            reactor.stop()

    for address in addresses:
        host, port = address
        get_poetry(host, port, got_poem)

    reactor.run()

    for poem in poems:
        print poem


if __name__ == &apos;__main__&apos;:
    poetry_main()</code></pre><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted3.png" alt=""></p>
<p>Deferred 管理回调函数</p>
<p>deferred.callback errback 不能被调用两次<br>    from twisted.internet.defer import Deferred</p>
<pre><code>def got_poem(res):
    print &apos;Your poem is served:&apos;
    print res

def poem_failed(err):
    print &apos;No poetry for you.&apos;

d = Deferred()

# add a callback/errback pair to the chain
d.addCallbacks(got_poem, poem_failed)

# fire the chain with a normal result
d.callback(&apos;This poem is short.&apos;)

print &quot;Finished&quot;


from twisted.internet.defer import Deferred
from twisted.python.failure import Failure

def got_poem(res):
    print &apos;Your poem is served:&apos;
    print res

def poem_failed(err):
    print &apos;No poetry for you.&apos;

d = Deferred()

# add a callback/errback pair to the chain
d.addCallbacks(got_poem, poem_failed)

# fire the chain with an error result
d.errback(Failure(Exception(&apos;I have failed.&apos;)))

print &quot;Finished&quot;



# This is the Twisted Get Poetry Now! client, version 4.0

import optparse, sys

from twisted.internet import defer
from twisted.internet.protocol import Protocol, ClientFactory


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, Twisted version 4.0
Run it like this:
  python get-poetry.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python twisted-client-4/get-poetry.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


class PoetryProtocol(Protocol):

    poem = &apos;&apos;

    def dataReceived(self, data):
        self.poem += data

    def connectionLost(self, reason):
        self.poemReceived(self.poem)

    def poemReceived(self, poem):
        self.factory.poem_finished(poem)


class PoetryClientFactory(ClientFactory):

    protocol = PoetryProtocol

    def __init__(self, deferred):
        self.deferred = deferred

    def poem_finished(self, poem):
        if self.deferred is not None:
            d, self.deferred = self.deferred, None
            d.callback(poem)

    def clientConnectionFailed(self, connector, reason):
        if self.deferred is not None:
            d, self.deferred = self.deferred, None
            d.errback(reason)


def get_poetry(host, port):
    &quot;&quot;&quot;
    Download a poem from the given host and port. This function
    returns a Deferred which will be fired with the complete text of
    the poem or a Failure if the poem could not be downloaded.
    &quot;&quot;&quot;
    d = defer.Deferred()
    from twisted.internet import reactor
    factory = PoetryClientFactory(d)
    reactor.connectTCP(host, port, factory)
    return d


def poetry_main():
    addresses = parse_args()

    from twisted.internet import reactor

    poems = []
    errors = []

    def got_poem(poem):
        poems.append(poem)

    def poem_failed(err):
        print &gt;&gt;sys.stderr, &apos;Poem failed:&apos;, err
        errors.append(err)

    def poem_done(_):
        if len(poems) + len(errors) == len(addresses):
            reactor.stop()

    for address in addresses:
        host, port = address
        d = get_poetry(host, port)
        d.addCallbacks(got_poem, poem_failed)
        d.addBoth(poem_done)

    reactor.run()

    for poem in poems:
        print poem


if __name__ == &apos;__main__&apos;:
    poetry_main()</code></pre><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted4.png" alt=""></p>
<pre><code>socket.setblocking(flag)

Set blocking or non-blocking mode of the socket: if flag is 0, the socket is set to non-blocking, else to blocking mode. Initially all sockets are in blocking mode. In non-blocking mode, if a recv() call doesn’t find any data, or if a send() call can’t immediately dispose of the data, a error exception is raised; in blocking mode, the calls block until they can proceed. s.setblocking(0) is equivalent to s.settimeout(0.0); s.setblocking(1) is equivalent to s.settimeout(None).



class ClientFactory(Factory):
    &quot;&quot;&quot;A Protocol factory for clients.

    This can be used together with the various connectXXX methods in
    reactors.
    &quot;&quot;&quot;

    def startedConnecting(self, connector):
        &quot;&quot;&quot;Called when a connection has been started.

        You can call connector.stopConnecting() to stop the connection attempt.

        @param connector: a Connector object.
        &quot;&quot;&quot;

    def clientConnectionFailed(self, connector, reason):
        &quot;&quot;&quot;Called when a connection has failed to connect.

        It may be useful to call connector.connect() - this will reconnect.

        @type reason: L{twisted.python.failure.Failure}
        &quot;&quot;&quot;

    def clientConnectionLost(self, connector, reason):
        &quot;&quot;&quot;Called when an established connection is lost.

        It may be useful to call connector.connect() - this will reconnect.

        @type reason: L{twisted.python.failure.Failure}
        &quot;&quot;&quot;





@implementer(interfaces.IProtocolFactory, interfaces.ILoggingContext)
class Factory:
    &quot;&quot;&quot;
    This is a factory which produces protocols.

    By default, buildProtocol will create a protocol of the class given in
    self.protocol.
    &quot;&quot;&quot;

    # put a subclass of Protocol here:
    protocol = None

    numPorts = 0
    noisy = True

    @classmethod
    def forProtocol(cls, protocol, *args, **kwargs):
        &quot;&quot;&quot;
        Create a factory for the given protocol.

        It sets the C{protocol} attribute and returns the constructed factory
        instance.

        @param protocol: A L{Protocol} subclass

        @param args: Positional arguments for the factory.

        @param kwargs: Keyword arguments for the factory.

        @return: A L{Factory} instance wired up to C{protocol}.
        &quot;&quot;&quot;
        factory = cls(*args, **kwargs)
        factory.protocol = protocol
        return factory


    def logPrefix(self):
        &quot;&quot;&quot;
        Describe this factory for log messages.
        &quot;&quot;&quot;
        return self.__class__.__name__


    def doStart(self):
        &quot;&quot;&quot;Make sure startFactory is called.

        Users should not call this function themselves!
        &quot;&quot;&quot;
        if not self.numPorts:
            if self.noisy:
                log.msg(&quot;Starting factory %r&quot; % self)
            self.startFactory()
        self.numPorts = self.numPorts + 1

    def doStop(self):
        &quot;&quot;&quot;Make sure stopFactory is called.

        Users should not call this function themselves!
        &quot;&quot;&quot;
        if self.numPorts == 0:
            # this shouldn&apos;t happen, but does sometimes and this is better
            # than blowing up in assert as we did previously.
            return
        self.numPorts = self.numPorts - 1
        if not self.numPorts:
            if self.noisy:
                log.msg(&quot;Stopping factory %r&quot; % self)
            self.stopFactory()

    def startFactory(self):
        &quot;&quot;&quot;This will be called before I begin listening on a Port or Connector.

        It will only be called once, even if the factory is connected
        to multiple ports.

        This can be used to perform &apos;unserialization&apos; tasks that
        are best put off until things are actually running, such
        as connecting to a database, opening files, etcetera.
        &quot;&quot;&quot;

    def stopFactory(self):
        &quot;&quot;&quot;This will be called before I stop listening on all Ports/Connectors.

        This can be overridden to perform &apos;shutdown&apos; tasks such as disconnecting
        database connections, closing files, etc.

        It will be called, for example, before an application shuts down,
        if it was connected to a port. User code should not call this function
        directly.
        &quot;&quot;&quot;


    def buildProtocol(self, addr):
        &quot;&quot;&quot;
        Create an instance of a subclass of Protocol.

        The returned instance will handle input on an incoming server
        connection, and an attribute &quot;factory&quot; pointing to the creating
        factory.

        Alternatively, C{None} may be returned to immediately close the
        new connection.

        Override this method to alter how Protocol instances get created.

        @param addr: an object implementing L{twisted.internet.interfaces.IAddress}
        &quot;&quot;&quot;
        p = self.protocol()
        p.factory = self
        return p</code></pre><p>###安装</p>
<pre><code>sudo pip install lxml==3.1.2 --trusted-host pypi.python.org

sudo pip install Scrapy --trusted-host pypi.python.org</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/02/15/2015-2-15-Twisted/" data-id="ck521h1b80078lc7k6ip1altx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/02/15/2015-2-15-python%E9%97%AD%E5%8C%85/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          闭包
        
      </div>
    </a>
  
  
    <a href="/2015/02/13/2015-2-13-tornado/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">tornado</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/06/2018-6-3-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">2018-6-3-代码规范</a>
          </li>
        
          <li>
            <a href="/2020/01/05/2020-1-5-datax/">离线同步工具DataX</a>
          </li>
        
          <li>
            <a href="/2019/12/31/2019-12-31-replicate/">分布式系统数据同步</a>
          </li>
        
          <li>
            <a href="/2019/12/28/2019-12-28-LCH/">LCH</a>
          </li>
        
          <li>
            <a href="/2019/12/26/2019-12-26-lambda/">lambda</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
<!DOCTYPE html>


  <html class="light page-default">


<head>
  <meta charset="utf-8">
  
  <title>Twisted | Hexo</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="后端、技术、博客、架构、全栈" />
  

  <meta name="description" content="##Twisted reactor+deferred 没使用reactor的异步客户端  # This is the asynchronous Get Poetry Now! client.  import datetime, errno, optparse, select, socket   def parse_args():     usage &#x3D; &quot;&quot;&quot;usag">
<meta property="og:type" content="article">
<meta property="og:title" content="Twisted">
<meta property="og:url" content="http://yoursite.com/2015/02/15/2015-2-15-Twisted/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="##Twisted reactor+deferred 没使用reactor的异步客户端  # This is the asynchronous Get Poetry Now! client.  import datetime, errno, optparse, select, socket   def parse_args():     usage &#x3D; &quot;&quot;&quot;usag">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted.PNG">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted.PNG">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted2.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted3.png">
<meta property="og:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted4.png">
<meta property="article:published_time" content="2015-02-14T16:00:00.000Z">
<meta property="article:modified_time" content="2020-01-06T07:17:32.494Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted.PNG">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?65e0b4df283d78e15f8c78f238ec9593";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
    </ul>
  </div>


</div>




<div class="content content-post CENTER">
   <article id="default-2015-2-15-Twisted" class="article article-type-default" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Twisted</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2015.02.15</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>John Doe</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>##Twisted</p>
<p>reactor+deferred</p>
<pre><code>没使用reactor的异步客户端

# This is the asynchronous Get Poetry Now! client.

import datetime, errno, optparse, select, socket


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, asynchronous edition.
Run it like this:
  python get-poetry.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python async-client/get-poetry.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


def get_poetry(sockets):
    &quot;&quot;&quot;Download poety from all the given sockets.&quot;&quot;&quot;

    poems = dict.fromkeys(sockets, &apos;&apos;) # socket -&gt; accumulated poem

    # socket -&gt; task numbers
    sock2task = dict([(s, i + 1) for i, s in enumerate(sockets)])

    sockets = list(sockets) # make a copy

    # we go around this loop until we&apos;ve gotten all the poetry
    # from all the sockets. This is the &apos;reactor loop&apos;.

    while sockets:
        # this select call blocks until one or more of the
        # sockets is ready for read I/O
        rlist, _, _ = select.select(sockets, [], [])

        # rlist is the list of sockets with data ready to read

        for sock in rlist:
            data = &apos;&apos;

            while True:
                try:
                    new_data = sock.recv(1024)
                except socket.error, e:
                    if e.args[0] == errno.EWOULDBLOCK:
                        # this error code means we would have
                        # blocked if the socket was blocking.
                        # instead we skip to the next socket
                        break
                    raise
                else:
                    if not new_data:
                        break
                    else:
                        data += new_data

            # Each execution of this inner loop corresponds to
            # working on one asynchronous task in Figure 3 here:
            # http://krondo.com/?p=1209#figure3

            task_num = sock2task[sock]

            if not data:
                sockets.remove(sock)
                sock.close()
                print &apos;Task %d finished&apos; % task_num
            else:
                addr_fmt = format_address(sock.getpeername())
                msg = &apos;Task %d: got %d bytes of poetry from %s&apos;
                print  msg % (task_num, len(data), addr_fmt)

            poems[sock] += data

    return poems


def connect(address):
    &quot;&quot;&quot;Connect to the given server and return a non-blocking socket.&quot;&quot;&quot;

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(address)
    sock.setblocking(0)
    return sock


def format_address(address):
    host, port = address
    return &apos;%s:%s&apos; % (host or &apos;127.0.0.1&apos;, port)


def main():
    addresses = parse_args()

    start = datetime.datetime.now()

    sockets = map(connect, addresses)

    poems = get_poetry(sockets)

    elapsed = datetime.datetime.now() - start

    for i, sock in enumerate(sockets):
        print &apos;Task %d: %d bytes of poetry&apos; % (i + 1, len(poems[sock]))

    print &apos;Got %d poems in %s&apos; % (len(addresses), elapsed)


if __name__ == &apos;__main__&apos;:
    main()


twisted异步客户端
    # This is the Twisted Get Poetry Now! client, version 1.0.

# NOTE: This should not be used as the basis for production code.
# It uses low-level Twisted APIs as a learning exercise.

import datetime, errno, optparse, socket

from twisted.internet import main


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, Twisted version 1.0.
Run it like this:
  python get-poetry.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python twisted-client-1/get-poetry.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


class PoetrySocket(object):

    poem = &apos;&apos;

    def __init__(self, task_num, address):
        self.task_num = task_num
        self.address = address
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect(address)
        self.sock.setblocking(0)

        # tell the Twisted reactor to monitor this socket for reading
        from twisted.internet import reactor
        reactor.addReader(self)

    def fileno(self):
        try:
            return self.sock.fileno()
        except socket.error:
            return -1

    def connectionLost(self, reason):
        self.sock.close()

        # stop monitoring this socket
        from twisted.internet import reactor
        reactor.removeReader(self)

        # see if there are any poetry sockets left
        for reader in reactor.getReaders():
            if isinstance(reader, PoetrySocket):
                return

        reactor.stop() # no more poetry

    def doRead(self):
        bytes = &apos;&apos;

        while True:
            try:
                bytesread = self.sock.recv(1024)
                if not bytesread:
                    break
                else:
                    bytes += bytesread
            except socket.error, e:
                if e.args[0] == errno.EWOULDBLOCK:
                    break
                return main.CONNECTION_LOST

        if not bytes:
            print &apos;Task %d finished&apos; % self.task_num
            return main.CONNECTION_DONE
        else:
            msg = &apos;Task %d: got %d bytes of poetry from %s&apos;
            print  msg % (self.task_num, len(bytes), self.format_addr())

        self.poem += bytes

    def logPrefix(self):
        return &apos;poetry&apos;

    def format_addr(self):
        host, port = self.address
        return &apos;%s:%s&apos; % (host or &apos;127.0.0.1&apos;, port)


def poetry_main():
    addresses = parse_args()

    start = datetime.datetime.now()

    sockets = [PoetrySocket(i + 1, addr) for i, addr in enumerate(addresses)]

    from twisted.internet import reactor
    reactor.run()

    elapsed = datetime.datetime.now() - start

    for i, sock in enumerate(sockets):
        print &apos;Task %d: %d bytes of poetry&apos; % (i + 1, len(sock.poem))

    print &apos;Got %d poems in %s&apos; % (len(addresses), elapsed)


if __name__ == &apos;__main__&apos;:
    poetry_main()</code></pre><p>IReactorFDSet是一个Twisted的reactor实现的接口</p>
<p>epollreactor</p>
<pre><code>def doPoll(self, timeout):
     &quot;&quot;&quot;
     Poll the poller for new events.
     &quot;&quot;&quot;
     if timeout is None:
         timeout = -1  # Wait indefinitely.

     try:
         # Limit the number of events to the number of io objects we&apos;re
         # currently tracking (because that&apos;s maybe a good heuristic) and
         # the amount of time we block to the value specified by our
         # caller.
         l = self._poller.poll(timeout, len(self._selectables))
     except IOError as err:
         if err.errno == errno.EINTR:
             return
         # See epoll_wait(2) for documentation on the other conditions
         # under which this can fail.  They can only be due to a serious
         # programming error on our part, so let&apos;s just announce them
         # loudly.
         raise

     _drdw = self._doReadOrWrite
     for fd, event in l:
         try:
             selectable = self._selectables[fd]
         except KeyError:
             pass
         else:
             log.callWithLogger(selectable, _drdw, selectable, fd, event)</code></pre><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted.PNG" alt=""></p>
<p>run</p>
<p>回调函数的实现，通过传入类，重写基类的函数</p>
<p>有很多抽象类</p>
<p>有关socket的操作由Protocol类完成，抽象了底层，提供操作数据流的接口，即实现数据协议</p>
<pre><code># This is the Twisted Get Poetry Now! client, version 2.0.

# NOTE: This should not be used as the basis for production code.

import datetime, optparse

from twisted.internet.protocol import Protocol, ClientFactory


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, Twisted version 2.0.
Run it like this:
  python get-poetry.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python twisted-client-2/get-poetry.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


class PoetryProtocol(Protocol):

    poem = &apos;&apos;
    task_num = 0

    def dataReceived(self, data):
        self.poem += data
        msg = &apos;Task %d: got %d bytes of poetry from %s&apos;
        print  msg % (self.task_num, len(data), self.transport.getPeer())

    def connectionLost(self, reason):
        self.poemReceived(self.poem)

    def poemReceived(self, poem):
        self.factory.poem_finished(self.task_num, poem)


class PoetryClientFactory(ClientFactory):

    task_num = 1

    protocol = PoetryProtocol # tell base class what proto to build

    def __init__(self, poetry_count):
        self.poetry_count = poetry_count
        self.poems = {} # task num -&gt; poem

    def buildProtocol(self, address):
        proto = ClientFactory.buildProtocol(self, address)
        proto.task_num = self.task_num
        self.task_num += 1
        return proto

    def poem_finished(self, task_num=None, poem=None):
        if task_num is not None:
            self.poems[task_num] = poem

        self.poetry_count -= 1

        if self.poetry_count == 0:
            self.report()
            from twisted.internet import reactor
            reactor.stop()

    def report(self):
        for i in self.poems:
            print &apos;Task %d: %d bytes of poetry&apos; % (i, len(self.poems[i]))

    def clientConnectionFailed(self, connector, reason):
        print &apos;Failed to connect to:&apos;, connector.getDestination()
        self.poem_finished()


def poetry_main():
    addresses = parse_args()

    start = datetime.datetime.now()

    factory = PoetryClientFactory(len(addresses))

    from twisted.internet import reactor

    for address in addresses:
        host, port = address
        reactor.connectTCP(host, port, factory)

    reactor.run()

    elapsed = datetime.datetime.now() - start

    print &apos;Got %d poems in %s&apos; % (len(addresses), elapsed)


if __name__ == &apos;__main__&apos;:
    poetry_main()


 reactor.connectTCP(host, port, factory)-&gt; buildProtocol(self, address):</code></pre><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted.PNG" alt=""></p>
<p>加入Transports，Protocols</p>
<pre><code># This is the Twisted Get Poetry Now! client, version 2.0.

# NOTE: This should not be used as the basis for production code.

import datetime, optparse

from twisted.internet.protocol import Protocol, ClientFactory


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, Twisted version 2.0.
Run it like this:
  python get-poetry.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python twisted-client-2/get-poetry.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


class PoetryProtocol(Protocol):处理接收的数据

    poem = &apos;&apos;
    task_num = 0

    def dataReceived(self, data):
        self.poem += data
        msg = &apos;Task %d: got %d bytes of poetry from %s&apos;
        print  msg % (self.task_num, len(data), self.transport.getPeer())

    def connectionLost(self, reason):
        self.poemReceived(self.poem)

    def poemReceived(self, poem):
        self.factory.poem_finished(self.task_num, poem)


class PoetryClientFactory(ClientFactory):

    task_num = 1

    protocol = PoetryProtocol # tell base class what proto to build

    def __init__(self, poetry_count):
        self.poetry_count = poetry_count
        self.poems = {} # task num -&gt; poem

    def buildProtocol(self, address):
        proto = ClientFactory.buildProtocol(self, address)
        proto.task_num = self.task_num
        self.task_num += 1
        return proto

    def poem_finished(self, task_num=None, poem=None):
        if task_num is not None:
            self.poems[task_num] = poem

        self.poetry_count -= 1

        if self.poetry_count == 0:
            self.report()
            from twisted.internet import reactor
            reactor.stop()

    def report(self):
        for i in self.poems:
            print &apos;Task %d: %d bytes of poetry&apos; % (i, len(self.poems[i]))

    def clientConnectionFailed(self, connector, reason):
        print &apos;Failed to connect to:&apos;, connector.getDestination()
        self.poem_finished()


def poetry_main():
    addresses = parse_args()

    start = datetime.datetime.now()

    factory = PoetryClientFactory(len(addresses)) 创建factory

    from twisted.internet import reactor

    for address in addresses:
        host, port = address
        reactor.connectTCP(host, port, factory) 创建协议

    reactor.run()

    elapsed = datetime.datetime.now() - start

    print &apos;Got %d poems in %s&apos; % (len(addresses), elapsed)


if __name__ == &apos;__main__&apos;:
    poetry_main()</code></pre><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted2.png" alt=""></p>
<pre><code># This is the Twisted Get Poetry Now! client, version 3.0.

# NOTE: This should not be used as the basis for production code.

import optparse

from twisted.internet.protocol import Protocol, ClientFactory


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, Twisted version 3.0
Run it like this:
  python get-poetry-1.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python twisted-client-3/get-poetry-1.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


class PoetryProtocol(Protocol):

    poem = &apos;&apos;

    def dataReceived(self, data):
        self.poem += data

    def connectionLost(self, reason):
        self.poemReceived(self.poem)

    def poemReceived(self, poem):
        self.factory.poem_finished(poem)


class PoetryClientFactory(ClientFactory):

    protocol = PoetryProtocol

    def __init__(self, callback):
        self.callback = callback

    def poem_finished(self, poem):
        self.callback(poem)


def get_poetry(host, port, callback):
    &quot;&quot;&quot;
    Download a poem from the given host and port and invoke
      callback(poem)
    when the poem is complete.
    &quot;&quot;&quot;
    from twisted.internet import reactor
    factory = PoetryClientFactory(callback)
    reactor.connectTCP(host, port, factory)


def poetry_main():
    addresses = parse_args()

    from twisted.internet import reactor

    poems = []

    def got_poem(poem):
        poems.append(poem)
        if len(poems) == len(addresses):
            reactor.stop()

    for address in addresses:
        host, port = address
        get_poetry(host, port, got_poem)

    reactor.run()

    for poem in poems:
        print poem


if __name__ == &apos;__main__&apos;:
    poetry_main()</code></pre><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted3.png" alt=""></p>
<p>Deferred 管理回调函数</p>
<p>deferred.callback errback 不能被调用两次<br>    from twisted.internet.defer import Deferred</p>
<pre><code>def got_poem(res):
    print &apos;Your poem is served:&apos;
    print res

def poem_failed(err):
    print &apos;No poetry for you.&apos;

d = Deferred()

# add a callback/errback pair to the chain
d.addCallbacks(got_poem, poem_failed)

# fire the chain with a normal result
d.callback(&apos;This poem is short.&apos;)

print &quot;Finished&quot;


from twisted.internet.defer import Deferred
from twisted.python.failure import Failure

def got_poem(res):
    print &apos;Your poem is served:&apos;
    print res

def poem_failed(err):
    print &apos;No poetry for you.&apos;

d = Deferred()

# add a callback/errback pair to the chain
d.addCallbacks(got_poem, poem_failed)

# fire the chain with an error result
d.errback(Failure(Exception(&apos;I have failed.&apos;)))

print &quot;Finished&quot;



# This is the Twisted Get Poetry Now! client, version 4.0

import optparse, sys

from twisted.internet import defer
from twisted.internet.protocol import Protocol, ClientFactory


def parse_args():
    usage = &quot;&quot;&quot;usage: %prog [options] [hostname]:port ...
This is the Get Poetry Now! client, Twisted version 4.0
Run it like this:
  python get-poetry.py port1 port2 port3 ...
If you are in the base directory of the twisted-intro package,
you could run it like this:
  python twisted-client-4/get-poetry.py 10001 10002 10003
to grab poetry from servers on ports 10001, 10002, and 10003.
Of course, there need to be servers listening on those ports
for that to work.
&quot;&quot;&quot;

    parser = optparse.OptionParser(usage)

    _, addresses = parser.parse_args()

    if not addresses:
        print parser.format_help()
        parser.exit()

    def parse_address(addr):
        if &apos;:&apos; not in addr:
            host = &apos;127.0.0.1&apos;
            port = addr
        else:
            host, port = addr.split(&apos;:&apos;, 1)

        if not port.isdigit():
            parser.error(&apos;Ports must be integers.&apos;)

        return host, int(port)

    return map(parse_address, addresses)


class PoetryProtocol(Protocol):

    poem = &apos;&apos;

    def dataReceived(self, data):
        self.poem += data

    def connectionLost(self, reason):
        self.poemReceived(self.poem)

    def poemReceived(self, poem):
        self.factory.poem_finished(poem)


class PoetryClientFactory(ClientFactory):

    protocol = PoetryProtocol

    def __init__(self, deferred):
        self.deferred = deferred

    def poem_finished(self, poem):
        if self.deferred is not None:
            d, self.deferred = self.deferred, None
            d.callback(poem)

    def clientConnectionFailed(self, connector, reason):
        if self.deferred is not None:
            d, self.deferred = self.deferred, None
            d.errback(reason)


def get_poetry(host, port):
    &quot;&quot;&quot;
    Download a poem from the given host and port. This function
    returns a Deferred which will be fired with the complete text of
    the poem or a Failure if the poem could not be downloaded.
    &quot;&quot;&quot;
    d = defer.Deferred()
    from twisted.internet import reactor
    factory = PoetryClientFactory(d)
    reactor.connectTCP(host, port, factory)
    return d


def poetry_main():
    addresses = parse_args()

    from twisted.internet import reactor

    poems = []
    errors = []

    def got_poem(poem):
        poems.append(poem)

    def poem_failed(err):
        print &gt;&gt;sys.stderr, &apos;Poem failed:&apos;, err
        errors.append(err)

    def poem_done(_):
        if len(poems) + len(errors) == len(addresses):
            reactor.stop()

    for address in addresses:
        host, port = address
        d = get_poetry(host, port)
        d.addCallbacks(got_poem, poem_failed)
        d.addBoth(poem_done)

    reactor.run()

    for poem in poems:
        print poem


if __name__ == &apos;__main__&apos;:
    poetry_main()</code></pre><p><img src="https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/twisted4.png" alt=""></p>
<pre><code>socket.setblocking(flag)

Set blocking or non-blocking mode of the socket: if flag is 0, the socket is set to non-blocking, else to blocking mode. Initially all sockets are in blocking mode. In non-blocking mode, if a recv() call doesn’t find any data, or if a send() call can’t immediately dispose of the data, a error exception is raised; in blocking mode, the calls block until they can proceed. s.setblocking(0) is equivalent to s.settimeout(0.0); s.setblocking(1) is equivalent to s.settimeout(None).



class ClientFactory(Factory):
    &quot;&quot;&quot;A Protocol factory for clients.

    This can be used together with the various connectXXX methods in
    reactors.
    &quot;&quot;&quot;

    def startedConnecting(self, connector):
        &quot;&quot;&quot;Called when a connection has been started.

        You can call connector.stopConnecting() to stop the connection attempt.

        @param connector: a Connector object.
        &quot;&quot;&quot;

    def clientConnectionFailed(self, connector, reason):
        &quot;&quot;&quot;Called when a connection has failed to connect.

        It may be useful to call connector.connect() - this will reconnect.

        @type reason: L{twisted.python.failure.Failure}
        &quot;&quot;&quot;

    def clientConnectionLost(self, connector, reason):
        &quot;&quot;&quot;Called when an established connection is lost.

        It may be useful to call connector.connect() - this will reconnect.

        @type reason: L{twisted.python.failure.Failure}
        &quot;&quot;&quot;





@implementer(interfaces.IProtocolFactory, interfaces.ILoggingContext)
class Factory:
    &quot;&quot;&quot;
    This is a factory which produces protocols.

    By default, buildProtocol will create a protocol of the class given in
    self.protocol.
    &quot;&quot;&quot;

    # put a subclass of Protocol here:
    protocol = None

    numPorts = 0
    noisy = True

    @classmethod
    def forProtocol(cls, protocol, *args, **kwargs):
        &quot;&quot;&quot;
        Create a factory for the given protocol.

        It sets the C{protocol} attribute and returns the constructed factory
        instance.

        @param protocol: A L{Protocol} subclass

        @param args: Positional arguments for the factory.

        @param kwargs: Keyword arguments for the factory.

        @return: A L{Factory} instance wired up to C{protocol}.
        &quot;&quot;&quot;
        factory = cls(*args, **kwargs)
        factory.protocol = protocol
        return factory


    def logPrefix(self):
        &quot;&quot;&quot;
        Describe this factory for log messages.
        &quot;&quot;&quot;
        return self.__class__.__name__


    def doStart(self):
        &quot;&quot;&quot;Make sure startFactory is called.

        Users should not call this function themselves!
        &quot;&quot;&quot;
        if not self.numPorts:
            if self.noisy:
                log.msg(&quot;Starting factory %r&quot; % self)
            self.startFactory()
        self.numPorts = self.numPorts + 1

    def doStop(self):
        &quot;&quot;&quot;Make sure stopFactory is called.

        Users should not call this function themselves!
        &quot;&quot;&quot;
        if self.numPorts == 0:
            # this shouldn&apos;t happen, but does sometimes and this is better
            # than blowing up in assert as we did previously.
            return
        self.numPorts = self.numPorts - 1
        if not self.numPorts:
            if self.noisy:
                log.msg(&quot;Stopping factory %r&quot; % self)
            self.stopFactory()

    def startFactory(self):
        &quot;&quot;&quot;This will be called before I begin listening on a Port or Connector.

        It will only be called once, even if the factory is connected
        to multiple ports.

        This can be used to perform &apos;unserialization&apos; tasks that
        are best put off until things are actually running, such
        as connecting to a database, opening files, etcetera.
        &quot;&quot;&quot;

    def stopFactory(self):
        &quot;&quot;&quot;This will be called before I stop listening on all Ports/Connectors.

        This can be overridden to perform &apos;shutdown&apos; tasks such as disconnecting
        database connections, closing files, etc.

        It will be called, for example, before an application shuts down,
        if it was connected to a port. User code should not call this function
        directly.
        &quot;&quot;&quot;


    def buildProtocol(self, addr):
        &quot;&quot;&quot;
        Create an instance of a subclass of Protocol.

        The returned instance will handle input on an incoming server
        connection, and an attribute &quot;factory&quot; pointing to the creating
        factory.

        Alternatively, C{None} may be returned to immediately close the
        new connection.

        Override this method to alter how Protocol instances get created.

        @param addr: an object implementing L{twisted.internet.interfaces.IAddress}
        &quot;&quot;&quot;
        p = self.protocol()
        p.factory = self
        return p</code></pre><p>###安装</p>
<pre><code>sudo pip install lxml==3.1.2 --trusted-host pypi.python.org

sudo pip install Scrapy --trusted-host pypi.python.org</code></pre>
    
  </div>

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2015/02/13/2015-2-13-tornado/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2015/02/15/2015-2-15-scrapy/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-default">
    

    

    
    

    

    
    

    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
